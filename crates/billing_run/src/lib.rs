#![no_std]
#![allow(unused_imports)]
extern crate alloc;
use alloc::string::ToString;
use chrono::Datelike as _;
#[cfg(feature = "arrow")]
extern crate std;
pub struct BillingAspayments7 {
    extract_row_partition: alloc::boxed::Box<
        dyn Fn(
            &BillingAspayments7Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    >,
    row_partition_key: mmsdm_core::PartitionKey,
}
impl BillingAspayments7 {
    pub fn new(
        row_partition_key: mmsdm_core::PartitionKey,
        func: impl Fn(
            &<Self as mmsdm_core::GetTable>::Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    ) -> Self {
        Self {
            extract_row_partition: alloc::boxed::Box::new(func),
            row_partition_key,
        }
    }
}
pub struct BillingAspayments7Mapping([usize; 26]);
/// # Summary
///
/// ## BILLINGASPAYMENTS
///  _BILLINGASPAYMENTS shows Ancillary Service payments for each billing period by each of the Ancillary Service types for each participantâ€™s connection points._
///
/// * Data Set Name: Billing
/// * File Name: Aspayments
/// * Data Version: 7
///
/// # Description
///  BILLINGASPAYMENTS data is confidential to relevant participant. Source Updated  with each billing run. Volume The volume is according to the number of Transmission ConnectionPointIDs a Participant may have subject to ancillary payment per billrunno. An indicative maximum is approximately 20 records are inserted per billrunno, or about 220 records inserted per week.
///
///
///
/// # Primary Key Columns
///
/// * BILLRUNNO
/// * CONNECTIONPOINTID
/// * CONTRACTYEAR
/// * PARTICIPANTID
/// * WEEKNO
#[derive(Debug, PartialEq, Eq)]
pub struct BillingAspayments7Row<'data> {
    /// Region Identifier
    pub regionid: core::ops::Range<usize>,
    /// Contract Year
    pub contractyear: rust_decimal::Decimal,
    /// Week No
    pub weekno: rust_decimal::Decimal,
    /// Billing Run No.
    pub billrunno: rust_decimal::Decimal,
    /// Participant Identifier
    pub participantid: core::ops::Range<usize>,
    /// Connection point identifier
    pub connectionpointid: core::ops::Range<usize>,
    /// Raise 6 Sec Payments
    pub raise6sec: Option<rust_decimal::Decimal>,
    /// Lower 6 Sec Payments
    pub lower6sec: Option<rust_decimal::Decimal>,
    /// Raise 60 Sec Payments
    pub raise60sec: Option<rust_decimal::Decimal>,
    /// Lower 60 Sec Payments
    pub lower60sec: Option<rust_decimal::Decimal>,
    /// AGC Payments
    pub agc: Option<rust_decimal::Decimal>,
    /// Frequency Control Compensation Payments
    pub fcascomp: Option<rust_decimal::Decimal>,
    /// Load Shed Payments
    pub loadshed: Option<rust_decimal::Decimal>,
    /// Rapid Generator unit Loading Payments
    pub rgul: Option<rust_decimal::Decimal>,
    /// Rapid Generator Unit Unloading Payments
    pub rguu: Option<rust_decimal::Decimal>,
    /// Reactive Power Payments
    pub reactivepower: Option<rust_decimal::Decimal>,
    /// System Restart Payments
    pub systemrestart: Option<rust_decimal::Decimal>,
    /// The latest date and time that a file was updated or inserted
    pub lastchanged: Option<chrono::NaiveDateTime>,
    /// Lower 5 Minute Payment
    pub lower5min: Option<rust_decimal::Decimal>,
    /// Raise 5 Minute Payment
    pub raise5min: Option<rust_decimal::Decimal>,
    /// Lower 5 Minute Regulation Payment
    pub lowerreg: Option<rust_decimal::Decimal>,
    /// Raise 5 Minute Regulation Payment
    pub raisereg: Option<rust_decimal::Decimal>,
    /// The total availability payment
    pub availability_reactive: Option<rust_decimal::Decimal>,
    /// The total availability payment rebate
    pub availability_reactive_rbt: Option<rust_decimal::Decimal>,
    /// Payment amount for the very fast raise service
    pub raise1sec: Option<rust_decimal::Decimal>,
    /// Payment amount for the very fast lower service
    pub lower1sec: Option<rust_decimal::Decimal>,
    backing_data: mmsdm_core::CsvRow<'data>,
}
impl<'data> BillingAspayments7Row<'data> {
    pub fn regionid(&self) -> Option<&str> {
        if self.regionid.is_empty() {
            None
        } else {
            Some(
                core::ops::Index::index(
                    self.backing_data.as_slice(),
                    self.regionid.clone(),
                ),
            )
        }
    }
    pub fn participantid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.participantid.clone())
    }
    pub fn connectionpointid(&self) -> &str {
        core::ops::Index::index(
            self.backing_data.as_slice(),
            self.connectionpointid.clone(),
        )
    }
}
impl mmsdm_core::GetTable for BillingAspayments7 {
    const VERSION: i32 = 7;
    const DATA_SET_NAME: &'static str = "BILLING";
    const TABLE_NAME: &'static str = "ASPAYMENTS";
    const DEFAULT_FIELD_MAPPING: Self::FieldMapping = BillingAspayments7Mapping([
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        27,
        28,
        29,
    ]);
    const COLUMNS: &'static [&'static str] = &[
        "REGIONID",
        "CONTRACTYEAR",
        "WEEKNO",
        "BILLRUNNO",
        "PARTICIPANTID",
        "CONNECTIONPOINTID",
        "RAISE6SEC",
        "LOWER6SEC",
        "RAISE60SEC",
        "LOWER60SEC",
        "AGC",
        "FCASCOMP",
        "LOADSHED",
        "RGUL",
        "RGUU",
        "REACTIVEPOWER",
        "SYSTEMRESTART",
        "LASTCHANGED",
        "LOWER5MIN",
        "RAISE5MIN",
        "LOWERREG",
        "RAISEREG",
        "AVAILABILITY_REACTIVE",
        "AVAILABILITY_REACTIVE_RBT",
        "RAISE1SEC",
        "LOWER1SEC",
    ];
    type Row<'row> = BillingAspayments7Row<'row>;
    type FieldMapping = BillingAspayments7Mapping;
    type PrimaryKey = BillingAspayments7PrimaryKey;
    fn from_row<'data>(
        row: mmsdm_core::CsvRow<'data>,
        field_mapping: &Self::FieldMapping,
    ) -> mmsdm_core::Result<Self::Row<'data>> {
        Ok(BillingAspayments7Row {
            regionid: row.get_opt_range("regionid", field_mapping.0[0])?,
            contractyear: row
                .get_custom_parsed_at_idx(
                    "contractyear",
                    field_mapping.0[1],
                    mmsdm_core::mms_decimal::parse,
                )?,
            weekno: row
                .get_custom_parsed_at_idx(
                    "weekno",
                    field_mapping.0[2],
                    mmsdm_core::mms_decimal::parse,
                )?,
            billrunno: row
                .get_custom_parsed_at_idx(
                    "billrunno",
                    field_mapping.0[3],
                    mmsdm_core::mms_decimal::parse,
                )?,
            participantid: row.get_range("participantid", field_mapping.0[4])?,
            connectionpointid: row.get_range("connectionpointid", field_mapping.0[5])?,
            raise6sec: row
                .get_opt_custom_parsed_at_idx(
                    "raise6sec",
                    field_mapping.0[6],
                    mmsdm_core::mms_decimal::parse,
                )?,
            lower6sec: row
                .get_opt_custom_parsed_at_idx(
                    "lower6sec",
                    field_mapping.0[7],
                    mmsdm_core::mms_decimal::parse,
                )?,
            raise60sec: row
                .get_opt_custom_parsed_at_idx(
                    "raise60sec",
                    field_mapping.0[8],
                    mmsdm_core::mms_decimal::parse,
                )?,
            lower60sec: row
                .get_opt_custom_parsed_at_idx(
                    "lower60sec",
                    field_mapping.0[9],
                    mmsdm_core::mms_decimal::parse,
                )?,
            agc: row
                .get_opt_custom_parsed_at_idx(
                    "agc",
                    field_mapping.0[10],
                    mmsdm_core::mms_decimal::parse,
                )?,
            fcascomp: row
                .get_opt_custom_parsed_at_idx(
                    "fcascomp",
                    field_mapping.0[11],
                    mmsdm_core::mms_decimal::parse,
                )?,
            loadshed: row
                .get_opt_custom_parsed_at_idx(
                    "loadshed",
                    field_mapping.0[12],
                    mmsdm_core::mms_decimal::parse,
                )?,
            rgul: row
                .get_opt_custom_parsed_at_idx(
                    "rgul",
                    field_mapping.0[13],
                    mmsdm_core::mms_decimal::parse,
                )?,
            rguu: row
                .get_opt_custom_parsed_at_idx(
                    "rguu",
                    field_mapping.0[14],
                    mmsdm_core::mms_decimal::parse,
                )?,
            reactivepower: row
                .get_opt_custom_parsed_at_idx(
                    "reactivepower",
                    field_mapping.0[15],
                    mmsdm_core::mms_decimal::parse,
                )?,
            systemrestart: row
                .get_opt_custom_parsed_at_idx(
                    "systemrestart",
                    field_mapping.0[16],
                    mmsdm_core::mms_decimal::parse,
                )?,
            lastchanged: row
                .get_opt_custom_parsed_at_idx(
                    "lastchanged",
                    field_mapping.0[17],
                    mmsdm_core::mms_datetime::parse,
                )?,
            lower5min: row
                .get_opt_custom_parsed_at_idx(
                    "lower5min",
                    field_mapping.0[18],
                    mmsdm_core::mms_decimal::parse,
                )?,
            raise5min: row
                .get_opt_custom_parsed_at_idx(
                    "raise5min",
                    field_mapping.0[19],
                    mmsdm_core::mms_decimal::parse,
                )?,
            lowerreg: row
                .get_opt_custom_parsed_at_idx(
                    "lowerreg",
                    field_mapping.0[20],
                    mmsdm_core::mms_decimal::parse,
                )?,
            raisereg: row
                .get_opt_custom_parsed_at_idx(
                    "raisereg",
                    field_mapping.0[21],
                    mmsdm_core::mms_decimal::parse,
                )?,
            availability_reactive: row
                .get_opt_custom_parsed_at_idx(
                    "availability_reactive",
                    field_mapping.0[22],
                    mmsdm_core::mms_decimal::parse,
                )?,
            availability_reactive_rbt: row
                .get_opt_custom_parsed_at_idx(
                    "availability_reactive_rbt",
                    field_mapping.0[23],
                    mmsdm_core::mms_decimal::parse,
                )?,
            raise1sec: row
                .get_opt_custom_parsed_at_idx(
                    "raise1sec",
                    field_mapping.0[24],
                    mmsdm_core::mms_decimal::parse,
                )?,
            lower1sec: row
                .get_opt_custom_parsed_at_idx(
                    "lower1sec",
                    field_mapping.0[25],
                    mmsdm_core::mms_decimal::parse,
                )?,
            backing_data: row,
        })
    }
    fn field_mapping_from_row<'a>(
        mut row: mmsdm_core::CsvRow<'a>,
    ) -> mmsdm_core::Result<Self::FieldMapping> {
        if !row.is_heading() {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!("Expected an I row but got {row:?}"),
                ),
            );
        }
        let row_key = mmsdm_core::FileKey::from_row(row.borrow())?;
        if !Self::matches_file_key(&row_key, row_key.version) {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!(
                        "Expected a row matching {}.{}.v{} but got {row_key}",
                        Self::DATA_SET_NAME, Self::TABLE_NAME, Self::VERSION
                    ),
                ),
            );
        }
        let mut base_mapping = Self::DEFAULT_FIELD_MAPPING.0;
        for (field_index, field) in Self::COLUMNS.iter().enumerate() {
            base_mapping[field_index] = row
                .iter_fields()
                .position(|f| f == *field)
                .unwrap_or(usize::MAX);
        }
        Ok(BillingAspayments7Mapping(base_mapping))
    }
    fn matches_file_key(key: &mmsdm_core::FileKey<'_>, version: i32) -> bool {
        version == key.version && Self::DATA_SET_NAME == key.data_set_name()
            && Self::TABLE_NAME == key.table_name()
    }
    fn primary_key(row: &Self::Row<'_>) -> BillingAspayments7PrimaryKey {
        BillingAspayments7PrimaryKey {
            billrunno: row.billrunno,
            connectionpointid: row.connectionpointid().to_string(),
            contractyear: row.contractyear,
            participantid: row.participantid().to_string(),
            weekno: row.weekno,
        }
    }
    fn partition_value(&self, row: &Self::Row<'_>) -> mmsdm_core::PartitionValue {
        (self.extract_row_partition)(row)
    }
    fn partition_name(&self, row: &Self::Row<'_>) -> alloc::string::String {
        alloc::format!("billing_aspayments_v7_{}", self.partition_value(row))
    }
    fn partition_key(&self) -> mmsdm_core::PartitionKey {
        self.row_partition_key
    }
    fn to_static<'a>(row: &Self::Row<'a>) -> Self::Row<'static> {
        BillingAspayments7Row {
            regionid: row.regionid.clone(),
            contractyear: row.contractyear.clone(),
            weekno: row.weekno.clone(),
            billrunno: row.billrunno.clone(),
            participantid: row.participantid.clone(),
            connectionpointid: row.connectionpointid.clone(),
            raise6sec: row.raise6sec.clone(),
            lower6sec: row.lower6sec.clone(),
            raise60sec: row.raise60sec.clone(),
            lower60sec: row.lower60sec.clone(),
            agc: row.agc.clone(),
            fcascomp: row.fcascomp.clone(),
            loadshed: row.loadshed.clone(),
            rgul: row.rgul.clone(),
            rguu: row.rguu.clone(),
            reactivepower: row.reactivepower.clone(),
            systemrestart: row.systemrestart.clone(),
            lastchanged: row.lastchanged.clone(),
            lower5min: row.lower5min.clone(),
            raise5min: row.raise5min.clone(),
            lowerreg: row.lowerreg.clone(),
            raisereg: row.raisereg.clone(),
            availability_reactive: row.availability_reactive.clone(),
            availability_reactive_rbt: row.availability_reactive_rbt.clone(),
            raise1sec: row.raise1sec.clone(),
            lower1sec: row.lower1sec.clone(),
            backing_data: row.backing_data.to_owned(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct BillingAspayments7PrimaryKey {
    pub billrunno: rust_decimal::Decimal,
    pub connectionpointid: alloc::string::String,
    pub contractyear: rust_decimal::Decimal,
    pub participantid: alloc::string::String,
    pub weekno: rust_decimal::Decimal,
}
impl mmsdm_core::PrimaryKey for BillingAspayments7PrimaryKey {}
impl<'data> mmsdm_core::CompareWithRow for BillingAspayments7Row<'data> {
    type Row<'other> = BillingAspayments7Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno
            && self.connectionpointid() == row.connectionpointid()
            && self.contractyear == row.contractyear
            && self.participantid() == row.participantid() && self.weekno == row.weekno
    }
}
impl<'data> mmsdm_core::CompareWithPrimaryKey for BillingAspayments7Row<'data> {
    type PrimaryKey = BillingAspayments7PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno
            && self.connectionpointid() == key.connectionpointid
            && self.contractyear == key.contractyear
            && self.participantid() == key.participantid && self.weekno == key.weekno
    }
}
impl<'data> mmsdm_core::CompareWithRow for BillingAspayments7PrimaryKey {
    type Row<'other> = BillingAspayments7Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno
            && self.connectionpointid == row.connectionpointid()
            && self.contractyear == row.contractyear
            && self.participantid == row.participantid() && self.weekno == row.weekno
    }
}
impl mmsdm_core::CompareWithPrimaryKey for BillingAspayments7PrimaryKey {
    type PrimaryKey = BillingAspayments7PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno
            && self.connectionpointid == key.connectionpointid
            && self.contractyear == key.contractyear
            && self.participantid == key.participantid && self.weekno == key.weekno
    }
}
#[cfg(feature = "arrow")]
impl mmsdm_core::ArrowSchema for BillingAspayments7 {
    type Builder = BillingAspayments7Builder;
    fn schema() -> arrow::datatypes::Schema {
        arrow::datatypes::Schema::new(
            alloc::vec::Vec::from([
                arrow::datatypes::Field::new(
                    "regionid",
                    arrow::datatypes::DataType::Utf8,
                    true,
                ),
                arrow::datatypes::Field::new(
                    "contractyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "weekno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "billrunno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "participantid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "connectionpointid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "raise6sec",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lower6sec",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "raise60sec",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lower60sec",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "agc",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "fcascomp",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "loadshed",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "rgul",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "rguu",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "reactivepower",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "systemrestart",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lastchanged",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lower5min",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "raise5min",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lowerreg",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "raisereg",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "availability_reactive",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "availability_reactive_rbt",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "raise1sec",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lower1sec",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
            ]),
        )
    }
    fn new_builder() -> Self::Builder {
        BillingAspayments7Builder {
            regionid_array: arrow::array::builder::StringBuilder::new(),
            contractyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            weekno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            billrunno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            participantid_array: arrow::array::builder::StringBuilder::new(),
            connectionpointid_array: arrow::array::builder::StringBuilder::new(),
            raise6sec_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            lower6sec_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            raise60sec_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            lower60sec_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            agc_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            fcascomp_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            loadshed_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            rgul_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            rguu_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            reactivepower_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            systemrestart_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
            lower5min_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            raise5min_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            lowerreg_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            raisereg_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            availability_reactive_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            availability_reactive_rbt_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            raise1sec_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            lower1sec_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
        }
    }
    fn append_builder(builder: &mut Self::Builder, row: Self::Row<'_>) {
        builder.regionid_array.append_option(row.regionid());
        builder
            .contractyear_array
            .append_value({
                let mut val = row.contractyear;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .weekno_array
            .append_value({
                let mut val = row.weekno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .billrunno_array
            .append_value({
                let mut val = row.billrunno;
                val.rescale(0);
                val.mantissa()
            });
        builder.participantid_array.append_value(row.participantid());
        builder.connectionpointid_array.append_value(row.connectionpointid());
        builder
            .raise6sec_array
            .append_option({
                row.raise6sec
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .lower6sec_array
            .append_option({
                row.lower6sec
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .raise60sec_array
            .append_option({
                row.raise60sec
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .lower60sec_array
            .append_option({
                row.lower60sec
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .agc_array
            .append_option({
                row.agc
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .fcascomp_array
            .append_option({
                row.fcascomp
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .loadshed_array
            .append_option({
                row.loadshed
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .rgul_array
            .append_option({
                row.rgul
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .rguu_array
            .append_option({
                row.rguu
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .reactivepower_array
            .append_option({
                row.reactivepower
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .systemrestart_array
            .append_option({
                row.systemrestart
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .lastchanged_array
            .append_option(row.lastchanged.map(|val| val.and_utc().timestamp_millis()));
        builder
            .lower5min_array
            .append_option({
                row.lower5min
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .raise5min_array
            .append_option({
                row.raise5min
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .lowerreg_array
            .append_option({
                row.lowerreg
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .raisereg_array
            .append_option({
                row.raisereg
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .availability_reactive_array
            .append_option({
                row.availability_reactive
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .availability_reactive_rbt_array
            .append_option({
                row.availability_reactive_rbt
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .raise1sec_array
            .append_option({
                row.raise1sec
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .lower1sec_array
            .append_option({
                row.lower1sec
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
    }
    fn finalize_builder(
        builder: &mut Self::Builder,
    ) -> mmsdm_core::Result<arrow::array::RecordBatch> {
        arrow::array::RecordBatch::try_new(
                alloc::sync::Arc::new(<Self as mmsdm_core::ArrowSchema>::schema()),
                alloc::vec::Vec::from([
                    alloc::sync::Arc::new(builder.regionid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.participantid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.connectionpointid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.raise6sec_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lower6sec_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.raise60sec_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lower60sec_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.agc_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.fcascomp_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.loadshed_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.rgul_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.rguu_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.reactivepower_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.systemrestart_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lastchanged_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lower5min_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.raise5min_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lowerreg_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.raisereg_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.availability_reactive_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(
                        builder.availability_reactive_rbt_array.finish(),
                    ) as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.raise1sec_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lower1sec_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                ]),
            )
            .map_err(Into::into)
    }
}
#[cfg(feature = "arrow")]
pub struct BillingAspayments7Builder {
    regionid_array: arrow::array::builder::StringBuilder,
    contractyear_array: arrow::array::builder::Decimal128Builder,
    weekno_array: arrow::array::builder::Decimal128Builder,
    billrunno_array: arrow::array::builder::Decimal128Builder,
    participantid_array: arrow::array::builder::StringBuilder,
    connectionpointid_array: arrow::array::builder::StringBuilder,
    raise6sec_array: arrow::array::builder::Decimal128Builder,
    lower6sec_array: arrow::array::builder::Decimal128Builder,
    raise60sec_array: arrow::array::builder::Decimal128Builder,
    lower60sec_array: arrow::array::builder::Decimal128Builder,
    agc_array: arrow::array::builder::Decimal128Builder,
    fcascomp_array: arrow::array::builder::Decimal128Builder,
    loadshed_array: arrow::array::builder::Decimal128Builder,
    rgul_array: arrow::array::builder::Decimal128Builder,
    rguu_array: arrow::array::builder::Decimal128Builder,
    reactivepower_array: arrow::array::builder::Decimal128Builder,
    systemrestart_array: arrow::array::builder::Decimal128Builder,
    lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder,
    lower5min_array: arrow::array::builder::Decimal128Builder,
    raise5min_array: arrow::array::builder::Decimal128Builder,
    lowerreg_array: arrow::array::builder::Decimal128Builder,
    raisereg_array: arrow::array::builder::Decimal128Builder,
    availability_reactive_array: arrow::array::builder::Decimal128Builder,
    availability_reactive_rbt_array: arrow::array::builder::Decimal128Builder,
    raise1sec_array: arrow::array::builder::Decimal128Builder,
    lower1sec_array: arrow::array::builder::Decimal128Builder,
}
pub struct BillingAsrecovery9 {
    extract_row_partition: alloc::boxed::Box<
        dyn Fn(
            &BillingAsrecovery9Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    >,
    row_partition_key: mmsdm_core::PartitionKey,
}
impl BillingAsrecovery9 {
    pub fn new(
        row_partition_key: mmsdm_core::PartitionKey,
        func: impl Fn(
            &<Self as mmsdm_core::GetTable>::Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    ) -> Self {
        Self {
            extract_row_partition: alloc::boxed::Box::new(func),
            row_partition_key,
        }
    }
}
pub struct BillingAsrecovery9Mapping([usize; 50]);
/// # Summary
///
/// ## BILLINGASRECOVERY
///  _BILLINGASRECOVERY shows participant charges for Ancillary Services for the billing period. This view shows the billing amounts for Ancillary Service Recovery._
///
/// * Data Set Name: Billing
/// * File Name: Asrecovery
/// * Data Version: 9
///
/// # Description
///  BILLINGASRECOVERY data is confidential to relevant participant. Source Updated  with each billing run. Volume Approximately 5 records are inserted per billrunno, or about 55 records inserted per week.
///
///
///
/// # Primary Key Columns
///
/// * BILLRUNNO
/// * CONTRACTYEAR
/// * PARTICIPANTID
/// * REGIONID
/// * WEEKNO
#[derive(Debug, PartialEq, Eq)]
pub struct BillingAsrecovery9Row<'data> {
    /// Region Identifier
    pub regionid: core::ops::Range<usize>,
    /// Contract Year
    pub contractyear: rust_decimal::Decimal,
    /// Week No
    pub weekno: rust_decimal::Decimal,
    /// Billing Run No.
    pub billrunno: rust_decimal::Decimal,
    /// Participant Identifier
    pub participantid: core::ops::Range<usize>,
    /// Raise 6 Sec Recovery. NULL for Billing Week post the IESS rule effective date
    pub raise6sec: Option<rust_decimal::Decimal>,
    /// Lower 6 Sec Recovery. NULL for Billing Week post the IESS rule effective date
    pub lower6sec: Option<rust_decimal::Decimal>,
    /// Raise 60 Sec Recovery. NULL for Billing Week post the IESS rule effective date
    pub raise60sec: Option<rust_decimal::Decimal>,
    /// Lower 60 Sec Recovery. NULL for Billing Week post the IESS rule effective date
    pub lower60sec: Option<rust_decimal::Decimal>,
    /// AGC Recovery - Not used since circa 2000
    pub agc: Option<rust_decimal::Decimal>,
    /// Frequency Control Compensation Recovery - Not used since circa 2000
    pub fcascomp: Option<rust_decimal::Decimal>,
    /// Load Shed Recovery. Post-IESS the value in this column only represent the Testing Payment Recovery from Customers. 0 if no testing payment exists.
    pub loadshed: Option<rust_decimal::Decimal>,
    /// Rapid Generator Unit Loading Recovery - Not used since December 2001
    pub rgul: Option<rust_decimal::Decimal>,
    /// Rapid Generator Unit Unloading Recovery - Not used since December 2001
    pub rguu: Option<rust_decimal::Decimal>,
    /// Reactive Power Recovery. Post-IESS the value in this column only represent the Testing Payment Recovery from Customers. 0 if no testing payment exists.
    pub reactivepower: Option<rust_decimal::Decimal>,
    /// System Restart Recovery. Post-IESS the value in this column only represent the Testing Payment Recovery from Customers. 0 if no testing payment exists
    pub systemrestart: Option<rust_decimal::Decimal>,
    /// The latest date and time a file was updated/inserted
    pub lastchanged: Option<chrono::NaiveDateTime>,
    /// Raise 6 Sec Recovery for Generator. NULL for Billing Week post the IESS rule effective date
    pub raise6sec_gen: Option<rust_decimal::Decimal>,
    /// Lower 6 Sec Recovery for Generator. NULL for Billing Week post the IESS rule effective date
    pub lower6sec_gen: Option<rust_decimal::Decimal>,
    /// Raise 60 Sec Recovery for Generator. NULL for Billing Week post the IESS rule effective date
    pub raise60sec_gen: Option<rust_decimal::Decimal>,
    /// Lower 60 Sec Recovery for Generator. NULL for Billing Week post the IESS rule effective date
    pub lower60sec_gen: Option<rust_decimal::Decimal>,
    /// AGC Recovery for Generator
    pub agc_gen: Option<rust_decimal::Decimal>,
    /// Frequency Control Compensation Recovery for Generator
    pub fcascomp_gen: Option<rust_decimal::Decimal>,
    /// Load Shed Recovery for Generator. Post-IESS the value in this column only represent the Testing Payment Recovery from Generators. 0 if no testing payment exists.
    pub loadshed_gen: Option<rust_decimal::Decimal>,
    /// Rapid Generator unit Loading Recovery for. Generator - Not used since December 2001
    pub rgul_gen: Option<rust_decimal::Decimal>,
    /// Rapid Generator Unit Unloading Recovery for Generator - Not used since December 2001
    pub rguu_gen: Option<rust_decimal::Decimal>,
    /// Reactive Power Recovery for Generator. Post-IESS the value in this column only represent the Testing Payment Recovery from Generators. 0 if no testing payment exists.
    pub reactivepower_gen: Option<rust_decimal::Decimal>,
    /// System Restart Recovery for Generator. Post-IESS the value in this column only represent the Testing Payment Recovery from Generators. 0 if no testing payment exists.
    pub systemrestart_gen: Option<rust_decimal::Decimal>,
    /// Recovery amount for the Lower 5 Minute service attributable to customer connection points. NULL for Billing Week post the IESS rule effective date
    pub lower5min: Option<rust_decimal::Decimal>,
    /// Recovery amount for the Raise 5 Minute service attributable to customer connection points. NULL for Billing Week post the IESS rule effective date
    pub raise5min: Option<rust_decimal::Decimal>,
    /// Pre-IESS - Recovery amount for the Lower Regulation service attributable to customer connection points(MPF + Residue). Post-IESS the amount in this column represent only the Lower Regulation FCAS MPF Recovery Amount from Customer and Generator Connection Point MPFs, no Residue Amounts are added to this column value.
    pub lowerreg: Option<rust_decimal::Decimal>,
    /// Pre-IESS - Recovery amount for the Raise Regulation service attributable to customer connection points(MPF + Residue). Post-IESS the amount in this column represent only the Raise Regulation FCAS MPF Recovery Amount from Customer and Generator Connection Point MPFs, no Residue Amounts are added to this column value.
    pub raisereg: Option<rust_decimal::Decimal>,
    /// Recovery amount for the Lower 5 Minute service attributable to generator connection points. NULL for Billing Week post the IESS rule effective date
    pub lower5min_gen: Option<rust_decimal::Decimal>,
    /// Recovery amount for the Raise 5 Minute service attributable to generator connection points. NULL for Billing Week post the IESS rule effective date
    pub raise5min_gen: Option<rust_decimal::Decimal>,
    /// Recovery amount for the Lower Regulation service attributable to generator connection points. NULL for Billing Week post the IESS rule effective date
    pub lowerreg_gen: Option<rust_decimal::Decimal>,
    /// Recovery amount for the Raise Regulation service attributable to generator connection points. NULL for Billing Week post the IESS rule effective date. NULL for Billing Week post the IESS rule effective date.
    pub raisereg_gen: Option<rust_decimal::Decimal>,
    /// The total availability payment recovery amount (customer).. NULL for Billing Week post the IESS rule effective date
    pub availability_reactive: Option<rust_decimal::Decimal>,
    /// The total availability payment rebate recovery amount (customer).. NULL for Billing Week post the IESS rule effective date
    pub availability_reactive_rbt: Option<rust_decimal::Decimal>,
    /// The total availability payment recovery amount (Generator).. NULL for Billing Week post the IESS rule effective date
    pub availability_reactive_gen: Option<rust_decimal::Decimal>,
    /// The total availability payment rebate recovery amount (Generator).. NULL for Billing Week post the IESS rule effective date
    pub availability_reactive_rbt_gen: Option<rust_decimal::Decimal>,
    /// Customer recovery amount for the very fast raise service. NULL for Billing Week post the IESS rule effective date
    pub raise1sec: Option<rust_decimal::Decimal>,
    /// Customer recovery amount for the very fast lower service. NULL for Billing Week post the IESS rule effective date
    pub lower1sec: Option<rust_decimal::Decimal>,
    /// Generator recovery amount for the very fast raise service. NULL for Billing Week post the IESS rule effective date
    pub raise1sec_gen: Option<rust_decimal::Decimal>,
    /// Generator recovery amount for the very fast lower service. NULL for Billing Week post the IESS rule effective date
    pub lower1sec_gen: Option<rust_decimal::Decimal>,
    /// The Lower Regulation FCAS Residue Recovery Amount using ACE MWh values. NULL for Billing Week prior to the IESS rule effective date
    pub lowerreg_ace: Option<rust_decimal::Decimal>,
    /// The Raise Regulation FCAS Residue Recovery Amount using ACE MWh values. NULL for Billing Week prior to the IESS rule effective date
    pub raisereg_ace: Option<rust_decimal::Decimal>,
    /// The Raise1Sec FCAS Recovery Amount for the Participant and Region from ACE MWh Portion. NULL for Billing Week prior to the IESS rule effective date
    pub raise1sec_ace: Option<rust_decimal::Decimal>,
    /// The Raise1Sec FCAS Recovery Amount for the Participant and Region from ASOE MWh Portion. NULL for Billing Week prior to the IESS rule effective date
    pub raise1sec_asoe: Option<rust_decimal::Decimal>,
    /// The Lower1Sec FCAS Recovery Amount for the Participant and Region from ACE MWh Portion. NULL for Billing Week prior to the IESS rule effective date
    pub lower1sec_ace: Option<rust_decimal::Decimal>,
    /// The Lower1Sec FCAS Recovery Amount for the Participant and Region from ASOE MWh Portion. NULL for Billing Week prior to the IESS rule effective date
    pub lower1sec_asoe: Option<rust_decimal::Decimal>,
    backing_data: mmsdm_core::CsvRow<'data>,
}
impl<'data> BillingAsrecovery9Row<'data> {
    pub fn regionid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.regionid.clone())
    }
    pub fn participantid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.participantid.clone())
    }
}
impl mmsdm_core::GetTable for BillingAsrecovery9 {
    const VERSION: i32 = 9;
    const DATA_SET_NAME: &'static str = "BILLING";
    const TABLE_NAME: &'static str = "ASRECOVERY";
    const DEFAULT_FIELD_MAPPING: Self::FieldMapping = BillingAsrecovery9Mapping([
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        27,
        28,
        29,
        30,
        31,
        32,
        33,
        34,
        35,
        36,
        37,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        46,
        47,
        48,
        49,
        50,
        51,
        52,
        53,
    ]);
    const COLUMNS: &'static [&'static str] = &[
        "REGIONID",
        "CONTRACTYEAR",
        "WEEKNO",
        "BILLRUNNO",
        "PARTICIPANTID",
        "RAISE6SEC",
        "LOWER6SEC",
        "RAISE60SEC",
        "LOWER60SEC",
        "AGC",
        "FCASCOMP",
        "LOADSHED",
        "RGUL",
        "RGUU",
        "REACTIVEPOWER",
        "SYSTEMRESTART",
        "LASTCHANGED",
        "RAISE6SEC_GEN",
        "LOWER6SEC_GEN",
        "RAISE60SEC_GEN",
        "LOWER60SEC_GEN",
        "AGC_GEN",
        "FCASCOMP_GEN",
        "LOADSHED_GEN",
        "RGUL_GEN",
        "RGUU_GEN",
        "REACTIVEPOWER_GEN",
        "SYSTEMRESTART_GEN",
        "LOWER5MIN",
        "RAISE5MIN",
        "LOWERREG",
        "RAISEREG",
        "LOWER5MIN_GEN",
        "RAISE5MIN_GEN",
        "LOWERREG_GEN",
        "RAISEREG_GEN",
        "AVAILABILITY_REACTIVE",
        "AVAILABILITY_REACTIVE_RBT",
        "AVAILABILITY_REACTIVE_GEN",
        "AVAILABILITY_REACTIVE_RBT_GEN",
        "RAISE1SEC",
        "LOWER1SEC",
        "RAISE1SEC_GEN",
        "LOWER1SEC_GEN",
        "LOWERREG_ACE",
        "RAISEREG_ACE",
        "RAISE1SEC_ACE",
        "RAISE1SEC_ASOE",
        "LOWER1SEC_ACE",
        "LOWER1SEC_ASOE",
    ];
    type Row<'row> = BillingAsrecovery9Row<'row>;
    type FieldMapping = BillingAsrecovery9Mapping;
    type PrimaryKey = BillingAsrecovery9PrimaryKey;
    fn from_row<'data>(
        row: mmsdm_core::CsvRow<'data>,
        field_mapping: &Self::FieldMapping,
    ) -> mmsdm_core::Result<Self::Row<'data>> {
        Ok(BillingAsrecovery9Row {
            regionid: row.get_range("regionid", field_mapping.0[0])?,
            contractyear: row
                .get_custom_parsed_at_idx(
                    "contractyear",
                    field_mapping.0[1],
                    mmsdm_core::mms_decimal::parse,
                )?,
            weekno: row
                .get_custom_parsed_at_idx(
                    "weekno",
                    field_mapping.0[2],
                    mmsdm_core::mms_decimal::parse,
                )?,
            billrunno: row
                .get_custom_parsed_at_idx(
                    "billrunno",
                    field_mapping.0[3],
                    mmsdm_core::mms_decimal::parse,
                )?,
            participantid: row.get_range("participantid", field_mapping.0[4])?,
            raise6sec: row
                .get_opt_custom_parsed_at_idx(
                    "raise6sec",
                    field_mapping.0[5],
                    mmsdm_core::mms_decimal::parse,
                )?,
            lower6sec: row
                .get_opt_custom_parsed_at_idx(
                    "lower6sec",
                    field_mapping.0[6],
                    mmsdm_core::mms_decimal::parse,
                )?,
            raise60sec: row
                .get_opt_custom_parsed_at_idx(
                    "raise60sec",
                    field_mapping.0[7],
                    mmsdm_core::mms_decimal::parse,
                )?,
            lower60sec: row
                .get_opt_custom_parsed_at_idx(
                    "lower60sec",
                    field_mapping.0[8],
                    mmsdm_core::mms_decimal::parse,
                )?,
            agc: row
                .get_opt_custom_parsed_at_idx(
                    "agc",
                    field_mapping.0[9],
                    mmsdm_core::mms_decimal::parse,
                )?,
            fcascomp: row
                .get_opt_custom_parsed_at_idx(
                    "fcascomp",
                    field_mapping.0[10],
                    mmsdm_core::mms_decimal::parse,
                )?,
            loadshed: row
                .get_opt_custom_parsed_at_idx(
                    "loadshed",
                    field_mapping.0[11],
                    mmsdm_core::mms_decimal::parse,
                )?,
            rgul: row
                .get_opt_custom_parsed_at_idx(
                    "rgul",
                    field_mapping.0[12],
                    mmsdm_core::mms_decimal::parse,
                )?,
            rguu: row
                .get_opt_custom_parsed_at_idx(
                    "rguu",
                    field_mapping.0[13],
                    mmsdm_core::mms_decimal::parse,
                )?,
            reactivepower: row
                .get_opt_custom_parsed_at_idx(
                    "reactivepower",
                    field_mapping.0[14],
                    mmsdm_core::mms_decimal::parse,
                )?,
            systemrestart: row
                .get_opt_custom_parsed_at_idx(
                    "systemrestart",
                    field_mapping.0[15],
                    mmsdm_core::mms_decimal::parse,
                )?,
            lastchanged: row
                .get_opt_custom_parsed_at_idx(
                    "lastchanged",
                    field_mapping.0[16],
                    mmsdm_core::mms_datetime::parse,
                )?,
            raise6sec_gen: row
                .get_opt_custom_parsed_at_idx(
                    "raise6sec_gen",
                    field_mapping.0[17],
                    mmsdm_core::mms_decimal::parse,
                )?,
            lower6sec_gen: row
                .get_opt_custom_parsed_at_idx(
                    "lower6sec_gen",
                    field_mapping.0[18],
                    mmsdm_core::mms_decimal::parse,
                )?,
            raise60sec_gen: row
                .get_opt_custom_parsed_at_idx(
                    "raise60sec_gen",
                    field_mapping.0[19],
                    mmsdm_core::mms_decimal::parse,
                )?,
            lower60sec_gen: row
                .get_opt_custom_parsed_at_idx(
                    "lower60sec_gen",
                    field_mapping.0[20],
                    mmsdm_core::mms_decimal::parse,
                )?,
            agc_gen: row
                .get_opt_custom_parsed_at_idx(
                    "agc_gen",
                    field_mapping.0[21],
                    mmsdm_core::mms_decimal::parse,
                )?,
            fcascomp_gen: row
                .get_opt_custom_parsed_at_idx(
                    "fcascomp_gen",
                    field_mapping.0[22],
                    mmsdm_core::mms_decimal::parse,
                )?,
            loadshed_gen: row
                .get_opt_custom_parsed_at_idx(
                    "loadshed_gen",
                    field_mapping.0[23],
                    mmsdm_core::mms_decimal::parse,
                )?,
            rgul_gen: row
                .get_opt_custom_parsed_at_idx(
                    "rgul_gen",
                    field_mapping.0[24],
                    mmsdm_core::mms_decimal::parse,
                )?,
            rguu_gen: row
                .get_opt_custom_parsed_at_idx(
                    "rguu_gen",
                    field_mapping.0[25],
                    mmsdm_core::mms_decimal::parse,
                )?,
            reactivepower_gen: row
                .get_opt_custom_parsed_at_idx(
                    "reactivepower_gen",
                    field_mapping.0[26],
                    mmsdm_core::mms_decimal::parse,
                )?,
            systemrestart_gen: row
                .get_opt_custom_parsed_at_idx(
                    "systemrestart_gen",
                    field_mapping.0[27],
                    mmsdm_core::mms_decimal::parse,
                )?,
            lower5min: row
                .get_opt_custom_parsed_at_idx(
                    "lower5min",
                    field_mapping.0[28],
                    mmsdm_core::mms_decimal::parse,
                )?,
            raise5min: row
                .get_opt_custom_parsed_at_idx(
                    "raise5min",
                    field_mapping.0[29],
                    mmsdm_core::mms_decimal::parse,
                )?,
            lowerreg: row
                .get_opt_custom_parsed_at_idx(
                    "lowerreg",
                    field_mapping.0[30],
                    mmsdm_core::mms_decimal::parse,
                )?,
            raisereg: row
                .get_opt_custom_parsed_at_idx(
                    "raisereg",
                    field_mapping.0[31],
                    mmsdm_core::mms_decimal::parse,
                )?,
            lower5min_gen: row
                .get_opt_custom_parsed_at_idx(
                    "lower5min_gen",
                    field_mapping.0[32],
                    mmsdm_core::mms_decimal::parse,
                )?,
            raise5min_gen: row
                .get_opt_custom_parsed_at_idx(
                    "raise5min_gen",
                    field_mapping.0[33],
                    mmsdm_core::mms_decimal::parse,
                )?,
            lowerreg_gen: row
                .get_opt_custom_parsed_at_idx(
                    "lowerreg_gen",
                    field_mapping.0[34],
                    mmsdm_core::mms_decimal::parse,
                )?,
            raisereg_gen: row
                .get_opt_custom_parsed_at_idx(
                    "raisereg_gen",
                    field_mapping.0[35],
                    mmsdm_core::mms_decimal::parse,
                )?,
            availability_reactive: row
                .get_opt_custom_parsed_at_idx(
                    "availability_reactive",
                    field_mapping.0[36],
                    mmsdm_core::mms_decimal::parse,
                )?,
            availability_reactive_rbt: row
                .get_opt_custom_parsed_at_idx(
                    "availability_reactive_rbt",
                    field_mapping.0[37],
                    mmsdm_core::mms_decimal::parse,
                )?,
            availability_reactive_gen: row
                .get_opt_custom_parsed_at_idx(
                    "availability_reactive_gen",
                    field_mapping.0[38],
                    mmsdm_core::mms_decimal::parse,
                )?,
            availability_reactive_rbt_gen: row
                .get_opt_custom_parsed_at_idx(
                    "availability_reactive_rbt_gen",
                    field_mapping.0[39],
                    mmsdm_core::mms_decimal::parse,
                )?,
            raise1sec: row
                .get_opt_custom_parsed_at_idx(
                    "raise1sec",
                    field_mapping.0[40],
                    mmsdm_core::mms_decimal::parse,
                )?,
            lower1sec: row
                .get_opt_custom_parsed_at_idx(
                    "lower1sec",
                    field_mapping.0[41],
                    mmsdm_core::mms_decimal::parse,
                )?,
            raise1sec_gen: row
                .get_opt_custom_parsed_at_idx(
                    "raise1sec_gen",
                    field_mapping.0[42],
                    mmsdm_core::mms_decimal::parse,
                )?,
            lower1sec_gen: row
                .get_opt_custom_parsed_at_idx(
                    "lower1sec_gen",
                    field_mapping.0[43],
                    mmsdm_core::mms_decimal::parse,
                )?,
            lowerreg_ace: row
                .get_opt_custom_parsed_at_idx(
                    "lowerreg_ace",
                    field_mapping.0[44],
                    mmsdm_core::mms_decimal::parse,
                )?,
            raisereg_ace: row
                .get_opt_custom_parsed_at_idx(
                    "raisereg_ace",
                    field_mapping.0[45],
                    mmsdm_core::mms_decimal::parse,
                )?,
            raise1sec_ace: row
                .get_opt_custom_parsed_at_idx(
                    "raise1sec_ace",
                    field_mapping.0[46],
                    mmsdm_core::mms_decimal::parse,
                )?,
            raise1sec_asoe: row
                .get_opt_custom_parsed_at_idx(
                    "raise1sec_asoe",
                    field_mapping.0[47],
                    mmsdm_core::mms_decimal::parse,
                )?,
            lower1sec_ace: row
                .get_opt_custom_parsed_at_idx(
                    "lower1sec_ace",
                    field_mapping.0[48],
                    mmsdm_core::mms_decimal::parse,
                )?,
            lower1sec_asoe: row
                .get_opt_custom_parsed_at_idx(
                    "lower1sec_asoe",
                    field_mapping.0[49],
                    mmsdm_core::mms_decimal::parse,
                )?,
            backing_data: row,
        })
    }
    fn field_mapping_from_row<'a>(
        mut row: mmsdm_core::CsvRow<'a>,
    ) -> mmsdm_core::Result<Self::FieldMapping> {
        if !row.is_heading() {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!("Expected an I row but got {row:?}"),
                ),
            );
        }
        let row_key = mmsdm_core::FileKey::from_row(row.borrow())?;
        if !Self::matches_file_key(&row_key, row_key.version) {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!(
                        "Expected a row matching {}.{}.v{} but got {row_key}",
                        Self::DATA_SET_NAME, Self::TABLE_NAME, Self::VERSION
                    ),
                ),
            );
        }
        let mut base_mapping = Self::DEFAULT_FIELD_MAPPING.0;
        for (field_index, field) in Self::COLUMNS.iter().enumerate() {
            base_mapping[field_index] = row
                .iter_fields()
                .position(|f| f == *field)
                .unwrap_or(usize::MAX);
        }
        Ok(BillingAsrecovery9Mapping(base_mapping))
    }
    fn matches_file_key(key: &mmsdm_core::FileKey<'_>, version: i32) -> bool {
        version == key.version && Self::DATA_SET_NAME == key.data_set_name()
            && Self::TABLE_NAME == key.table_name()
    }
    fn primary_key(row: &Self::Row<'_>) -> BillingAsrecovery9PrimaryKey {
        BillingAsrecovery9PrimaryKey {
            billrunno: row.billrunno,
            contractyear: row.contractyear,
            participantid: row.participantid().to_string(),
            regionid: row.regionid().to_string(),
            weekno: row.weekno,
        }
    }
    fn partition_value(&self, row: &Self::Row<'_>) -> mmsdm_core::PartitionValue {
        (self.extract_row_partition)(row)
    }
    fn partition_name(&self, row: &Self::Row<'_>) -> alloc::string::String {
        alloc::format!("billing_asrecovery_v9_{}", self.partition_value(row))
    }
    fn partition_key(&self) -> mmsdm_core::PartitionKey {
        self.row_partition_key
    }
    fn to_static<'a>(row: &Self::Row<'a>) -> Self::Row<'static> {
        BillingAsrecovery9Row {
            regionid: row.regionid.clone(),
            contractyear: row.contractyear.clone(),
            weekno: row.weekno.clone(),
            billrunno: row.billrunno.clone(),
            participantid: row.participantid.clone(),
            raise6sec: row.raise6sec.clone(),
            lower6sec: row.lower6sec.clone(),
            raise60sec: row.raise60sec.clone(),
            lower60sec: row.lower60sec.clone(),
            agc: row.agc.clone(),
            fcascomp: row.fcascomp.clone(),
            loadshed: row.loadshed.clone(),
            rgul: row.rgul.clone(),
            rguu: row.rguu.clone(),
            reactivepower: row.reactivepower.clone(),
            systemrestart: row.systemrestart.clone(),
            lastchanged: row.lastchanged.clone(),
            raise6sec_gen: row.raise6sec_gen.clone(),
            lower6sec_gen: row.lower6sec_gen.clone(),
            raise60sec_gen: row.raise60sec_gen.clone(),
            lower60sec_gen: row.lower60sec_gen.clone(),
            agc_gen: row.agc_gen.clone(),
            fcascomp_gen: row.fcascomp_gen.clone(),
            loadshed_gen: row.loadshed_gen.clone(),
            rgul_gen: row.rgul_gen.clone(),
            rguu_gen: row.rguu_gen.clone(),
            reactivepower_gen: row.reactivepower_gen.clone(),
            systemrestart_gen: row.systemrestart_gen.clone(),
            lower5min: row.lower5min.clone(),
            raise5min: row.raise5min.clone(),
            lowerreg: row.lowerreg.clone(),
            raisereg: row.raisereg.clone(),
            lower5min_gen: row.lower5min_gen.clone(),
            raise5min_gen: row.raise5min_gen.clone(),
            lowerreg_gen: row.lowerreg_gen.clone(),
            raisereg_gen: row.raisereg_gen.clone(),
            availability_reactive: row.availability_reactive.clone(),
            availability_reactive_rbt: row.availability_reactive_rbt.clone(),
            availability_reactive_gen: row.availability_reactive_gen.clone(),
            availability_reactive_rbt_gen: row.availability_reactive_rbt_gen.clone(),
            raise1sec: row.raise1sec.clone(),
            lower1sec: row.lower1sec.clone(),
            raise1sec_gen: row.raise1sec_gen.clone(),
            lower1sec_gen: row.lower1sec_gen.clone(),
            lowerreg_ace: row.lowerreg_ace.clone(),
            raisereg_ace: row.raisereg_ace.clone(),
            raise1sec_ace: row.raise1sec_ace.clone(),
            raise1sec_asoe: row.raise1sec_asoe.clone(),
            lower1sec_ace: row.lower1sec_ace.clone(),
            lower1sec_asoe: row.lower1sec_asoe.clone(),
            backing_data: row.backing_data.to_owned(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct BillingAsrecovery9PrimaryKey {
    pub billrunno: rust_decimal::Decimal,
    pub contractyear: rust_decimal::Decimal,
    pub participantid: alloc::string::String,
    pub regionid: alloc::string::String,
    pub weekno: rust_decimal::Decimal,
}
impl mmsdm_core::PrimaryKey for BillingAsrecovery9PrimaryKey {}
impl<'data> mmsdm_core::CompareWithRow for BillingAsrecovery9Row<'data> {
    type Row<'other> = BillingAsrecovery9Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.participantid() == row.participantid()
            && self.regionid() == row.regionid() && self.weekno == row.weekno
    }
}
impl<'data> mmsdm_core::CompareWithPrimaryKey for BillingAsrecovery9Row<'data> {
    type PrimaryKey = BillingAsrecovery9PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.participantid() == key.participantid
            && self.regionid() == key.regionid && self.weekno == key.weekno
    }
}
impl<'data> mmsdm_core::CompareWithRow for BillingAsrecovery9PrimaryKey {
    type Row<'other> = BillingAsrecovery9Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.participantid == row.participantid()
            && self.regionid == row.regionid() && self.weekno == row.weekno
    }
}
impl mmsdm_core::CompareWithPrimaryKey for BillingAsrecovery9PrimaryKey {
    type PrimaryKey = BillingAsrecovery9PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.participantid == key.participantid && self.regionid == key.regionid
            && self.weekno == key.weekno
    }
}
#[cfg(feature = "arrow")]
impl mmsdm_core::ArrowSchema for BillingAsrecovery9 {
    type Builder = BillingAsrecovery9Builder;
    fn schema() -> arrow::datatypes::Schema {
        arrow::datatypes::Schema::new(
            alloc::vec::Vec::from([
                arrow::datatypes::Field::new(
                    "regionid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "contractyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "weekno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "billrunno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "participantid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "raise6sec",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lower6sec",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "raise60sec",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lower60sec",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "agc",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "fcascomp",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "loadshed",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "rgul",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "rguu",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "reactivepower",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "systemrestart",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lastchanged",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "raise6sec_gen",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lower6sec_gen",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "raise60sec_gen",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lower60sec_gen",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "agc_gen",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "fcascomp_gen",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "loadshed_gen",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "rgul_gen",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "rguu_gen",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "reactivepower_gen",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "systemrestart_gen",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lower5min",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "raise5min",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lowerreg",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "raisereg",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lower5min_gen",
                    arrow::datatypes::DataType::Decimal128(16, 6),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "raise5min_gen",
                    arrow::datatypes::DataType::Decimal128(16, 6),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lowerreg_gen",
                    arrow::datatypes::DataType::Decimal128(16, 6),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "raisereg_gen",
                    arrow::datatypes::DataType::Decimal128(16, 6),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "availability_reactive",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "availability_reactive_rbt",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "availability_reactive_gen",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "availability_reactive_rbt_gen",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "raise1sec",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lower1sec",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "raise1sec_gen",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lower1sec_gen",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lowerreg_ace",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "raisereg_ace",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "raise1sec_ace",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "raise1sec_asoe",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lower1sec_ace",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lower1sec_asoe",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
            ]),
        )
    }
    fn new_builder() -> Self::Builder {
        BillingAsrecovery9Builder {
            regionid_array: arrow::array::builder::StringBuilder::new(),
            contractyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            weekno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            billrunno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            participantid_array: arrow::array::builder::StringBuilder::new(),
            raise6sec_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            lower6sec_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            raise60sec_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            lower60sec_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            agc_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            fcascomp_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            loadshed_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            rgul_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            rguu_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            reactivepower_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            systemrestart_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
            raise6sec_gen_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            lower6sec_gen_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            raise60sec_gen_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            lower60sec_gen_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            agc_gen_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            fcascomp_gen_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            loadshed_gen_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            rgul_gen_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            rguu_gen_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            reactivepower_gen_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            systemrestart_gen_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            lower5min_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            raise5min_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            lowerreg_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            raisereg_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            lower5min_gen_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(16, 6)),
            raise5min_gen_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(16, 6)),
            lowerreg_gen_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(16, 6)),
            raisereg_gen_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(16, 6)),
            availability_reactive_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            availability_reactive_rbt_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            availability_reactive_gen_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            availability_reactive_rbt_gen_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            raise1sec_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            lower1sec_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            raise1sec_gen_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            lower1sec_gen_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            lowerreg_ace_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            raisereg_ace_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            raise1sec_ace_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            raise1sec_asoe_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            lower1sec_ace_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            lower1sec_asoe_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
        }
    }
    fn append_builder(builder: &mut Self::Builder, row: Self::Row<'_>) {
        builder.regionid_array.append_value(row.regionid());
        builder
            .contractyear_array
            .append_value({
                let mut val = row.contractyear;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .weekno_array
            .append_value({
                let mut val = row.weekno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .billrunno_array
            .append_value({
                let mut val = row.billrunno;
                val.rescale(0);
                val.mantissa()
            });
        builder.participantid_array.append_value(row.participantid());
        builder
            .raise6sec_array
            .append_option({
                row.raise6sec
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .lower6sec_array
            .append_option({
                row.lower6sec
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .raise60sec_array
            .append_option({
                row.raise60sec
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .lower60sec_array
            .append_option({
                row.lower60sec
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .agc_array
            .append_option({
                row.agc
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .fcascomp_array
            .append_option({
                row.fcascomp
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .loadshed_array
            .append_option({
                row.loadshed
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .rgul_array
            .append_option({
                row.rgul
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .rguu_array
            .append_option({
                row.rguu
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .reactivepower_array
            .append_option({
                row.reactivepower
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .systemrestart_array
            .append_option({
                row.systemrestart
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .lastchanged_array
            .append_option(row.lastchanged.map(|val| val.and_utc().timestamp_millis()));
        builder
            .raise6sec_gen_array
            .append_option({
                row.raise6sec_gen
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .lower6sec_gen_array
            .append_option({
                row.lower6sec_gen
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .raise60sec_gen_array
            .append_option({
                row.raise60sec_gen
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .lower60sec_gen_array
            .append_option({
                row.lower60sec_gen
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .agc_gen_array
            .append_option({
                row.agc_gen
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .fcascomp_gen_array
            .append_option({
                row.fcascomp_gen
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .loadshed_gen_array
            .append_option({
                row.loadshed_gen
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .rgul_gen_array
            .append_option({
                row.rgul_gen
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .rguu_gen_array
            .append_option({
                row.rguu_gen
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .reactivepower_gen_array
            .append_option({
                row.reactivepower_gen
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .systemrestart_gen_array
            .append_option({
                row.systemrestart_gen
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .lower5min_array
            .append_option({
                row.lower5min
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .raise5min_array
            .append_option({
                row.raise5min
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .lowerreg_array
            .append_option({
                row.lowerreg
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .raisereg_array
            .append_option({
                row.raisereg
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .lower5min_gen_array
            .append_option({
                row.lower5min_gen
                    .map(|mut val| {
                        val.rescale(6);
                        val.mantissa()
                    })
            });
        builder
            .raise5min_gen_array
            .append_option({
                row.raise5min_gen
                    .map(|mut val| {
                        val.rescale(6);
                        val.mantissa()
                    })
            });
        builder
            .lowerreg_gen_array
            .append_option({
                row.lowerreg_gen
                    .map(|mut val| {
                        val.rescale(6);
                        val.mantissa()
                    })
            });
        builder
            .raisereg_gen_array
            .append_option({
                row.raisereg_gen
                    .map(|mut val| {
                        val.rescale(6);
                        val.mantissa()
                    })
            });
        builder
            .availability_reactive_array
            .append_option({
                row.availability_reactive
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .availability_reactive_rbt_array
            .append_option({
                row.availability_reactive_rbt
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .availability_reactive_gen_array
            .append_option({
                row.availability_reactive_gen
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .availability_reactive_rbt_gen_array
            .append_option({
                row.availability_reactive_rbt_gen
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .raise1sec_array
            .append_option({
                row.raise1sec
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .lower1sec_array
            .append_option({
                row.lower1sec
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .raise1sec_gen_array
            .append_option({
                row.raise1sec_gen
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .lower1sec_gen_array
            .append_option({
                row.lower1sec_gen
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .lowerreg_ace_array
            .append_option({
                row.lowerreg_ace
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .raisereg_ace_array
            .append_option({
                row.raisereg_ace
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .raise1sec_ace_array
            .append_option({
                row.raise1sec_ace
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .raise1sec_asoe_array
            .append_option({
                row.raise1sec_asoe
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .lower1sec_ace_array
            .append_option({
                row.lower1sec_ace
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .lower1sec_asoe_array
            .append_option({
                row.lower1sec_asoe
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
    }
    fn finalize_builder(
        builder: &mut Self::Builder,
    ) -> mmsdm_core::Result<arrow::array::RecordBatch> {
        arrow::array::RecordBatch::try_new(
                alloc::sync::Arc::new(<Self as mmsdm_core::ArrowSchema>::schema()),
                alloc::vec::Vec::from([
                    alloc::sync::Arc::new(builder.regionid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.participantid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.raise6sec_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lower6sec_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.raise60sec_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lower60sec_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.agc_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.fcascomp_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.loadshed_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.rgul_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.rguu_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.reactivepower_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.systemrestart_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lastchanged_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.raise6sec_gen_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lower6sec_gen_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.raise60sec_gen_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lower60sec_gen_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.agc_gen_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.fcascomp_gen_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.loadshed_gen_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.rgul_gen_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.rguu_gen_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.reactivepower_gen_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.systemrestart_gen_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lower5min_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.raise5min_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lowerreg_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.raisereg_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lower5min_gen_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.raise5min_gen_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lowerreg_gen_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.raisereg_gen_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.availability_reactive_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(
                        builder.availability_reactive_rbt_array.finish(),
                    ) as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(
                        builder.availability_reactive_gen_array.finish(),
                    ) as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(
                        builder.availability_reactive_rbt_gen_array.finish(),
                    ) as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.raise1sec_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lower1sec_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.raise1sec_gen_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lower1sec_gen_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lowerreg_ace_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.raisereg_ace_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.raise1sec_ace_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.raise1sec_asoe_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lower1sec_ace_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lower1sec_asoe_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                ]),
            )
            .map_err(Into::into)
    }
}
#[cfg(feature = "arrow")]
pub struct BillingAsrecovery9Builder {
    regionid_array: arrow::array::builder::StringBuilder,
    contractyear_array: arrow::array::builder::Decimal128Builder,
    weekno_array: arrow::array::builder::Decimal128Builder,
    billrunno_array: arrow::array::builder::Decimal128Builder,
    participantid_array: arrow::array::builder::StringBuilder,
    raise6sec_array: arrow::array::builder::Decimal128Builder,
    lower6sec_array: arrow::array::builder::Decimal128Builder,
    raise60sec_array: arrow::array::builder::Decimal128Builder,
    lower60sec_array: arrow::array::builder::Decimal128Builder,
    agc_array: arrow::array::builder::Decimal128Builder,
    fcascomp_array: arrow::array::builder::Decimal128Builder,
    loadshed_array: arrow::array::builder::Decimal128Builder,
    rgul_array: arrow::array::builder::Decimal128Builder,
    rguu_array: arrow::array::builder::Decimal128Builder,
    reactivepower_array: arrow::array::builder::Decimal128Builder,
    systemrestart_array: arrow::array::builder::Decimal128Builder,
    lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder,
    raise6sec_gen_array: arrow::array::builder::Decimal128Builder,
    lower6sec_gen_array: arrow::array::builder::Decimal128Builder,
    raise60sec_gen_array: arrow::array::builder::Decimal128Builder,
    lower60sec_gen_array: arrow::array::builder::Decimal128Builder,
    agc_gen_array: arrow::array::builder::Decimal128Builder,
    fcascomp_gen_array: arrow::array::builder::Decimal128Builder,
    loadshed_gen_array: arrow::array::builder::Decimal128Builder,
    rgul_gen_array: arrow::array::builder::Decimal128Builder,
    rguu_gen_array: arrow::array::builder::Decimal128Builder,
    reactivepower_gen_array: arrow::array::builder::Decimal128Builder,
    systemrestart_gen_array: arrow::array::builder::Decimal128Builder,
    lower5min_array: arrow::array::builder::Decimal128Builder,
    raise5min_array: arrow::array::builder::Decimal128Builder,
    lowerreg_array: arrow::array::builder::Decimal128Builder,
    raisereg_array: arrow::array::builder::Decimal128Builder,
    lower5min_gen_array: arrow::array::builder::Decimal128Builder,
    raise5min_gen_array: arrow::array::builder::Decimal128Builder,
    lowerreg_gen_array: arrow::array::builder::Decimal128Builder,
    raisereg_gen_array: arrow::array::builder::Decimal128Builder,
    availability_reactive_array: arrow::array::builder::Decimal128Builder,
    availability_reactive_rbt_array: arrow::array::builder::Decimal128Builder,
    availability_reactive_gen_array: arrow::array::builder::Decimal128Builder,
    availability_reactive_rbt_gen_array: arrow::array::builder::Decimal128Builder,
    raise1sec_array: arrow::array::builder::Decimal128Builder,
    lower1sec_array: arrow::array::builder::Decimal128Builder,
    raise1sec_gen_array: arrow::array::builder::Decimal128Builder,
    lower1sec_gen_array: arrow::array::builder::Decimal128Builder,
    lowerreg_ace_array: arrow::array::builder::Decimal128Builder,
    raisereg_ace_array: arrow::array::builder::Decimal128Builder,
    raise1sec_ace_array: arrow::array::builder::Decimal128Builder,
    raise1sec_asoe_array: arrow::array::builder::Decimal128Builder,
    lower1sec_ace_array: arrow::array::builder::Decimal128Builder,
    lower1sec_asoe_array: arrow::array::builder::Decimal128Builder,
}
pub struct BillingCpdata7 {
    extract_row_partition: alloc::boxed::Box<
        dyn Fn(
            &BillingCpdata7Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    >,
    row_partition_key: mmsdm_core::PartitionKey,
}
impl BillingCpdata7 {
    pub fn new(
        row_partition_key: mmsdm_core::PartitionKey,
        func: impl Fn(
            &<Self as mmsdm_core::GetTable>::Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    ) -> Self {
        Self {
            extract_row_partition: alloc::boxed::Box::new(func),
            row_partition_key,
        }
    }
}
pub struct BillingCpdata7Mapping([usize; 16]);
/// # Summary
///
/// ## BILLINGCPDATA
///  _BILLINGCPDATA shows energy quantity and $ value purchased per participant connection point._
///
/// * Data Set Name: Billing
/// * File Name: Cpdata
/// * Data Version: 7
///
/// # Description
///  BILLINGCPDATA data is confidential to relevant participant. Source Populated by the posting of a billing run, being several times each week. Volume The number of records depends on  the number of Transmission ConnectionPointIDs a participant may use to purchase energy. An indicative maximum is approximately 150 records per billrunno, or about 1,500 records inserted per week.
///
///
///
/// # Primary Key Columns
///
/// * BILLRUNNO
/// * CONNECTIONPOINTID
/// * CONTRACTYEAR
/// * MDA
/// * PARTICIPANTID
/// * WEEKNO
#[derive(Debug, PartialEq, Eq)]
pub struct BillingCpdata7Row<'data> {
    /// AEMO Contract Year number starting in week containing 1st January
    pub contractyear: rust_decimal::Decimal,
    /// Week no within the contract year. Week no 1 is the week containing 1st January
    pub weekno: rust_decimal::Decimal,
    /// Unique run no within a given contract year and week no
    pub billrunno: rust_decimal::Decimal,
    /// Unique participant identifier
    pub participantid: core::ops::Range<usize>,
    /// Unique connection point identifier
    pub connectionpointid: core::ops::Range<usize>,
    /// Aggregate energy purchased/sold by customer, in MWh, plus UFEA. When GS commences, this includes the UFEA amount in the settlement runs.
    pub aggregateenergy: Option<rust_decimal::Decimal>,
    /// The Purchase column has the dollar value of the Energy Purchased rather than Aggregate Energy Dollar
    pub purchases: Option<rust_decimal::Decimal>,
    /// Last date and time record changed
    pub lastchanged: Option<chrono::NaiveDateTime>,
    /// relevant MDA for this connection point.
    pub mda: core::ops::Range<usize>,
    /// Adjusted Gross Energy for this Market Customer FRMP and TNI in the Billing run, excluding any UFEA component.
    pub afe: Option<rust_decimal::Decimal>,
    /// Sum of ME- for all NMIs at this Market Customer FRMP and TNI in the Billing run.
    pub dme: Option<rust_decimal::Decimal>,
    /// Share of UFE allocated to this FRMP and TNI in the Billing run.
    pub ufea: Option<rust_decimal::Decimal>,
    /// Adjusted Gross Energy for this Market Customer FRMP and TNI in the trading interval. This will include the UFEA value once financial settlement of UFE commences with GS.
    pub age: Option<rust_decimal::Decimal>,
    /// Energy sold at the connection point by the participant in this billing run
    pub soldenergy: Option<rust_decimal::Decimal>,
    /// The total cost of energy sold at the connection point by the participant in this billing run
    pub sales: Option<rust_decimal::Decimal>,
    /// The energy consumed at the connection point by the participant in this billing run
    pub purchasedenergy: Option<rust_decimal::Decimal>,
    backing_data: mmsdm_core::CsvRow<'data>,
}
impl<'data> BillingCpdata7Row<'data> {
    pub fn participantid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.participantid.clone())
    }
    pub fn connectionpointid(&self) -> &str {
        core::ops::Index::index(
            self.backing_data.as_slice(),
            self.connectionpointid.clone(),
        )
    }
    pub fn mda(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.mda.clone())
    }
}
impl mmsdm_core::GetTable for BillingCpdata7 {
    const VERSION: i32 = 7;
    const DATA_SET_NAME: &'static str = "BILLING";
    const TABLE_NAME: &'static str = "CPDATA";
    const DEFAULT_FIELD_MAPPING: Self::FieldMapping = BillingCpdata7Mapping([
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
    ]);
    const COLUMNS: &'static [&'static str] = &[
        "CONTRACTYEAR",
        "WEEKNO",
        "BILLRUNNO",
        "PARTICIPANTID",
        "CONNECTIONPOINTID",
        "AGGREGATEENERGY",
        "PURCHASES",
        "LASTCHANGED",
        "MDA",
        "AFE",
        "DME",
        "UFEA",
        "AGE",
        "SOLDENERGY",
        "SALES",
        "PURCHASEDENERGY",
    ];
    type Row<'row> = BillingCpdata7Row<'row>;
    type FieldMapping = BillingCpdata7Mapping;
    type PrimaryKey = BillingCpdata7PrimaryKey;
    fn from_row<'data>(
        row: mmsdm_core::CsvRow<'data>,
        field_mapping: &Self::FieldMapping,
    ) -> mmsdm_core::Result<Self::Row<'data>> {
        Ok(BillingCpdata7Row {
            contractyear: row
                .get_custom_parsed_at_idx(
                    "contractyear",
                    field_mapping.0[0],
                    mmsdm_core::mms_decimal::parse,
                )?,
            weekno: row
                .get_custom_parsed_at_idx(
                    "weekno",
                    field_mapping.0[1],
                    mmsdm_core::mms_decimal::parse,
                )?,
            billrunno: row
                .get_custom_parsed_at_idx(
                    "billrunno",
                    field_mapping.0[2],
                    mmsdm_core::mms_decimal::parse,
                )?,
            participantid: row.get_range("participantid", field_mapping.0[3])?,
            connectionpointid: row.get_range("connectionpointid", field_mapping.0[4])?,
            aggregateenergy: row
                .get_opt_custom_parsed_at_idx(
                    "aggregateenergy",
                    field_mapping.0[5],
                    mmsdm_core::mms_decimal::parse,
                )?,
            purchases: row
                .get_opt_custom_parsed_at_idx(
                    "purchases",
                    field_mapping.0[6],
                    mmsdm_core::mms_decimal::parse,
                )?,
            lastchanged: row
                .get_opt_custom_parsed_at_idx(
                    "lastchanged",
                    field_mapping.0[7],
                    mmsdm_core::mms_datetime::parse,
                )?,
            mda: row.get_range("mda", field_mapping.0[8])?,
            afe: row
                .get_opt_custom_parsed_at_idx(
                    "afe",
                    field_mapping.0[9],
                    mmsdm_core::mms_decimal::parse,
                )?,
            dme: row
                .get_opt_custom_parsed_at_idx(
                    "dme",
                    field_mapping.0[10],
                    mmsdm_core::mms_decimal::parse,
                )?,
            ufea: row
                .get_opt_custom_parsed_at_idx(
                    "ufea",
                    field_mapping.0[11],
                    mmsdm_core::mms_decimal::parse,
                )?,
            age: row
                .get_opt_custom_parsed_at_idx(
                    "age",
                    field_mapping.0[12],
                    mmsdm_core::mms_decimal::parse,
                )?,
            soldenergy: row
                .get_opt_custom_parsed_at_idx(
                    "soldenergy",
                    field_mapping.0[13],
                    mmsdm_core::mms_decimal::parse,
                )?,
            sales: row
                .get_opt_custom_parsed_at_idx(
                    "sales",
                    field_mapping.0[14],
                    mmsdm_core::mms_decimal::parse,
                )?,
            purchasedenergy: row
                .get_opt_custom_parsed_at_idx(
                    "purchasedenergy",
                    field_mapping.0[15],
                    mmsdm_core::mms_decimal::parse,
                )?,
            backing_data: row,
        })
    }
    fn field_mapping_from_row<'a>(
        mut row: mmsdm_core::CsvRow<'a>,
    ) -> mmsdm_core::Result<Self::FieldMapping> {
        if !row.is_heading() {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!("Expected an I row but got {row:?}"),
                ),
            );
        }
        let row_key = mmsdm_core::FileKey::from_row(row.borrow())?;
        if !Self::matches_file_key(&row_key, row_key.version) {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!(
                        "Expected a row matching {}.{}.v{} but got {row_key}",
                        Self::DATA_SET_NAME, Self::TABLE_NAME, Self::VERSION
                    ),
                ),
            );
        }
        let mut base_mapping = Self::DEFAULT_FIELD_MAPPING.0;
        for (field_index, field) in Self::COLUMNS.iter().enumerate() {
            base_mapping[field_index] = row
                .iter_fields()
                .position(|f| f == *field)
                .unwrap_or(usize::MAX);
        }
        Ok(BillingCpdata7Mapping(base_mapping))
    }
    fn matches_file_key(key: &mmsdm_core::FileKey<'_>, version: i32) -> bool {
        version == key.version && Self::DATA_SET_NAME == key.data_set_name()
            && Self::TABLE_NAME == key.table_name()
    }
    fn primary_key(row: &Self::Row<'_>) -> BillingCpdata7PrimaryKey {
        BillingCpdata7PrimaryKey {
            billrunno: row.billrunno,
            connectionpointid: row.connectionpointid().to_string(),
            contractyear: row.contractyear,
            mda: row.mda().to_string(),
            participantid: row.participantid().to_string(),
            weekno: row.weekno,
        }
    }
    fn partition_value(&self, row: &Self::Row<'_>) -> mmsdm_core::PartitionValue {
        (self.extract_row_partition)(row)
    }
    fn partition_name(&self, row: &Self::Row<'_>) -> alloc::string::String {
        alloc::format!("billing_cpdata_v7_{}", self.partition_value(row))
    }
    fn partition_key(&self) -> mmsdm_core::PartitionKey {
        self.row_partition_key
    }
    fn to_static<'a>(row: &Self::Row<'a>) -> Self::Row<'static> {
        BillingCpdata7Row {
            contractyear: row.contractyear.clone(),
            weekno: row.weekno.clone(),
            billrunno: row.billrunno.clone(),
            participantid: row.participantid.clone(),
            connectionpointid: row.connectionpointid.clone(),
            aggregateenergy: row.aggregateenergy.clone(),
            purchases: row.purchases.clone(),
            lastchanged: row.lastchanged.clone(),
            mda: row.mda.clone(),
            afe: row.afe.clone(),
            dme: row.dme.clone(),
            ufea: row.ufea.clone(),
            age: row.age.clone(),
            soldenergy: row.soldenergy.clone(),
            sales: row.sales.clone(),
            purchasedenergy: row.purchasedenergy.clone(),
            backing_data: row.backing_data.to_owned(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct BillingCpdata7PrimaryKey {
    pub billrunno: rust_decimal::Decimal,
    pub connectionpointid: alloc::string::String,
    pub contractyear: rust_decimal::Decimal,
    pub mda: alloc::string::String,
    pub participantid: alloc::string::String,
    pub weekno: rust_decimal::Decimal,
}
impl mmsdm_core::PrimaryKey for BillingCpdata7PrimaryKey {}
impl<'data> mmsdm_core::CompareWithRow for BillingCpdata7Row<'data> {
    type Row<'other> = BillingCpdata7Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno
            && self.connectionpointid() == row.connectionpointid()
            && self.contractyear == row.contractyear && self.mda() == row.mda()
            && self.participantid() == row.participantid() && self.weekno == row.weekno
    }
}
impl<'data> mmsdm_core::CompareWithPrimaryKey for BillingCpdata7Row<'data> {
    type PrimaryKey = BillingCpdata7PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno
            && self.connectionpointid() == key.connectionpointid
            && self.contractyear == key.contractyear && self.mda() == key.mda
            && self.participantid() == key.participantid && self.weekno == key.weekno
    }
}
impl<'data> mmsdm_core::CompareWithRow for BillingCpdata7PrimaryKey {
    type Row<'other> = BillingCpdata7Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno
            && self.connectionpointid == row.connectionpointid()
            && self.contractyear == row.contractyear && self.mda == row.mda()
            && self.participantid == row.participantid() && self.weekno == row.weekno
    }
}
impl mmsdm_core::CompareWithPrimaryKey for BillingCpdata7PrimaryKey {
    type PrimaryKey = BillingCpdata7PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno
            && self.connectionpointid == key.connectionpointid
            && self.contractyear == key.contractyear && self.mda == key.mda
            && self.participantid == key.participantid && self.weekno == key.weekno
    }
}
#[cfg(feature = "arrow")]
impl mmsdm_core::ArrowSchema for BillingCpdata7 {
    type Builder = BillingCpdata7Builder;
    fn schema() -> arrow::datatypes::Schema {
        arrow::datatypes::Schema::new(
            alloc::vec::Vec::from([
                arrow::datatypes::Field::new(
                    "contractyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "weekno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "billrunno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "participantid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "connectionpointid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "aggregateenergy",
                    arrow::datatypes::DataType::Decimal128(16, 6),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "purchases",
                    arrow::datatypes::DataType::Decimal128(16, 6),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lastchanged",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "mda",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "afe",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "dme",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "ufea",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "age",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "soldenergy",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "sales",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "purchasedenergy",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
            ]),
        )
    }
    fn new_builder() -> Self::Builder {
        BillingCpdata7Builder {
            contractyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            weekno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            billrunno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            participantid_array: arrow::array::builder::StringBuilder::new(),
            connectionpointid_array: arrow::array::builder::StringBuilder::new(),
            aggregateenergy_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(16, 6)),
            purchases_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(16, 6)),
            lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
            mda_array: arrow::array::builder::StringBuilder::new(),
            afe_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            dme_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            ufea_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            age_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            soldenergy_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            sales_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            purchasedenergy_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
        }
    }
    fn append_builder(builder: &mut Self::Builder, row: Self::Row<'_>) {
        builder
            .contractyear_array
            .append_value({
                let mut val = row.contractyear;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .weekno_array
            .append_value({
                let mut val = row.weekno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .billrunno_array
            .append_value({
                let mut val = row.billrunno;
                val.rescale(0);
                val.mantissa()
            });
        builder.participantid_array.append_value(row.participantid());
        builder.connectionpointid_array.append_value(row.connectionpointid());
        builder
            .aggregateenergy_array
            .append_option({
                row.aggregateenergy
                    .map(|mut val| {
                        val.rescale(6);
                        val.mantissa()
                    })
            });
        builder
            .purchases_array
            .append_option({
                row.purchases
                    .map(|mut val| {
                        val.rescale(6);
                        val.mantissa()
                    })
            });
        builder
            .lastchanged_array
            .append_option(row.lastchanged.map(|val| val.and_utc().timestamp_millis()));
        builder.mda_array.append_value(row.mda());
        builder
            .afe_array
            .append_option({
                row.afe
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .dme_array
            .append_option({
                row.dme
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .ufea_array
            .append_option({
                row.ufea
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .age_array
            .append_option({
                row.age
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .soldenergy_array
            .append_option({
                row.soldenergy
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .sales_array
            .append_option({
                row.sales
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .purchasedenergy_array
            .append_option({
                row.purchasedenergy
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
    }
    fn finalize_builder(
        builder: &mut Self::Builder,
    ) -> mmsdm_core::Result<arrow::array::RecordBatch> {
        arrow::array::RecordBatch::try_new(
                alloc::sync::Arc::new(<Self as mmsdm_core::ArrowSchema>::schema()),
                alloc::vec::Vec::from([
                    alloc::sync::Arc::new(builder.contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.participantid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.connectionpointid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.aggregateenergy_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.purchases_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lastchanged_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.mda_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.afe_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.dme_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.ufea_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.age_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.soldenergy_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.sales_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.purchasedenergy_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                ]),
            )
            .map_err(Into::into)
    }
}
#[cfg(feature = "arrow")]
pub struct BillingCpdata7Builder {
    contractyear_array: arrow::array::builder::Decimal128Builder,
    weekno_array: arrow::array::builder::Decimal128Builder,
    billrunno_array: arrow::array::builder::Decimal128Builder,
    participantid_array: arrow::array::builder::StringBuilder,
    connectionpointid_array: arrow::array::builder::StringBuilder,
    aggregateenergy_array: arrow::array::builder::Decimal128Builder,
    purchases_array: arrow::array::builder::Decimal128Builder,
    lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder,
    mda_array: arrow::array::builder::StringBuilder,
    afe_array: arrow::array::builder::Decimal128Builder,
    dme_array: arrow::array::builder::Decimal128Builder,
    ufea_array: arrow::array::builder::Decimal128Builder,
    age_array: arrow::array::builder::Decimal128Builder,
    soldenergy_array: arrow::array::builder::Decimal128Builder,
    sales_array: arrow::array::builder::Decimal128Builder,
    purchasedenergy_array: arrow::array::builder::Decimal128Builder,
}
pub struct BillingDaytrk5 {
    extract_row_partition: alloc::boxed::Box<
        dyn Fn(
            &BillingDaytrk5Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    >,
    row_partition_key: mmsdm_core::PartitionKey,
}
impl BillingDaytrk5 {
    pub fn new(
        row_partition_key: mmsdm_core::PartitionKey,
        func: impl Fn(
            &<Self as mmsdm_core::GetTable>::Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    ) -> Self {
        Self {
            extract_row_partition: alloc::boxed::Box::new(func),
            row_partition_key,
        }
    }
}
pub struct BillingDaytrk5Mapping([usize; 6]);
/// # Summary
///
/// ## BILLINGDAYTRK
///  _BILLINGDAYTRK is key for matching settlement versions with billing runs. BILLINGDAYTRK displays the billrunnos per billing week, and the settlement version numbers per settlement day comprising the billrunno._
///
/// * Data Set Name: Billing
/// * File Name: Daytrk
/// * Data Version: 5
///
/// # Description
///  BILLINGDAYTRK  is public data, and is available to all participants. Source BILLINGDAYTRK is populated by the posting of a billing run, being several times each week. Volume Each billing run inserts approximately 7 records, being about 77 records per week.
///
///
///
/// # Primary Key Columns
///
/// * BILLRUNNO
/// * CONTRACTYEAR
/// * SETTLEMENTDATE
/// * WEEKNO
#[derive(Debug, PartialEq, Eq)]
pub struct BillingDaytrk5Row<'data> {
    /// AEMO Contract Year number starting in week containing 1st January
    pub contractyear: rust_decimal::Decimal,
    /// Week no within the contract year. Week no 1 is the week containing 1st January
    pub weekno: rust_decimal::Decimal,
    /// Unique run no within a given contract year and week no
    pub billrunno: rust_decimal::Decimal,
    /// Calendar Settlement Date contained in the billing run.
    pub settlementdate: chrono::NaiveDateTime,
    /// Settlement run number used for each settlement date in that billing run.
    pub runno: Option<rust_decimal::Decimal>,
    /// Last date and time record changed
    pub lastchanged: Option<chrono::NaiveDateTime>,
    backing_data: core::marker::PhantomData<&'data ()>,
}
impl<'data> BillingDaytrk5Row<'data> {}
impl mmsdm_core::GetTable for BillingDaytrk5 {
    const VERSION: i32 = 5;
    const DATA_SET_NAME: &'static str = "BILLING";
    const TABLE_NAME: &'static str = "DAYTRK";
    const DEFAULT_FIELD_MAPPING: Self::FieldMapping = BillingDaytrk5Mapping([
        4,
        5,
        6,
        7,
        8,
        9,
    ]);
    const COLUMNS: &'static [&'static str] = &[
        "CONTRACTYEAR",
        "WEEKNO",
        "BILLRUNNO",
        "SETTLEMENTDATE",
        "RUNNO",
        "LASTCHANGED",
    ];
    type Row<'row> = BillingDaytrk5Row<'row>;
    type FieldMapping = BillingDaytrk5Mapping;
    type PrimaryKey = BillingDaytrk5PrimaryKey;
    fn from_row<'data>(
        row: mmsdm_core::CsvRow<'data>,
        field_mapping: &Self::FieldMapping,
    ) -> mmsdm_core::Result<Self::Row<'data>> {
        Ok(BillingDaytrk5Row {
            contractyear: row
                .get_custom_parsed_at_idx(
                    "contractyear",
                    field_mapping.0[0],
                    mmsdm_core::mms_decimal::parse,
                )?,
            weekno: row
                .get_custom_parsed_at_idx(
                    "weekno",
                    field_mapping.0[1],
                    mmsdm_core::mms_decimal::parse,
                )?,
            billrunno: row
                .get_custom_parsed_at_idx(
                    "billrunno",
                    field_mapping.0[2],
                    mmsdm_core::mms_decimal::parse,
                )?,
            settlementdate: row
                .get_custom_parsed_at_idx(
                    "settlementdate",
                    field_mapping.0[3],
                    mmsdm_core::mms_datetime::parse,
                )?,
            runno: row
                .get_opt_custom_parsed_at_idx(
                    "runno",
                    field_mapping.0[4],
                    mmsdm_core::mms_decimal::parse,
                )?,
            lastchanged: row
                .get_opt_custom_parsed_at_idx(
                    "lastchanged",
                    field_mapping.0[5],
                    mmsdm_core::mms_datetime::parse,
                )?,
            backing_data: core::marker::PhantomData,
        })
    }
    fn field_mapping_from_row<'a>(
        mut row: mmsdm_core::CsvRow<'a>,
    ) -> mmsdm_core::Result<Self::FieldMapping> {
        if !row.is_heading() {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!("Expected an I row but got {row:?}"),
                ),
            );
        }
        let row_key = mmsdm_core::FileKey::from_row(row.borrow())?;
        if !Self::matches_file_key(&row_key, row_key.version) {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!(
                        "Expected a row matching {}.{}.v{} but got {row_key}",
                        Self::DATA_SET_NAME, Self::TABLE_NAME, Self::VERSION
                    ),
                ),
            );
        }
        let mut base_mapping = Self::DEFAULT_FIELD_MAPPING.0;
        for (field_index, field) in Self::COLUMNS.iter().enumerate() {
            base_mapping[field_index] = row
                .iter_fields()
                .position(|f| f == *field)
                .unwrap_or(usize::MAX);
        }
        Ok(BillingDaytrk5Mapping(base_mapping))
    }
    fn matches_file_key(key: &mmsdm_core::FileKey<'_>, version: i32) -> bool {
        version == key.version && Self::DATA_SET_NAME == key.data_set_name()
            && Self::TABLE_NAME == key.table_name()
    }
    fn primary_key(row: &Self::Row<'_>) -> BillingDaytrk5PrimaryKey {
        BillingDaytrk5PrimaryKey {
            billrunno: row.billrunno,
            contractyear: row.contractyear,
            settlementdate: row.settlementdate,
            weekno: row.weekno,
        }
    }
    fn partition_value(&self, row: &Self::Row<'_>) -> mmsdm_core::PartitionValue {
        (self.extract_row_partition)(row)
    }
    fn partition_name(&self, row: &Self::Row<'_>) -> alloc::string::String {
        alloc::format!("billing_daytrk_v5_{}", self.partition_value(row))
    }
    fn partition_key(&self) -> mmsdm_core::PartitionKey {
        self.row_partition_key
    }
    fn to_static<'a>(row: &Self::Row<'a>) -> Self::Row<'static> {
        BillingDaytrk5Row {
            contractyear: row.contractyear.clone(),
            weekno: row.weekno.clone(),
            billrunno: row.billrunno.clone(),
            settlementdate: row.settlementdate.clone(),
            runno: row.runno.clone(),
            lastchanged: row.lastchanged.clone(),
            backing_data: core::marker::PhantomData,
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct BillingDaytrk5PrimaryKey {
    pub billrunno: rust_decimal::Decimal,
    pub contractyear: rust_decimal::Decimal,
    pub settlementdate: chrono::NaiveDateTime,
    pub weekno: rust_decimal::Decimal,
}
impl mmsdm_core::PrimaryKey for BillingDaytrk5PrimaryKey {}
impl<'data> mmsdm_core::CompareWithRow for BillingDaytrk5Row<'data> {
    type Row<'other> = BillingDaytrk5Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.settlementdate == row.settlementdate && self.weekno == row.weekno
    }
}
impl<'data> mmsdm_core::CompareWithPrimaryKey for BillingDaytrk5Row<'data> {
    type PrimaryKey = BillingDaytrk5PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.settlementdate == key.settlementdate && self.weekno == key.weekno
    }
}
impl<'data> mmsdm_core::CompareWithRow for BillingDaytrk5PrimaryKey {
    type Row<'other> = BillingDaytrk5Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.settlementdate == row.settlementdate && self.weekno == row.weekno
    }
}
impl mmsdm_core::CompareWithPrimaryKey for BillingDaytrk5PrimaryKey {
    type PrimaryKey = BillingDaytrk5PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.settlementdate == key.settlementdate && self.weekno == key.weekno
    }
}
#[cfg(feature = "arrow")]
impl mmsdm_core::ArrowSchema for BillingDaytrk5 {
    type Builder = BillingDaytrk5Builder;
    fn schema() -> arrow::datatypes::Schema {
        arrow::datatypes::Schema::new(
            alloc::vec::Vec::from([
                arrow::datatypes::Field::new(
                    "contractyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "weekno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "billrunno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "settlementdate",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "runno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lastchanged",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    true,
                ),
            ]),
        )
    }
    fn new_builder() -> Self::Builder {
        BillingDaytrk5Builder {
            contractyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            weekno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            billrunno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            settlementdate_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
            runno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
        }
    }
    fn append_builder(builder: &mut Self::Builder, row: Self::Row<'_>) {
        builder
            .contractyear_array
            .append_value({
                let mut val = row.contractyear;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .weekno_array
            .append_value({
                let mut val = row.weekno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .billrunno_array
            .append_value({
                let mut val = row.billrunno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .settlementdate_array
            .append_value(row.settlementdate.and_utc().timestamp_millis());
        builder
            .runno_array
            .append_option({
                row.runno
                    .map(|mut val| {
                        val.rescale(0);
                        val.mantissa()
                    })
            });
        builder
            .lastchanged_array
            .append_option(row.lastchanged.map(|val| val.and_utc().timestamp_millis()));
    }
    fn finalize_builder(
        builder: &mut Self::Builder,
    ) -> mmsdm_core::Result<arrow::array::RecordBatch> {
        arrow::array::RecordBatch::try_new(
                alloc::sync::Arc::new(<Self as mmsdm_core::ArrowSchema>::schema()),
                alloc::vec::Vec::from([
                    alloc::sync::Arc::new(builder.contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.settlementdate_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.runno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lastchanged_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                ]),
            )
            .map_err(Into::into)
    }
}
#[cfg(feature = "arrow")]
pub struct BillingDaytrk5Builder {
    contractyear_array: arrow::array::builder::Decimal128Builder,
    weekno_array: arrow::array::builder::Decimal128Builder,
    billrunno_array: arrow::array::builder::Decimal128Builder,
    settlementdate_array: arrow::array::builder::TimestampMillisecondBuilder,
    runno_array: arrow::array::builder::Decimal128Builder,
    lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder,
}
pub struct BillingFees5 {
    extract_row_partition: alloc::boxed::Box<
        dyn Fn(
            &BillingFees5Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    >,
    row_partition_key: mmsdm_core::PartitionKey,
}
impl BillingFees5 {
    pub fn new(
        row_partition_key: mmsdm_core::PartitionKey,
        func: impl Fn(
            &<Self as mmsdm_core::GetTable>::Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    ) -> Self {
        Self {
            extract_row_partition: alloc::boxed::Box::new(func),
            row_partition_key,
        }
    }
}
pub struct BillingFees5Mapping([usize; 10]);
/// # Summary
///
/// ## BILLINGFEES
///  _BILLINGFEES presents pool fees applied to the statement, per billing run._
///
/// * Data Set Name: Billing
/// * File Name: Fees
/// * Data Version: 5
///
/// # Description
///  BILLINGFEES data is confidential to the relevant participant. Source BILLINGFEES is populated by the posting of a billing run, being several times each week. Volume The number of records varies according to the number of pool fee types the participant may be subject to. An indicative maximum is about 13 records inserted per billrunno or 143 records inserted per week.
///
///
///
/// # Primary Key Columns
///
/// * BILLRUNNO
/// * CONTRACTYEAR
/// * MARKETFEEID
/// * PARTICIPANTCATEGORYID
/// * PARTICIPANTID
/// * WEEKNO
#[derive(Debug, PartialEq, Eq)]
pub struct BillingFees5Row<'data> {
    /// AEMO Contract Year number starting in week containing 1st January
    pub contractyear: rust_decimal::Decimal,
    /// Week no within the contract year. Week no 1 is the week containing 1st January
    pub weekno: rust_decimal::Decimal,
    /// Unique run no within a given contract year and week no
    pub billrunno: rust_decimal::Decimal,
    /// Unique participant identifier
    pub participantid: core::ops::Range<usize>,
    /// Market fee identifier
    pub marketfeeid: core::ops::Range<usize>,
    /// Market fee rate
    pub rate: Option<rust_decimal::Decimal>,
    /// Energy, in MWh
    pub energy: Option<rust_decimal::Decimal>,
    /// Fee in $
    pub value: Option<rust_decimal::Decimal>,
    /// Last date and time record changed
    pub lastchanged: Option<chrono::NaiveDateTime>,
    /// The participant category pertaining to the market fee recovery. Corresponds to the PARTICIPANTCATEGORYID column of the SETMARKETFEES table.
    pub participantcategoryid: core::ops::Range<usize>,
    backing_data: mmsdm_core::CsvRow<'data>,
}
impl<'data> BillingFees5Row<'data> {
    pub fn participantid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.participantid.clone())
    }
    pub fn marketfeeid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.marketfeeid.clone())
    }
    pub fn participantcategoryid(&self) -> &str {
        core::ops::Index::index(
            self.backing_data.as_slice(),
            self.participantcategoryid.clone(),
        )
    }
}
impl mmsdm_core::GetTable for BillingFees5 {
    const VERSION: i32 = 5;
    const DATA_SET_NAME: &'static str = "BILLING";
    const TABLE_NAME: &'static str = "FEES";
    const DEFAULT_FIELD_MAPPING: Self::FieldMapping = BillingFees5Mapping([
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
    ]);
    const COLUMNS: &'static [&'static str] = &[
        "CONTRACTYEAR",
        "WEEKNO",
        "BILLRUNNO",
        "PARTICIPANTID",
        "MARKETFEEID",
        "RATE",
        "ENERGY",
        "VALUE",
        "LASTCHANGED",
        "PARTICIPANTCATEGORYID",
    ];
    type Row<'row> = BillingFees5Row<'row>;
    type FieldMapping = BillingFees5Mapping;
    type PrimaryKey = BillingFees5PrimaryKey;
    fn from_row<'data>(
        row: mmsdm_core::CsvRow<'data>,
        field_mapping: &Self::FieldMapping,
    ) -> mmsdm_core::Result<Self::Row<'data>> {
        Ok(BillingFees5Row {
            contractyear: row
                .get_custom_parsed_at_idx(
                    "contractyear",
                    field_mapping.0[0],
                    mmsdm_core::mms_decimal::parse,
                )?,
            weekno: row
                .get_custom_parsed_at_idx(
                    "weekno",
                    field_mapping.0[1],
                    mmsdm_core::mms_decimal::parse,
                )?,
            billrunno: row
                .get_custom_parsed_at_idx(
                    "billrunno",
                    field_mapping.0[2],
                    mmsdm_core::mms_decimal::parse,
                )?,
            participantid: row.get_range("participantid", field_mapping.0[3])?,
            marketfeeid: row.get_range("marketfeeid", field_mapping.0[4])?,
            rate: row
                .get_opt_custom_parsed_at_idx(
                    "rate",
                    field_mapping.0[5],
                    mmsdm_core::mms_decimal::parse,
                )?,
            energy: row
                .get_opt_custom_parsed_at_idx(
                    "energy",
                    field_mapping.0[6],
                    mmsdm_core::mms_decimal::parse,
                )?,
            value: row
                .get_opt_custom_parsed_at_idx(
                    "value",
                    field_mapping.0[7],
                    mmsdm_core::mms_decimal::parse,
                )?,
            lastchanged: row
                .get_opt_custom_parsed_at_idx(
                    "lastchanged",
                    field_mapping.0[8],
                    mmsdm_core::mms_datetime::parse,
                )?,
            participantcategoryid: row
                .get_range("participantcategoryid", field_mapping.0[9])?,
            backing_data: row,
        })
    }
    fn field_mapping_from_row<'a>(
        mut row: mmsdm_core::CsvRow<'a>,
    ) -> mmsdm_core::Result<Self::FieldMapping> {
        if !row.is_heading() {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!("Expected an I row but got {row:?}"),
                ),
            );
        }
        let row_key = mmsdm_core::FileKey::from_row(row.borrow())?;
        if !Self::matches_file_key(&row_key, row_key.version) {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!(
                        "Expected a row matching {}.{}.v{} but got {row_key}",
                        Self::DATA_SET_NAME, Self::TABLE_NAME, Self::VERSION
                    ),
                ),
            );
        }
        let mut base_mapping = Self::DEFAULT_FIELD_MAPPING.0;
        for (field_index, field) in Self::COLUMNS.iter().enumerate() {
            base_mapping[field_index] = row
                .iter_fields()
                .position(|f| f == *field)
                .unwrap_or(usize::MAX);
        }
        Ok(BillingFees5Mapping(base_mapping))
    }
    fn matches_file_key(key: &mmsdm_core::FileKey<'_>, version: i32) -> bool {
        version == key.version && Self::DATA_SET_NAME == key.data_set_name()
            && Self::TABLE_NAME == key.table_name()
    }
    fn primary_key(row: &Self::Row<'_>) -> BillingFees5PrimaryKey {
        BillingFees5PrimaryKey {
            billrunno: row.billrunno,
            contractyear: row.contractyear,
            marketfeeid: row.marketfeeid().to_string(),
            participantcategoryid: row.participantcategoryid().to_string(),
            participantid: row.participantid().to_string(),
            weekno: row.weekno,
        }
    }
    fn partition_value(&self, row: &Self::Row<'_>) -> mmsdm_core::PartitionValue {
        (self.extract_row_partition)(row)
    }
    fn partition_name(&self, row: &Self::Row<'_>) -> alloc::string::String {
        alloc::format!("billing_fees_v5_{}", self.partition_value(row))
    }
    fn partition_key(&self) -> mmsdm_core::PartitionKey {
        self.row_partition_key
    }
    fn to_static<'a>(row: &Self::Row<'a>) -> Self::Row<'static> {
        BillingFees5Row {
            contractyear: row.contractyear.clone(),
            weekno: row.weekno.clone(),
            billrunno: row.billrunno.clone(),
            participantid: row.participantid.clone(),
            marketfeeid: row.marketfeeid.clone(),
            rate: row.rate.clone(),
            energy: row.energy.clone(),
            value: row.value.clone(),
            lastchanged: row.lastchanged.clone(),
            participantcategoryid: row.participantcategoryid.clone(),
            backing_data: row.backing_data.to_owned(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct BillingFees5PrimaryKey {
    pub billrunno: rust_decimal::Decimal,
    pub contractyear: rust_decimal::Decimal,
    pub marketfeeid: alloc::string::String,
    pub participantcategoryid: alloc::string::String,
    pub participantid: alloc::string::String,
    pub weekno: rust_decimal::Decimal,
}
impl mmsdm_core::PrimaryKey for BillingFees5PrimaryKey {}
impl<'data> mmsdm_core::CompareWithRow for BillingFees5Row<'data> {
    type Row<'other> = BillingFees5Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.marketfeeid() == row.marketfeeid()
            && self.participantcategoryid() == row.participantcategoryid()
            && self.participantid() == row.participantid() && self.weekno == row.weekno
    }
}
impl<'data> mmsdm_core::CompareWithPrimaryKey for BillingFees5Row<'data> {
    type PrimaryKey = BillingFees5PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.marketfeeid() == key.marketfeeid
            && self.participantcategoryid() == key.participantcategoryid
            && self.participantid() == key.participantid && self.weekno == key.weekno
    }
}
impl<'data> mmsdm_core::CompareWithRow for BillingFees5PrimaryKey {
    type Row<'other> = BillingFees5Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.marketfeeid == row.marketfeeid()
            && self.participantcategoryid == row.participantcategoryid()
            && self.participantid == row.participantid() && self.weekno == row.weekno
    }
}
impl mmsdm_core::CompareWithPrimaryKey for BillingFees5PrimaryKey {
    type PrimaryKey = BillingFees5PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.marketfeeid == key.marketfeeid
            && self.participantcategoryid == key.participantcategoryid
            && self.participantid == key.participantid && self.weekno == key.weekno
    }
}
#[cfg(feature = "arrow")]
impl mmsdm_core::ArrowSchema for BillingFees5 {
    type Builder = BillingFees5Builder;
    fn schema() -> arrow::datatypes::Schema {
        arrow::datatypes::Schema::new(
            alloc::vec::Vec::from([
                arrow::datatypes::Field::new(
                    "contractyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "weekno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "billrunno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "participantid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "marketfeeid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "rate",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "energy",
                    arrow::datatypes::DataType::Decimal128(16, 6),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "value",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lastchanged",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "participantcategoryid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
            ]),
        )
    }
    fn new_builder() -> Self::Builder {
        BillingFees5Builder {
            contractyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            weekno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            billrunno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            participantid_array: arrow::array::builder::StringBuilder::new(),
            marketfeeid_array: arrow::array::builder::StringBuilder::new(),
            rate_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            energy_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(16, 6)),
            value_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
            participantcategoryid_array: arrow::array::builder::StringBuilder::new(),
        }
    }
    fn append_builder(builder: &mut Self::Builder, row: Self::Row<'_>) {
        builder
            .contractyear_array
            .append_value({
                let mut val = row.contractyear;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .weekno_array
            .append_value({
                let mut val = row.weekno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .billrunno_array
            .append_value({
                let mut val = row.billrunno;
                val.rescale(0);
                val.mantissa()
            });
        builder.participantid_array.append_value(row.participantid());
        builder.marketfeeid_array.append_value(row.marketfeeid());
        builder
            .rate_array
            .append_option({
                row.rate
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .energy_array
            .append_option({
                row.energy
                    .map(|mut val| {
                        val.rescale(6);
                        val.mantissa()
                    })
            });
        builder
            .value_array
            .append_option({
                row.value
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .lastchanged_array
            .append_option(row.lastchanged.map(|val| val.and_utc().timestamp_millis()));
        builder.participantcategoryid_array.append_value(row.participantcategoryid());
    }
    fn finalize_builder(
        builder: &mut Self::Builder,
    ) -> mmsdm_core::Result<arrow::array::RecordBatch> {
        arrow::array::RecordBatch::try_new(
                alloc::sync::Arc::new(<Self as mmsdm_core::ArrowSchema>::schema()),
                alloc::vec::Vec::from([
                    alloc::sync::Arc::new(builder.contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.participantid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.marketfeeid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.rate_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.energy_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.value_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lastchanged_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.participantcategoryid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                ]),
            )
            .map_err(Into::into)
    }
}
#[cfg(feature = "arrow")]
pub struct BillingFees5Builder {
    contractyear_array: arrow::array::builder::Decimal128Builder,
    weekno_array: arrow::array::builder::Decimal128Builder,
    billrunno_array: arrow::array::builder::Decimal128Builder,
    participantid_array: arrow::array::builder::StringBuilder,
    marketfeeid_array: arrow::array::builder::StringBuilder,
    rate_array: arrow::array::builder::Decimal128Builder,
    energy_array: arrow::array::builder::Decimal128Builder,
    value_array: arrow::array::builder::Decimal128Builder,
    lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder,
    participantcategoryid_array: arrow::array::builder::StringBuilder,
}
pub struct BillingFinancialadjustments5 {
    extract_row_partition: alloc::boxed::Box<
        dyn Fn(
            &BillingFinancialadjustments5Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    >,
    row_partition_key: mmsdm_core::PartitionKey,
}
impl BillingFinancialadjustments5 {
    pub fn new(
        row_partition_key: mmsdm_core::PartitionKey,
        func: impl Fn(
            &<Self as mmsdm_core::GetTable>::Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    ) -> Self {
        Self {
            extract_row_partition: alloc::boxed::Box::new(func),
            row_partition_key,
        }
    }
}
pub struct BillingFinancialadjustments5Mapping([usize; 11]);
/// # Summary
///
/// ## BILLINGFINANCIALADJUSTMENTS
///  _BILLINGFINANCIALADJUSTMENTS contains any manual adjustments included in the billing run._
///
/// * Data Set Name: Billing
/// * File Name: Financialadjustments
/// * Data Version: 5
///
/// # Description
///  BILLINGFINANCIALADJUSTMENTS data is confidential to the relevant participant. Source BILLINGFINANCIALADJUSTMENTS is populated by the posting of a billing run, being several times each week. The insertion of a manual adjustment in a billing run is infrequent. Volume Infrequent and, if included in a billing run, low volume. An indicative maximum is 15 records inserted.
///
///
///
/// # Primary Key Columns
///
/// * ADJUSTMENTITEM
/// * BILLRUNNO
/// * CONTRACTYEAR
/// * PARTICIPANTID
/// * WEEKNO
#[derive(Debug, PartialEq, Eq)]
pub struct BillingFinancialadjustments5Row<'data> {
    /// AEMO Contract Year number starting in week containing 1st January
    pub contractyear: rust_decimal::Decimal,
    /// Week no within the contract year. Week no 1 is the week containing 1st January
    pub weekno: rust_decimal::Decimal,
    /// Unique run no within a given contract year and week no
    pub billrunno: rust_decimal::Decimal,
    /// Unique participant identifier
    pub participantid: core::ops::Range<usize>,
    /// Not Used
    pub participanttype: core::ops::Range<usize>,
    /// Description of the adjustment being made
    pub adjustmentitem: core::ops::Range<usize>,
    /// The amount of the manual adjustment line item
    pub amount: Option<rust_decimal::Decimal>,
    /// Not Used
    pub value: Option<rust_decimal::Decimal>,
    /// Last date and time the record changed.
    pub lastchanged: Option<chrono::NaiveDateTime>,
    /// The GL financial code of the manual adjustment line item. Used internally by AEMO systems.
    pub financialcode: Option<rust_decimal::Decimal>,
    /// The BAS classification of the manual adjustment line item.
    pub bas_class: core::ops::Range<usize>,
    backing_data: mmsdm_core::CsvRow<'data>,
}
impl<'data> BillingFinancialadjustments5Row<'data> {
    pub fn participantid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.participantid.clone())
    }
    pub fn participanttype(&self) -> Option<&str> {
        if self.participanttype.is_empty() {
            None
        } else {
            Some(
                core::ops::Index::index(
                    self.backing_data.as_slice(),
                    self.participanttype.clone(),
                ),
            )
        }
    }
    pub fn adjustmentitem(&self) -> &str {
        core::ops::Index::index(
            self.backing_data.as_slice(),
            self.adjustmentitem.clone(),
        )
    }
    pub fn bas_class(&self) -> Option<&str> {
        if self.bas_class.is_empty() {
            None
        } else {
            Some(
                core::ops::Index::index(
                    self.backing_data.as_slice(),
                    self.bas_class.clone(),
                ),
            )
        }
    }
}
impl mmsdm_core::GetTable for BillingFinancialadjustments5 {
    const VERSION: i32 = 5;
    const DATA_SET_NAME: &'static str = "BILLING";
    const TABLE_NAME: &'static str = "FINANCIALADJUSTMENTS";
    const DEFAULT_FIELD_MAPPING: Self::FieldMapping = BillingFinancialadjustments5Mapping([
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
    ]);
    const COLUMNS: &'static [&'static str] = &[
        "CONTRACTYEAR",
        "WEEKNO",
        "BILLRUNNO",
        "PARTICIPANTID",
        "PARTICIPANTTYPE",
        "ADJUSTMENTITEM",
        "AMOUNT",
        "VALUE",
        "LASTCHANGED",
        "FINANCIALCODE",
        "BAS_CLASS",
    ];
    type Row<'row> = BillingFinancialadjustments5Row<'row>;
    type FieldMapping = BillingFinancialadjustments5Mapping;
    type PrimaryKey = BillingFinancialadjustments5PrimaryKey;
    fn from_row<'data>(
        row: mmsdm_core::CsvRow<'data>,
        field_mapping: &Self::FieldMapping,
    ) -> mmsdm_core::Result<Self::Row<'data>> {
        Ok(BillingFinancialadjustments5Row {
            contractyear: row
                .get_custom_parsed_at_idx(
                    "contractyear",
                    field_mapping.0[0],
                    mmsdm_core::mms_decimal::parse,
                )?,
            weekno: row
                .get_custom_parsed_at_idx(
                    "weekno",
                    field_mapping.0[1],
                    mmsdm_core::mms_decimal::parse,
                )?,
            billrunno: row
                .get_custom_parsed_at_idx(
                    "billrunno",
                    field_mapping.0[2],
                    mmsdm_core::mms_decimal::parse,
                )?,
            participantid: row.get_range("participantid", field_mapping.0[3])?,
            participanttype: row.get_opt_range("participanttype", field_mapping.0[4])?,
            adjustmentitem: row.get_range("adjustmentitem", field_mapping.0[5])?,
            amount: row
                .get_opt_custom_parsed_at_idx(
                    "amount",
                    field_mapping.0[6],
                    mmsdm_core::mms_decimal::parse,
                )?,
            value: row
                .get_opt_custom_parsed_at_idx(
                    "value",
                    field_mapping.0[7],
                    mmsdm_core::mms_decimal::parse,
                )?,
            lastchanged: row
                .get_opt_custom_parsed_at_idx(
                    "lastchanged",
                    field_mapping.0[8],
                    mmsdm_core::mms_datetime::parse,
                )?,
            financialcode: row
                .get_opt_custom_parsed_at_idx(
                    "financialcode",
                    field_mapping.0[9],
                    mmsdm_core::mms_decimal::parse,
                )?,
            bas_class: row.get_opt_range("bas_class", field_mapping.0[10])?,
            backing_data: row,
        })
    }
    fn field_mapping_from_row<'a>(
        mut row: mmsdm_core::CsvRow<'a>,
    ) -> mmsdm_core::Result<Self::FieldMapping> {
        if !row.is_heading() {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!("Expected an I row but got {row:?}"),
                ),
            );
        }
        let row_key = mmsdm_core::FileKey::from_row(row.borrow())?;
        if !Self::matches_file_key(&row_key, row_key.version) {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!(
                        "Expected a row matching {}.{}.v{} but got {row_key}",
                        Self::DATA_SET_NAME, Self::TABLE_NAME, Self::VERSION
                    ),
                ),
            );
        }
        let mut base_mapping = Self::DEFAULT_FIELD_MAPPING.0;
        for (field_index, field) in Self::COLUMNS.iter().enumerate() {
            base_mapping[field_index] = row
                .iter_fields()
                .position(|f| f == *field)
                .unwrap_or(usize::MAX);
        }
        Ok(BillingFinancialadjustments5Mapping(base_mapping))
    }
    fn matches_file_key(key: &mmsdm_core::FileKey<'_>, version: i32) -> bool {
        version == key.version && Self::DATA_SET_NAME == key.data_set_name()
            && Self::TABLE_NAME == key.table_name()
    }
    fn primary_key(row: &Self::Row<'_>) -> BillingFinancialadjustments5PrimaryKey {
        BillingFinancialadjustments5PrimaryKey {
            adjustmentitem: row.adjustmentitem().to_string(),
            billrunno: row.billrunno,
            contractyear: row.contractyear,
            participantid: row.participantid().to_string(),
            weekno: row.weekno,
        }
    }
    fn partition_value(&self, row: &Self::Row<'_>) -> mmsdm_core::PartitionValue {
        (self.extract_row_partition)(row)
    }
    fn partition_name(&self, row: &Self::Row<'_>) -> alloc::string::String {
        alloc::format!("billing_financialadjustments_v5_{}", self.partition_value(row))
    }
    fn partition_key(&self) -> mmsdm_core::PartitionKey {
        self.row_partition_key
    }
    fn to_static<'a>(row: &Self::Row<'a>) -> Self::Row<'static> {
        BillingFinancialadjustments5Row {
            contractyear: row.contractyear.clone(),
            weekno: row.weekno.clone(),
            billrunno: row.billrunno.clone(),
            participantid: row.participantid.clone(),
            participanttype: row.participanttype.clone(),
            adjustmentitem: row.adjustmentitem.clone(),
            amount: row.amount.clone(),
            value: row.value.clone(),
            lastchanged: row.lastchanged.clone(),
            financialcode: row.financialcode.clone(),
            bas_class: row.bas_class.clone(),
            backing_data: row.backing_data.to_owned(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct BillingFinancialadjustments5PrimaryKey {
    pub adjustmentitem: alloc::string::String,
    pub billrunno: rust_decimal::Decimal,
    pub contractyear: rust_decimal::Decimal,
    pub participantid: alloc::string::String,
    pub weekno: rust_decimal::Decimal,
}
impl mmsdm_core::PrimaryKey for BillingFinancialadjustments5PrimaryKey {}
impl<'data> mmsdm_core::CompareWithRow for BillingFinancialadjustments5Row<'data> {
    type Row<'other> = BillingFinancialadjustments5Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.adjustmentitem() == row.adjustmentitem() && self.billrunno == row.billrunno
            && self.contractyear == row.contractyear
            && self.participantid() == row.participantid() && self.weekno == row.weekno
    }
}
impl<'data> mmsdm_core::CompareWithPrimaryKey
for BillingFinancialadjustments5Row<'data> {
    type PrimaryKey = BillingFinancialadjustments5PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.adjustmentitem() == key.adjustmentitem && self.billrunno == key.billrunno
            && self.contractyear == key.contractyear
            && self.participantid() == key.participantid && self.weekno == key.weekno
    }
}
impl<'data> mmsdm_core::CompareWithRow for BillingFinancialadjustments5PrimaryKey {
    type Row<'other> = BillingFinancialadjustments5Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.adjustmentitem == row.adjustmentitem() && self.billrunno == row.billrunno
            && self.contractyear == row.contractyear
            && self.participantid == row.participantid() && self.weekno == row.weekno
    }
}
impl mmsdm_core::CompareWithPrimaryKey for BillingFinancialadjustments5PrimaryKey {
    type PrimaryKey = BillingFinancialadjustments5PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.adjustmentitem == key.adjustmentitem && self.billrunno == key.billrunno
            && self.contractyear == key.contractyear
            && self.participantid == key.participantid && self.weekno == key.weekno
    }
}
#[cfg(feature = "arrow")]
impl mmsdm_core::ArrowSchema for BillingFinancialadjustments5 {
    type Builder = BillingFinancialadjustments5Builder;
    fn schema() -> arrow::datatypes::Schema {
        arrow::datatypes::Schema::new(
            alloc::vec::Vec::from([
                arrow::datatypes::Field::new(
                    "contractyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "weekno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "billrunno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "participantid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "participanttype",
                    arrow::datatypes::DataType::Utf8,
                    true,
                ),
                arrow::datatypes::Field::new(
                    "adjustmentitem",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "amount",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "value",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lastchanged",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "financialcode",
                    arrow::datatypes::DataType::Decimal128(10, 0),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "bas_class",
                    arrow::datatypes::DataType::Utf8,
                    true,
                ),
            ]),
        )
    }
    fn new_builder() -> Self::Builder {
        BillingFinancialadjustments5Builder {
            contractyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            weekno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            billrunno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            participantid_array: arrow::array::builder::StringBuilder::new(),
            participanttype_array: arrow::array::builder::StringBuilder::new(),
            adjustmentitem_array: arrow::array::builder::StringBuilder::new(),
            amount_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            value_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
            financialcode_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(10, 0)),
            bas_class_array: arrow::array::builder::StringBuilder::new(),
        }
    }
    fn append_builder(builder: &mut Self::Builder, row: Self::Row<'_>) {
        builder
            .contractyear_array
            .append_value({
                let mut val = row.contractyear;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .weekno_array
            .append_value({
                let mut val = row.weekno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .billrunno_array
            .append_value({
                let mut val = row.billrunno;
                val.rescale(0);
                val.mantissa()
            });
        builder.participantid_array.append_value(row.participantid());
        builder.participanttype_array.append_option(row.participanttype());
        builder.adjustmentitem_array.append_value(row.adjustmentitem());
        builder
            .amount_array
            .append_option({
                row.amount
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .value_array
            .append_option({
                row.value
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .lastchanged_array
            .append_option(row.lastchanged.map(|val| val.and_utc().timestamp_millis()));
        builder
            .financialcode_array
            .append_option({
                row.financialcode
                    .map(|mut val| {
                        val.rescale(0);
                        val.mantissa()
                    })
            });
        builder.bas_class_array.append_option(row.bas_class());
    }
    fn finalize_builder(
        builder: &mut Self::Builder,
    ) -> mmsdm_core::Result<arrow::array::RecordBatch> {
        arrow::array::RecordBatch::try_new(
                alloc::sync::Arc::new(<Self as mmsdm_core::ArrowSchema>::schema()),
                alloc::vec::Vec::from([
                    alloc::sync::Arc::new(builder.contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.participantid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.participanttype_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.adjustmentitem_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.amount_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.value_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lastchanged_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.financialcode_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.bas_class_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                ]),
            )
            .map_err(Into::into)
    }
}
#[cfg(feature = "arrow")]
pub struct BillingFinancialadjustments5Builder {
    contractyear_array: arrow::array::builder::Decimal128Builder,
    weekno_array: arrow::array::builder::Decimal128Builder,
    billrunno_array: arrow::array::builder::Decimal128Builder,
    participantid_array: arrow::array::builder::StringBuilder,
    participanttype_array: arrow::array::builder::StringBuilder,
    adjustmentitem_array: arrow::array::builder::StringBuilder,
    amount_array: arrow::array::builder::Decimal128Builder,
    value_array: arrow::array::builder::Decimal128Builder,
    lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder,
    financialcode_array: arrow::array::builder::Decimal128Builder,
    bas_class_array: arrow::array::builder::StringBuilder,
}
pub struct BillingGendata5 {
    extract_row_partition: alloc::boxed::Box<
        dyn Fn(
            &BillingGendata5Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    >,
    row_partition_key: mmsdm_core::PartitionKey,
}
impl BillingGendata5 {
    pub fn new(
        row_partition_key: mmsdm_core::PartitionKey,
        func: impl Fn(
            &<Self as mmsdm_core::GetTable>::Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    ) -> Self {
        Self {
            extract_row_partition: alloc::boxed::Box::new(func),
            row_partition_key,
        }
    }
}
pub struct BillingGendata5Mapping([usize; 13]);
/// # Summary
///
/// ## BILLINGGENDATA
///  _BILLINGGENDATA shows the total energy sold and purchased per participant transmission connection point for a billing period._
///
/// * Data Set Name: Billing
/// * File Name: Gendata
/// * Data Version: 5
///
/// # Description
///  BILLINGGENDATA data is confidential to the the relevant participant. Source BILLINGGENDATA is populated by the posting of a billing run, being several times each week. Volume The number of records depends on the number of transmission ConnectionPointIDs a Participant may have sold energy from per billrunno.  An indicative maximum is approximately 15 records inserted per billrunno, or about 165 records inserted per week. BILLINGGENDATA is confidential to the the relevant participant.
///
///
///
/// # Primary Key Columns
///
/// * BILLRUNNO
/// * CONNECTIONPOINTID
/// * CONTRACTYEAR
/// * PARTICIPANTID
/// * WEEKNO
#[derive(Debug, PartialEq, Eq)]
pub struct BillingGendata5Row<'data> {
    /// AEMO Contract Year number starting in week containing 1st January
    pub contractyear: rust_decimal::Decimal,
    /// Week no within the contract year. Week no 1 is the week containing 1st January
    pub weekno: rust_decimal::Decimal,
    /// Unique run no within a given contract year and week no
    pub billrunno: rust_decimal::Decimal,
    /// Unique participant identifier
    pub participantid: core::ops::Range<usize>,
    /// Connection point identifier
    pub connectionpointid: core::ops::Range<usize>,
    /// not populated
    pub stationid: core::ops::Range<usize>,
    /// not populated
    pub duid: core::ops::Range<usize>,
    /// Aggregate energy sold, in MWh
    pub aggregateenergy: Option<rust_decimal::Decimal>,
    /// $ income
    pub sales: Option<rust_decimal::Decimal>,
    /// $ outgoing
    pub purchases: Option<rust_decimal::Decimal>,
    /// Last date and time record changed
    pub lastchanged: Option<chrono::NaiveDateTime>,
    /// Amount of energy purchased in MWh
    pub purchasedenergy: Option<rust_decimal::Decimal>,
    /// Metering Data Agent supplying data
    pub mda: core::ops::Range<usize>,
    backing_data: mmsdm_core::CsvRow<'data>,
}
impl<'data> BillingGendata5Row<'data> {
    pub fn participantid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.participantid.clone())
    }
    pub fn connectionpointid(&self) -> &str {
        core::ops::Index::index(
            self.backing_data.as_slice(),
            self.connectionpointid.clone(),
        )
    }
    pub fn stationid(&self) -> Option<&str> {
        if self.stationid.is_empty() {
            None
        } else {
            Some(
                core::ops::Index::index(
                    self.backing_data.as_slice(),
                    self.stationid.clone(),
                ),
            )
        }
    }
    pub fn duid(&self) -> Option<&str> {
        if self.duid.is_empty() {
            None
        } else {
            Some(
                core::ops::Index::index(self.backing_data.as_slice(), self.duid.clone()),
            )
        }
    }
    pub fn mda(&self) -> Option<&str> {
        if self.mda.is_empty() {
            None
        } else {
            Some(core::ops::Index::index(self.backing_data.as_slice(), self.mda.clone()))
        }
    }
}
impl mmsdm_core::GetTable for BillingGendata5 {
    const VERSION: i32 = 5;
    const DATA_SET_NAME: &'static str = "BILLING";
    const TABLE_NAME: &'static str = "GENDATA";
    const DEFAULT_FIELD_MAPPING: Self::FieldMapping = BillingGendata5Mapping([
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
    ]);
    const COLUMNS: &'static [&'static str] = &[
        "CONTRACTYEAR",
        "WEEKNO",
        "BILLRUNNO",
        "PARTICIPANTID",
        "CONNECTIONPOINTID",
        "STATIONID",
        "DUID",
        "AGGREGATEENERGY",
        "SALES",
        "PURCHASES",
        "LASTCHANGED",
        "PURCHASEDENERGY",
        "MDA",
    ];
    type Row<'row> = BillingGendata5Row<'row>;
    type FieldMapping = BillingGendata5Mapping;
    type PrimaryKey = BillingGendata5PrimaryKey;
    fn from_row<'data>(
        row: mmsdm_core::CsvRow<'data>,
        field_mapping: &Self::FieldMapping,
    ) -> mmsdm_core::Result<Self::Row<'data>> {
        Ok(BillingGendata5Row {
            contractyear: row
                .get_custom_parsed_at_idx(
                    "contractyear",
                    field_mapping.0[0],
                    mmsdm_core::mms_decimal::parse,
                )?,
            weekno: row
                .get_custom_parsed_at_idx(
                    "weekno",
                    field_mapping.0[1],
                    mmsdm_core::mms_decimal::parse,
                )?,
            billrunno: row
                .get_custom_parsed_at_idx(
                    "billrunno",
                    field_mapping.0[2],
                    mmsdm_core::mms_decimal::parse,
                )?,
            participantid: row.get_range("participantid", field_mapping.0[3])?,
            connectionpointid: row.get_range("connectionpointid", field_mapping.0[4])?,
            stationid: row.get_opt_range("stationid", field_mapping.0[5])?,
            duid: row.get_opt_range("duid", field_mapping.0[6])?,
            aggregateenergy: row
                .get_opt_custom_parsed_at_idx(
                    "aggregateenergy",
                    field_mapping.0[7],
                    mmsdm_core::mms_decimal::parse,
                )?,
            sales: row
                .get_opt_custom_parsed_at_idx(
                    "sales",
                    field_mapping.0[8],
                    mmsdm_core::mms_decimal::parse,
                )?,
            purchases: row
                .get_opt_custom_parsed_at_idx(
                    "purchases",
                    field_mapping.0[9],
                    mmsdm_core::mms_decimal::parse,
                )?,
            lastchanged: row
                .get_opt_custom_parsed_at_idx(
                    "lastchanged",
                    field_mapping.0[10],
                    mmsdm_core::mms_datetime::parse,
                )?,
            purchasedenergy: row
                .get_opt_custom_parsed_at_idx(
                    "purchasedenergy",
                    field_mapping.0[11],
                    mmsdm_core::mms_decimal::parse,
                )?,
            mda: row.get_opt_range("mda", field_mapping.0[12])?,
            backing_data: row,
        })
    }
    fn field_mapping_from_row<'a>(
        mut row: mmsdm_core::CsvRow<'a>,
    ) -> mmsdm_core::Result<Self::FieldMapping> {
        if !row.is_heading() {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!("Expected an I row but got {row:?}"),
                ),
            );
        }
        let row_key = mmsdm_core::FileKey::from_row(row.borrow())?;
        if !Self::matches_file_key(&row_key, row_key.version) {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!(
                        "Expected a row matching {}.{}.v{} but got {row_key}",
                        Self::DATA_SET_NAME, Self::TABLE_NAME, Self::VERSION
                    ),
                ),
            );
        }
        let mut base_mapping = Self::DEFAULT_FIELD_MAPPING.0;
        for (field_index, field) in Self::COLUMNS.iter().enumerate() {
            base_mapping[field_index] = row
                .iter_fields()
                .position(|f| f == *field)
                .unwrap_or(usize::MAX);
        }
        Ok(BillingGendata5Mapping(base_mapping))
    }
    fn matches_file_key(key: &mmsdm_core::FileKey<'_>, version: i32) -> bool {
        version == key.version && Self::DATA_SET_NAME == key.data_set_name()
            && Self::TABLE_NAME == key.table_name()
    }
    fn primary_key(row: &Self::Row<'_>) -> BillingGendata5PrimaryKey {
        BillingGendata5PrimaryKey {
            billrunno: row.billrunno,
            connectionpointid: row.connectionpointid().to_string(),
            contractyear: row.contractyear,
            participantid: row.participantid().to_string(),
            weekno: row.weekno,
        }
    }
    fn partition_value(&self, row: &Self::Row<'_>) -> mmsdm_core::PartitionValue {
        (self.extract_row_partition)(row)
    }
    fn partition_name(&self, row: &Self::Row<'_>) -> alloc::string::String {
        alloc::format!("billing_gendata_v5_{}", self.partition_value(row))
    }
    fn partition_key(&self) -> mmsdm_core::PartitionKey {
        self.row_partition_key
    }
    fn to_static<'a>(row: &Self::Row<'a>) -> Self::Row<'static> {
        BillingGendata5Row {
            contractyear: row.contractyear.clone(),
            weekno: row.weekno.clone(),
            billrunno: row.billrunno.clone(),
            participantid: row.participantid.clone(),
            connectionpointid: row.connectionpointid.clone(),
            stationid: row.stationid.clone(),
            duid: row.duid.clone(),
            aggregateenergy: row.aggregateenergy.clone(),
            sales: row.sales.clone(),
            purchases: row.purchases.clone(),
            lastchanged: row.lastchanged.clone(),
            purchasedenergy: row.purchasedenergy.clone(),
            mda: row.mda.clone(),
            backing_data: row.backing_data.to_owned(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct BillingGendata5PrimaryKey {
    pub billrunno: rust_decimal::Decimal,
    pub connectionpointid: alloc::string::String,
    pub contractyear: rust_decimal::Decimal,
    pub participantid: alloc::string::String,
    pub weekno: rust_decimal::Decimal,
}
impl mmsdm_core::PrimaryKey for BillingGendata5PrimaryKey {}
impl<'data> mmsdm_core::CompareWithRow for BillingGendata5Row<'data> {
    type Row<'other> = BillingGendata5Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno
            && self.connectionpointid() == row.connectionpointid()
            && self.contractyear == row.contractyear
            && self.participantid() == row.participantid() && self.weekno == row.weekno
    }
}
impl<'data> mmsdm_core::CompareWithPrimaryKey for BillingGendata5Row<'data> {
    type PrimaryKey = BillingGendata5PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno
            && self.connectionpointid() == key.connectionpointid
            && self.contractyear == key.contractyear
            && self.participantid() == key.participantid && self.weekno == key.weekno
    }
}
impl<'data> mmsdm_core::CompareWithRow for BillingGendata5PrimaryKey {
    type Row<'other> = BillingGendata5Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno
            && self.connectionpointid == row.connectionpointid()
            && self.contractyear == row.contractyear
            && self.participantid == row.participantid() && self.weekno == row.weekno
    }
}
impl mmsdm_core::CompareWithPrimaryKey for BillingGendata5PrimaryKey {
    type PrimaryKey = BillingGendata5PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno
            && self.connectionpointid == key.connectionpointid
            && self.contractyear == key.contractyear
            && self.participantid == key.participantid && self.weekno == key.weekno
    }
}
#[cfg(feature = "arrow")]
impl mmsdm_core::ArrowSchema for BillingGendata5 {
    type Builder = BillingGendata5Builder;
    fn schema() -> arrow::datatypes::Schema {
        arrow::datatypes::Schema::new(
            alloc::vec::Vec::from([
                arrow::datatypes::Field::new(
                    "contractyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "weekno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "billrunno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "participantid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "connectionpointid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "stationid",
                    arrow::datatypes::DataType::Utf8,
                    true,
                ),
                arrow::datatypes::Field::new(
                    "duid",
                    arrow::datatypes::DataType::Utf8,
                    true,
                ),
                arrow::datatypes::Field::new(
                    "aggregateenergy",
                    arrow::datatypes::DataType::Decimal128(16, 6),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "sales",
                    arrow::datatypes::DataType::Decimal128(16, 6),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "purchases",
                    arrow::datatypes::DataType::Decimal128(16, 6),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lastchanged",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "purchasedenergy",
                    arrow::datatypes::DataType::Decimal128(16, 6),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "mda",
                    arrow::datatypes::DataType::Utf8,
                    true,
                ),
            ]),
        )
    }
    fn new_builder() -> Self::Builder {
        BillingGendata5Builder {
            contractyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            weekno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            billrunno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            participantid_array: arrow::array::builder::StringBuilder::new(),
            connectionpointid_array: arrow::array::builder::StringBuilder::new(),
            stationid_array: arrow::array::builder::StringBuilder::new(),
            duid_array: arrow::array::builder::StringBuilder::new(),
            aggregateenergy_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(16, 6)),
            sales_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(16, 6)),
            purchases_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(16, 6)),
            lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
            purchasedenergy_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(16, 6)),
            mda_array: arrow::array::builder::StringBuilder::new(),
        }
    }
    fn append_builder(builder: &mut Self::Builder, row: Self::Row<'_>) {
        builder
            .contractyear_array
            .append_value({
                let mut val = row.contractyear;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .weekno_array
            .append_value({
                let mut val = row.weekno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .billrunno_array
            .append_value({
                let mut val = row.billrunno;
                val.rescale(0);
                val.mantissa()
            });
        builder.participantid_array.append_value(row.participantid());
        builder.connectionpointid_array.append_value(row.connectionpointid());
        builder.stationid_array.append_option(row.stationid());
        builder.duid_array.append_option(row.duid());
        builder
            .aggregateenergy_array
            .append_option({
                row.aggregateenergy
                    .map(|mut val| {
                        val.rescale(6);
                        val.mantissa()
                    })
            });
        builder
            .sales_array
            .append_option({
                row.sales
                    .map(|mut val| {
                        val.rescale(6);
                        val.mantissa()
                    })
            });
        builder
            .purchases_array
            .append_option({
                row.purchases
                    .map(|mut val| {
                        val.rescale(6);
                        val.mantissa()
                    })
            });
        builder
            .lastchanged_array
            .append_option(row.lastchanged.map(|val| val.and_utc().timestamp_millis()));
        builder
            .purchasedenergy_array
            .append_option({
                row.purchasedenergy
                    .map(|mut val| {
                        val.rescale(6);
                        val.mantissa()
                    })
            });
        builder.mda_array.append_option(row.mda());
    }
    fn finalize_builder(
        builder: &mut Self::Builder,
    ) -> mmsdm_core::Result<arrow::array::RecordBatch> {
        arrow::array::RecordBatch::try_new(
                alloc::sync::Arc::new(<Self as mmsdm_core::ArrowSchema>::schema()),
                alloc::vec::Vec::from([
                    alloc::sync::Arc::new(builder.contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.participantid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.connectionpointid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.stationid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.duid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.aggregateenergy_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.sales_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.purchases_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lastchanged_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.purchasedenergy_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.mda_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                ]),
            )
            .map_err(Into::into)
    }
}
#[cfg(feature = "arrow")]
pub struct BillingGendata5Builder {
    contractyear_array: arrow::array::builder::Decimal128Builder,
    weekno_array: arrow::array::builder::Decimal128Builder,
    billrunno_array: arrow::array::builder::Decimal128Builder,
    participantid_array: arrow::array::builder::StringBuilder,
    connectionpointid_array: arrow::array::builder::StringBuilder,
    stationid_array: arrow::array::builder::StringBuilder,
    duid_array: arrow::array::builder::StringBuilder,
    aggregateenergy_array: arrow::array::builder::Decimal128Builder,
    sales_array: arrow::array::builder::Decimal128Builder,
    purchases_array: arrow::array::builder::Decimal128Builder,
    lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder,
    purchasedenergy_array: arrow::array::builder::Decimal128Builder,
    mda_array: arrow::array::builder::StringBuilder,
}
pub struct BillingInterresidues5 {
    extract_row_partition: alloc::boxed::Box<
        dyn Fn(
            &BillingInterresidues5Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    >,
    row_partition_key: mmsdm_core::PartitionKey,
}
impl BillingInterresidues5 {
    pub fn new(
        row_partition_key: mmsdm_core::PartitionKey,
        func: impl Fn(
            &<Self as mmsdm_core::GetTable>::Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    ) -> Self {
        Self {
            extract_row_partition: alloc::boxed::Box::new(func),
            row_partition_key,
        }
    }
}
pub struct BillingInterresidues5Mapping([usize; 10]);
/// # Summary
///
/// ## BILLINGINTERRESIDUES
///  _BILLINGINTERRESIDUES shows interregion residues payable to NSP._
///
/// * Data Set Name: Billing
/// * File Name: Interresidues
/// * Data Version: 5
///
/// # Description
///  Source Obsolete, was weekly with billing run.
///
///
///
/// # Primary Key Columns
///
/// * BILLRUNNO
/// * CONTRACTYEAR
/// * INTERCONNECTORID
/// * PARTICIPANTID
/// * REGIONID
/// * WEEKNO
#[derive(Debug, PartialEq, Eq)]
pub struct BillingInterresidues5Row<'data> {
    /// May not be necessary
    pub allocation: Option<rust_decimal::Decimal>,
    /// May not be necessary
    pub totalsurplus: Option<rust_decimal::Decimal>,
    /// Unique identifier for an interconnector which joins two regions.
    pub interconnectorid: core::ops::Range<usize>,
    /// AEMO Contract Year number starting in week containing 1st January
    pub contractyear: rust_decimal::Decimal,
    /// Week no within the contract year. Week no 1 is the week containing 1st January
    pub weekno: rust_decimal::Decimal,
    /// Unique run no within a given contract year and week no
    pub billrunno: rust_decimal::Decimal,
    /// Unique participant identifier
    pub participantid: core::ops::Range<usize>,
    /// Amount NSP is paid for Inter-Regional Residues
    pub surplusvalue: Option<rust_decimal::Decimal>,
    /// Last date and time record changed
    pub lastchanged: Option<chrono::NaiveDateTime>,
    /// Region ID
    pub regionid: core::ops::Range<usize>,
    backing_data: mmsdm_core::CsvRow<'data>,
}
impl<'data> BillingInterresidues5Row<'data> {
    pub fn interconnectorid(&self) -> &str {
        core::ops::Index::index(
            self.backing_data.as_slice(),
            self.interconnectorid.clone(),
        )
    }
    pub fn participantid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.participantid.clone())
    }
    pub fn regionid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.regionid.clone())
    }
}
impl mmsdm_core::GetTable for BillingInterresidues5 {
    const VERSION: i32 = 5;
    const DATA_SET_NAME: &'static str = "BILLING";
    const TABLE_NAME: &'static str = "INTERRESIDUES";
    const DEFAULT_FIELD_MAPPING: Self::FieldMapping = BillingInterresidues5Mapping([
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
    ]);
    const COLUMNS: &'static [&'static str] = &[
        "ALLOCATION",
        "TOTALSURPLUS",
        "INTERCONNECTORID",
        "CONTRACTYEAR",
        "WEEKNO",
        "BILLRUNNO",
        "PARTICIPANTID",
        "SURPLUSVALUE",
        "LASTCHANGED",
        "REGIONID",
    ];
    type Row<'row> = BillingInterresidues5Row<'row>;
    type FieldMapping = BillingInterresidues5Mapping;
    type PrimaryKey = BillingInterresidues5PrimaryKey;
    fn from_row<'data>(
        row: mmsdm_core::CsvRow<'data>,
        field_mapping: &Self::FieldMapping,
    ) -> mmsdm_core::Result<Self::Row<'data>> {
        Ok(BillingInterresidues5Row {
            allocation: row
                .get_opt_custom_parsed_at_idx(
                    "allocation",
                    field_mapping.0[0],
                    mmsdm_core::mms_decimal::parse,
                )?,
            totalsurplus: row
                .get_opt_custom_parsed_at_idx(
                    "totalsurplus",
                    field_mapping.0[1],
                    mmsdm_core::mms_decimal::parse,
                )?,
            interconnectorid: row.get_range("interconnectorid", field_mapping.0[2])?,
            contractyear: row
                .get_custom_parsed_at_idx(
                    "contractyear",
                    field_mapping.0[3],
                    mmsdm_core::mms_decimal::parse,
                )?,
            weekno: row
                .get_custom_parsed_at_idx(
                    "weekno",
                    field_mapping.0[4],
                    mmsdm_core::mms_decimal::parse,
                )?,
            billrunno: row
                .get_custom_parsed_at_idx(
                    "billrunno",
                    field_mapping.0[5],
                    mmsdm_core::mms_decimal::parse,
                )?,
            participantid: row.get_range("participantid", field_mapping.0[6])?,
            surplusvalue: row
                .get_opt_custom_parsed_at_idx(
                    "surplusvalue",
                    field_mapping.0[7],
                    mmsdm_core::mms_decimal::parse,
                )?,
            lastchanged: row
                .get_opt_custom_parsed_at_idx(
                    "lastchanged",
                    field_mapping.0[8],
                    mmsdm_core::mms_datetime::parse,
                )?,
            regionid: row.get_range("regionid", field_mapping.0[9])?,
            backing_data: row,
        })
    }
    fn field_mapping_from_row<'a>(
        mut row: mmsdm_core::CsvRow<'a>,
    ) -> mmsdm_core::Result<Self::FieldMapping> {
        if !row.is_heading() {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!("Expected an I row but got {row:?}"),
                ),
            );
        }
        let row_key = mmsdm_core::FileKey::from_row(row.borrow())?;
        if !Self::matches_file_key(&row_key, row_key.version) {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!(
                        "Expected a row matching {}.{}.v{} but got {row_key}",
                        Self::DATA_SET_NAME, Self::TABLE_NAME, Self::VERSION
                    ),
                ),
            );
        }
        let mut base_mapping = Self::DEFAULT_FIELD_MAPPING.0;
        for (field_index, field) in Self::COLUMNS.iter().enumerate() {
            base_mapping[field_index] = row
                .iter_fields()
                .position(|f| f == *field)
                .unwrap_or(usize::MAX);
        }
        Ok(BillingInterresidues5Mapping(base_mapping))
    }
    fn matches_file_key(key: &mmsdm_core::FileKey<'_>, version: i32) -> bool {
        version == key.version && Self::DATA_SET_NAME == key.data_set_name()
            && Self::TABLE_NAME == key.table_name()
    }
    fn primary_key(row: &Self::Row<'_>) -> BillingInterresidues5PrimaryKey {
        BillingInterresidues5PrimaryKey {
            billrunno: row.billrunno,
            contractyear: row.contractyear,
            interconnectorid: row.interconnectorid().to_string(),
            participantid: row.participantid().to_string(),
            regionid: row.regionid().to_string(),
            weekno: row.weekno,
        }
    }
    fn partition_value(&self, row: &Self::Row<'_>) -> mmsdm_core::PartitionValue {
        (self.extract_row_partition)(row)
    }
    fn partition_name(&self, row: &Self::Row<'_>) -> alloc::string::String {
        alloc::format!("billing_interresidues_v5_{}", self.partition_value(row))
    }
    fn partition_key(&self) -> mmsdm_core::PartitionKey {
        self.row_partition_key
    }
    fn to_static<'a>(row: &Self::Row<'a>) -> Self::Row<'static> {
        BillingInterresidues5Row {
            allocation: row.allocation.clone(),
            totalsurplus: row.totalsurplus.clone(),
            interconnectorid: row.interconnectorid.clone(),
            contractyear: row.contractyear.clone(),
            weekno: row.weekno.clone(),
            billrunno: row.billrunno.clone(),
            participantid: row.participantid.clone(),
            surplusvalue: row.surplusvalue.clone(),
            lastchanged: row.lastchanged.clone(),
            regionid: row.regionid.clone(),
            backing_data: row.backing_data.to_owned(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct BillingInterresidues5PrimaryKey {
    pub billrunno: rust_decimal::Decimal,
    pub contractyear: rust_decimal::Decimal,
    pub interconnectorid: alloc::string::String,
    pub participantid: alloc::string::String,
    pub regionid: alloc::string::String,
    pub weekno: rust_decimal::Decimal,
}
impl mmsdm_core::PrimaryKey for BillingInterresidues5PrimaryKey {}
impl<'data> mmsdm_core::CompareWithRow for BillingInterresidues5Row<'data> {
    type Row<'other> = BillingInterresidues5Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.interconnectorid() == row.interconnectorid()
            && self.participantid() == row.participantid()
            && self.regionid() == row.regionid() && self.weekno == row.weekno
    }
}
impl<'data> mmsdm_core::CompareWithPrimaryKey for BillingInterresidues5Row<'data> {
    type PrimaryKey = BillingInterresidues5PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.interconnectorid() == key.interconnectorid
            && self.participantid() == key.participantid
            && self.regionid() == key.regionid && self.weekno == key.weekno
    }
}
impl<'data> mmsdm_core::CompareWithRow for BillingInterresidues5PrimaryKey {
    type Row<'other> = BillingInterresidues5Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.interconnectorid == row.interconnectorid()
            && self.participantid == row.participantid()
            && self.regionid == row.regionid() && self.weekno == row.weekno
    }
}
impl mmsdm_core::CompareWithPrimaryKey for BillingInterresidues5PrimaryKey {
    type PrimaryKey = BillingInterresidues5PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.interconnectorid == key.interconnectorid
            && self.participantid == key.participantid && self.regionid == key.regionid
            && self.weekno == key.weekno
    }
}
#[cfg(feature = "arrow")]
impl mmsdm_core::ArrowSchema for BillingInterresidues5 {
    type Builder = BillingInterresidues5Builder;
    fn schema() -> arrow::datatypes::Schema {
        arrow::datatypes::Schema::new(
            alloc::vec::Vec::from([
                arrow::datatypes::Field::new(
                    "allocation",
                    arrow::datatypes::DataType::Decimal128(6, 3),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "totalsurplus",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "interconnectorid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "contractyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "weekno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "billrunno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "participantid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "surplusvalue",
                    arrow::datatypes::DataType::Decimal128(15, 6),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lastchanged",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "regionid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
            ]),
        )
    }
    fn new_builder() -> Self::Builder {
        BillingInterresidues5Builder {
            allocation_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(6, 3)),
            totalsurplus_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            interconnectorid_array: arrow::array::builder::StringBuilder::new(),
            contractyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            weekno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            billrunno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            participantid_array: arrow::array::builder::StringBuilder::new(),
            surplusvalue_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 6)),
            lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
            regionid_array: arrow::array::builder::StringBuilder::new(),
        }
    }
    fn append_builder(builder: &mut Self::Builder, row: Self::Row<'_>) {
        builder
            .allocation_array
            .append_option({
                row.allocation
                    .map(|mut val| {
                        val.rescale(3);
                        val.mantissa()
                    })
            });
        builder
            .totalsurplus_array
            .append_option({
                row.totalsurplus
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder.interconnectorid_array.append_value(row.interconnectorid());
        builder
            .contractyear_array
            .append_value({
                let mut val = row.contractyear;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .weekno_array
            .append_value({
                let mut val = row.weekno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .billrunno_array
            .append_value({
                let mut val = row.billrunno;
                val.rescale(0);
                val.mantissa()
            });
        builder.participantid_array.append_value(row.participantid());
        builder
            .surplusvalue_array
            .append_option({
                row.surplusvalue
                    .map(|mut val| {
                        val.rescale(6);
                        val.mantissa()
                    })
            });
        builder
            .lastchanged_array
            .append_option(row.lastchanged.map(|val| val.and_utc().timestamp_millis()));
        builder.regionid_array.append_value(row.regionid());
    }
    fn finalize_builder(
        builder: &mut Self::Builder,
    ) -> mmsdm_core::Result<arrow::array::RecordBatch> {
        arrow::array::RecordBatch::try_new(
                alloc::sync::Arc::new(<Self as mmsdm_core::ArrowSchema>::schema()),
                alloc::vec::Vec::from([
                    alloc::sync::Arc::new(builder.allocation_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.totalsurplus_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.interconnectorid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.participantid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.surplusvalue_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lastchanged_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.regionid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                ]),
            )
            .map_err(Into::into)
    }
}
#[cfg(feature = "arrow")]
pub struct BillingInterresidues5Builder {
    allocation_array: arrow::array::builder::Decimal128Builder,
    totalsurplus_array: arrow::array::builder::Decimal128Builder,
    interconnectorid_array: arrow::array::builder::StringBuilder,
    contractyear_array: arrow::array::builder::Decimal128Builder,
    weekno_array: arrow::array::builder::Decimal128Builder,
    billrunno_array: arrow::array::builder::Decimal128Builder,
    participantid_array: arrow::array::builder::StringBuilder,
    surplusvalue_array: arrow::array::builder::Decimal128Builder,
    lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder,
    regionid_array: arrow::array::builder::StringBuilder,
}
pub struct BillingIntraresidues5 {
    extract_row_partition: alloc::boxed::Box<
        dyn Fn(
            &BillingIntraresidues5Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    >,
    row_partition_key: mmsdm_core::PartitionKey,
}
impl BillingIntraresidues5 {
    pub fn new(
        row_partition_key: mmsdm_core::PartitionKey,
        func: impl Fn(
            &<Self as mmsdm_core::GetTable>::Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    ) -> Self {
        Self {
            extract_row_partition: alloc::boxed::Box::new(func),
            row_partition_key,
        }
    }
}
pub struct BillingIntraresidues5Mapping([usize; 9]);
/// # Summary
///
/// ## BILLINGINTRARESIDUES
///  _BILLINGINTRARESIDUES shows intra-region settlement residue details for each Transmission Network Service Provider participant by region._
///
/// * Data Set Name: Billing
/// * File Name: Intraresidues
/// * Data Version: 5
///
/// # Description
///  BILLINGINTRARESIDUES is confidential to the relevant participant. Source BILLINGINTRARESIDUES is populated by the posting of a billing run, being several times each week. Volume An indicative maximum is two records inserted per billing run, or 22 records inserted per week.
///
///
///
/// # Primary Key Columns
///
/// * BILLRUNNO
/// * CONTRACTYEAR
/// * PARTICIPANTID
/// * REGIONID
/// * WEEKNO
#[derive(Debug, PartialEq, Eq)]
pub struct BillingIntraresidues5Row<'data> {
    /// TNSP allocation
    pub allocation: Option<rust_decimal::Decimal>,
    /// Total $ residue amount for the region
    pub totalsurplus: Option<rust_decimal::Decimal>,
    /// AEMO Contract Year number starting in week containing 1st January
    pub contractyear: rust_decimal::Decimal,
    /// Week no within the contract year. Week no 1 is the week containing 1st January
    pub weekno: rust_decimal::Decimal,
    /// Unique run no within a given contract year and week no
    pub billrunno: rust_decimal::Decimal,
    /// Unique participant identifier
    pub participantid: core::ops::Range<usize>,
    /// Amount TNSP is paid for Intra-Regional Residues
    pub surplusvalue: Option<rust_decimal::Decimal>,
    /// Last changed date
    pub lastchanged: Option<chrono::NaiveDateTime>,
    /// Region ID
    pub regionid: core::ops::Range<usize>,
    backing_data: mmsdm_core::CsvRow<'data>,
}
impl<'data> BillingIntraresidues5Row<'data> {
    pub fn participantid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.participantid.clone())
    }
    pub fn regionid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.regionid.clone())
    }
}
impl mmsdm_core::GetTable for BillingIntraresidues5 {
    const VERSION: i32 = 5;
    const DATA_SET_NAME: &'static str = "BILLING";
    const TABLE_NAME: &'static str = "INTRARESIDUES";
    const DEFAULT_FIELD_MAPPING: Self::FieldMapping = BillingIntraresidues5Mapping([
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
    ]);
    const COLUMNS: &'static [&'static str] = &[
        "ALLOCATION",
        "TOTALSURPLUS",
        "CONTRACTYEAR",
        "WEEKNO",
        "BILLRUNNO",
        "PARTICIPANTID",
        "SURPLUSVALUE",
        "LASTCHANGED",
        "REGIONID",
    ];
    type Row<'row> = BillingIntraresidues5Row<'row>;
    type FieldMapping = BillingIntraresidues5Mapping;
    type PrimaryKey = BillingIntraresidues5PrimaryKey;
    fn from_row<'data>(
        row: mmsdm_core::CsvRow<'data>,
        field_mapping: &Self::FieldMapping,
    ) -> mmsdm_core::Result<Self::Row<'data>> {
        Ok(BillingIntraresidues5Row {
            allocation: row
                .get_opt_custom_parsed_at_idx(
                    "allocation",
                    field_mapping.0[0],
                    mmsdm_core::mms_decimal::parse,
                )?,
            totalsurplus: row
                .get_opt_custom_parsed_at_idx(
                    "totalsurplus",
                    field_mapping.0[1],
                    mmsdm_core::mms_decimal::parse,
                )?,
            contractyear: row
                .get_custom_parsed_at_idx(
                    "contractyear",
                    field_mapping.0[2],
                    mmsdm_core::mms_decimal::parse,
                )?,
            weekno: row
                .get_custom_parsed_at_idx(
                    "weekno",
                    field_mapping.0[3],
                    mmsdm_core::mms_decimal::parse,
                )?,
            billrunno: row
                .get_custom_parsed_at_idx(
                    "billrunno",
                    field_mapping.0[4],
                    mmsdm_core::mms_decimal::parse,
                )?,
            participantid: row.get_range("participantid", field_mapping.0[5])?,
            surplusvalue: row
                .get_opt_custom_parsed_at_idx(
                    "surplusvalue",
                    field_mapping.0[6],
                    mmsdm_core::mms_decimal::parse,
                )?,
            lastchanged: row
                .get_opt_custom_parsed_at_idx(
                    "lastchanged",
                    field_mapping.0[7],
                    mmsdm_core::mms_datetime::parse,
                )?,
            regionid: row.get_range("regionid", field_mapping.0[8])?,
            backing_data: row,
        })
    }
    fn field_mapping_from_row<'a>(
        mut row: mmsdm_core::CsvRow<'a>,
    ) -> mmsdm_core::Result<Self::FieldMapping> {
        if !row.is_heading() {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!("Expected an I row but got {row:?}"),
                ),
            );
        }
        let row_key = mmsdm_core::FileKey::from_row(row.borrow())?;
        if !Self::matches_file_key(&row_key, row_key.version) {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!(
                        "Expected a row matching {}.{}.v{} but got {row_key}",
                        Self::DATA_SET_NAME, Self::TABLE_NAME, Self::VERSION
                    ),
                ),
            );
        }
        let mut base_mapping = Self::DEFAULT_FIELD_MAPPING.0;
        for (field_index, field) in Self::COLUMNS.iter().enumerate() {
            base_mapping[field_index] = row
                .iter_fields()
                .position(|f| f == *field)
                .unwrap_or(usize::MAX);
        }
        Ok(BillingIntraresidues5Mapping(base_mapping))
    }
    fn matches_file_key(key: &mmsdm_core::FileKey<'_>, version: i32) -> bool {
        version == key.version && Self::DATA_SET_NAME == key.data_set_name()
            && Self::TABLE_NAME == key.table_name()
    }
    fn primary_key(row: &Self::Row<'_>) -> BillingIntraresidues5PrimaryKey {
        BillingIntraresidues5PrimaryKey {
            billrunno: row.billrunno,
            contractyear: row.contractyear,
            participantid: row.participantid().to_string(),
            regionid: row.regionid().to_string(),
            weekno: row.weekno,
        }
    }
    fn partition_value(&self, row: &Self::Row<'_>) -> mmsdm_core::PartitionValue {
        (self.extract_row_partition)(row)
    }
    fn partition_name(&self, row: &Self::Row<'_>) -> alloc::string::String {
        alloc::format!("billing_intraresidues_v5_{}", self.partition_value(row))
    }
    fn partition_key(&self) -> mmsdm_core::PartitionKey {
        self.row_partition_key
    }
    fn to_static<'a>(row: &Self::Row<'a>) -> Self::Row<'static> {
        BillingIntraresidues5Row {
            allocation: row.allocation.clone(),
            totalsurplus: row.totalsurplus.clone(),
            contractyear: row.contractyear.clone(),
            weekno: row.weekno.clone(),
            billrunno: row.billrunno.clone(),
            participantid: row.participantid.clone(),
            surplusvalue: row.surplusvalue.clone(),
            lastchanged: row.lastchanged.clone(),
            regionid: row.regionid.clone(),
            backing_data: row.backing_data.to_owned(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct BillingIntraresidues5PrimaryKey {
    pub billrunno: rust_decimal::Decimal,
    pub contractyear: rust_decimal::Decimal,
    pub participantid: alloc::string::String,
    pub regionid: alloc::string::String,
    pub weekno: rust_decimal::Decimal,
}
impl mmsdm_core::PrimaryKey for BillingIntraresidues5PrimaryKey {}
impl<'data> mmsdm_core::CompareWithRow for BillingIntraresidues5Row<'data> {
    type Row<'other> = BillingIntraresidues5Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.participantid() == row.participantid()
            && self.regionid() == row.regionid() && self.weekno == row.weekno
    }
}
impl<'data> mmsdm_core::CompareWithPrimaryKey for BillingIntraresidues5Row<'data> {
    type PrimaryKey = BillingIntraresidues5PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.participantid() == key.participantid
            && self.regionid() == key.regionid && self.weekno == key.weekno
    }
}
impl<'data> mmsdm_core::CompareWithRow for BillingIntraresidues5PrimaryKey {
    type Row<'other> = BillingIntraresidues5Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.participantid == row.participantid()
            && self.regionid == row.regionid() && self.weekno == row.weekno
    }
}
impl mmsdm_core::CompareWithPrimaryKey for BillingIntraresidues5PrimaryKey {
    type PrimaryKey = BillingIntraresidues5PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.participantid == key.participantid && self.regionid == key.regionid
            && self.weekno == key.weekno
    }
}
#[cfg(feature = "arrow")]
impl mmsdm_core::ArrowSchema for BillingIntraresidues5 {
    type Builder = BillingIntraresidues5Builder;
    fn schema() -> arrow::datatypes::Schema {
        arrow::datatypes::Schema::new(
            alloc::vec::Vec::from([
                arrow::datatypes::Field::new(
                    "allocation",
                    arrow::datatypes::DataType::Decimal128(6, 3),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "totalsurplus",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "contractyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "weekno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "billrunno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "participantid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "surplusvalue",
                    arrow::datatypes::DataType::Decimal128(15, 6),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lastchanged",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "regionid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
            ]),
        )
    }
    fn new_builder() -> Self::Builder {
        BillingIntraresidues5Builder {
            allocation_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(6, 3)),
            totalsurplus_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            contractyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            weekno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            billrunno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            participantid_array: arrow::array::builder::StringBuilder::new(),
            surplusvalue_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 6)),
            lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
            regionid_array: arrow::array::builder::StringBuilder::new(),
        }
    }
    fn append_builder(builder: &mut Self::Builder, row: Self::Row<'_>) {
        builder
            .allocation_array
            .append_option({
                row.allocation
                    .map(|mut val| {
                        val.rescale(3);
                        val.mantissa()
                    })
            });
        builder
            .totalsurplus_array
            .append_option({
                row.totalsurplus
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .contractyear_array
            .append_value({
                let mut val = row.contractyear;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .weekno_array
            .append_value({
                let mut val = row.weekno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .billrunno_array
            .append_value({
                let mut val = row.billrunno;
                val.rescale(0);
                val.mantissa()
            });
        builder.participantid_array.append_value(row.participantid());
        builder
            .surplusvalue_array
            .append_option({
                row.surplusvalue
                    .map(|mut val| {
                        val.rescale(6);
                        val.mantissa()
                    })
            });
        builder
            .lastchanged_array
            .append_option(row.lastchanged.map(|val| val.and_utc().timestamp_millis()));
        builder.regionid_array.append_value(row.regionid());
    }
    fn finalize_builder(
        builder: &mut Self::Builder,
    ) -> mmsdm_core::Result<arrow::array::RecordBatch> {
        arrow::array::RecordBatch::try_new(
                alloc::sync::Arc::new(<Self as mmsdm_core::ArrowSchema>::schema()),
                alloc::vec::Vec::from([
                    alloc::sync::Arc::new(builder.allocation_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.totalsurplus_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.participantid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.surplusvalue_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lastchanged_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.regionid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                ]),
            )
            .map_err(Into::into)
    }
}
#[cfg(feature = "arrow")]
pub struct BillingIntraresidues5Builder {
    allocation_array: arrow::array::builder::Decimal128Builder,
    totalsurplus_array: arrow::array::builder::Decimal128Builder,
    contractyear_array: arrow::array::builder::Decimal128Builder,
    weekno_array: arrow::array::builder::Decimal128Builder,
    billrunno_array: arrow::array::builder::Decimal128Builder,
    participantid_array: arrow::array::builder::StringBuilder,
    surplusvalue_array: arrow::array::builder::Decimal128Builder,
    lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder,
    regionid_array: arrow::array::builder::StringBuilder,
}
pub struct BillingIraucsurplus5 {
    extract_row_partition: alloc::boxed::Box<
        dyn Fn(
            &BillingIraucsurplus5Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    >,
    row_partition_key: mmsdm_core::PartitionKey,
}
impl BillingIraucsurplus5 {
    pub fn new(
        row_partition_key: mmsdm_core::PartitionKey,
        func: impl Fn(
            &<Self as mmsdm_core::GetTable>::Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    ) -> Self {
        Self {
            extract_row_partition: alloc::boxed::Box::new(func),
            row_partition_key,
        }
    }
}
pub struct BillingIraucsurplus5Mapping([usize; 12]);
/// # Summary
///
/// ## BILLINGIRAUCSURPLUS
///  _BILLINGIRAUCSURPLUS supports the Settlements Residue Auction, by showing the weekly billing Interconnector Residue (IR) payments as calculated for each bill run for Network Service Providers (NSPs) from the amount not auctioned._
///
/// * Data Set Name: Billing
/// * File Name: Iraucsurplus
/// * Data Version: 5
///
/// # Description
///  Source Obsolete Volume This view contains a maximum of 30, 000 records per year.
///
///
///
/// # Primary Key Columns
///
/// * BILLRUNNO
/// * CONTRACTID
/// * CONTRACTYEAR
/// * FROMREGIONID
/// * INTERCONNECTORID
/// * PARTICIPANTID
/// * WEEKNO
#[derive(Debug, PartialEq, Eq)]
pub struct BillingIraucsurplus5Row<'data> {
    /// SRA Contracted Year (calendar year)
    pub contractyear: rust_decimal::Decimal,
    /// Week no within the contract year. Week no 1 is the week containing 1st January
    pub weekno: rust_decimal::Decimal,
    /// Year of the Residue Contract; may differ from the calendar year at week 1.
    pub residueyear: Option<rust_decimal::Decimal>,
    /// Residue Contract Quarter
    pub quarter: Option<rust_decimal::Decimal>,
    /// The sequential number of a billing run
    pub billrunno: rust_decimal::Decimal,
    /// SRA Contract unique identifier
    pub contractid: core::ops::Range<usize>,
    /// Unique participant identifier
    pub participantid: core::ops::Range<usize>,
    /// Contracted Interconnector
    pub interconnectorid: core::ops::Range<usize>,
    /// Nominated source region for Interconnector
    pub fromregionid: core::ops::Range<usize>,
    /// Total residues allocated to participant
    pub totalresidues: Option<rust_decimal::Decimal>,
    /// Adjustment allocated to participant
    pub adjustment: Option<rust_decimal::Decimal>,
    /// Date and time this record was last modified
    pub lastchanged: Option<chrono::NaiveDateTime>,
    backing_data: mmsdm_core::CsvRow<'data>,
}
impl<'data> BillingIraucsurplus5Row<'data> {
    pub fn contractid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.contractid.clone())
    }
    pub fn participantid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.participantid.clone())
    }
    pub fn interconnectorid(&self) -> &str {
        core::ops::Index::index(
            self.backing_data.as_slice(),
            self.interconnectorid.clone(),
        )
    }
    pub fn fromregionid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.fromregionid.clone())
    }
}
impl mmsdm_core::GetTable for BillingIraucsurplus5 {
    const VERSION: i32 = 5;
    const DATA_SET_NAME: &'static str = "BILLING";
    const TABLE_NAME: &'static str = "IRAUCSURPLUS";
    const DEFAULT_FIELD_MAPPING: Self::FieldMapping = BillingIraucsurplus5Mapping([
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
    ]);
    const COLUMNS: &'static [&'static str] = &[
        "CONTRACTYEAR",
        "WEEKNO",
        "RESIDUEYEAR",
        "QUARTER",
        "BILLRUNNO",
        "CONTRACTID",
        "PARTICIPANTID",
        "INTERCONNECTORID",
        "FROMREGIONID",
        "TOTALRESIDUES",
        "ADJUSTMENT",
        "LASTCHANGED",
    ];
    type Row<'row> = BillingIraucsurplus5Row<'row>;
    type FieldMapping = BillingIraucsurplus5Mapping;
    type PrimaryKey = BillingIraucsurplus5PrimaryKey;
    fn from_row<'data>(
        row: mmsdm_core::CsvRow<'data>,
        field_mapping: &Self::FieldMapping,
    ) -> mmsdm_core::Result<Self::Row<'data>> {
        Ok(BillingIraucsurplus5Row {
            contractyear: row
                .get_custom_parsed_at_idx(
                    "contractyear",
                    field_mapping.0[0],
                    mmsdm_core::mms_decimal::parse,
                )?,
            weekno: row
                .get_custom_parsed_at_idx(
                    "weekno",
                    field_mapping.0[1],
                    mmsdm_core::mms_decimal::parse,
                )?,
            residueyear: row
                .get_opt_custom_parsed_at_idx(
                    "residueyear",
                    field_mapping.0[2],
                    mmsdm_core::mms_decimal::parse,
                )?,
            quarter: row
                .get_opt_custom_parsed_at_idx(
                    "quarter",
                    field_mapping.0[3],
                    mmsdm_core::mms_decimal::parse,
                )?,
            billrunno: row
                .get_custom_parsed_at_idx(
                    "billrunno",
                    field_mapping.0[4],
                    mmsdm_core::mms_decimal::parse,
                )?,
            contractid: row.get_range("contractid", field_mapping.0[5])?,
            participantid: row.get_range("participantid", field_mapping.0[6])?,
            interconnectorid: row.get_range("interconnectorid", field_mapping.0[7])?,
            fromregionid: row.get_range("fromregionid", field_mapping.0[8])?,
            totalresidues: row
                .get_opt_custom_parsed_at_idx(
                    "totalresidues",
                    field_mapping.0[9],
                    mmsdm_core::mms_decimal::parse,
                )?,
            adjustment: row
                .get_opt_custom_parsed_at_idx(
                    "adjustment",
                    field_mapping.0[10],
                    mmsdm_core::mms_decimal::parse,
                )?,
            lastchanged: row
                .get_opt_custom_parsed_at_idx(
                    "lastchanged",
                    field_mapping.0[11],
                    mmsdm_core::mms_datetime::parse,
                )?,
            backing_data: row,
        })
    }
    fn field_mapping_from_row<'a>(
        mut row: mmsdm_core::CsvRow<'a>,
    ) -> mmsdm_core::Result<Self::FieldMapping> {
        if !row.is_heading() {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!("Expected an I row but got {row:?}"),
                ),
            );
        }
        let row_key = mmsdm_core::FileKey::from_row(row.borrow())?;
        if !Self::matches_file_key(&row_key, row_key.version) {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!(
                        "Expected a row matching {}.{}.v{} but got {row_key}",
                        Self::DATA_SET_NAME, Self::TABLE_NAME, Self::VERSION
                    ),
                ),
            );
        }
        let mut base_mapping = Self::DEFAULT_FIELD_MAPPING.0;
        for (field_index, field) in Self::COLUMNS.iter().enumerate() {
            base_mapping[field_index] = row
                .iter_fields()
                .position(|f| f == *field)
                .unwrap_or(usize::MAX);
        }
        Ok(BillingIraucsurplus5Mapping(base_mapping))
    }
    fn matches_file_key(key: &mmsdm_core::FileKey<'_>, version: i32) -> bool {
        version == key.version && Self::DATA_SET_NAME == key.data_set_name()
            && Self::TABLE_NAME == key.table_name()
    }
    fn primary_key(row: &Self::Row<'_>) -> BillingIraucsurplus5PrimaryKey {
        BillingIraucsurplus5PrimaryKey {
            billrunno: row.billrunno,
            contractid: row.contractid().to_string(),
            contractyear: row.contractyear,
            fromregionid: row.fromregionid().to_string(),
            interconnectorid: row.interconnectorid().to_string(),
            participantid: row.participantid().to_string(),
            weekno: row.weekno,
        }
    }
    fn partition_value(&self, row: &Self::Row<'_>) -> mmsdm_core::PartitionValue {
        (self.extract_row_partition)(row)
    }
    fn partition_name(&self, row: &Self::Row<'_>) -> alloc::string::String {
        alloc::format!("billing_iraucsurplus_v5_{}", self.partition_value(row))
    }
    fn partition_key(&self) -> mmsdm_core::PartitionKey {
        self.row_partition_key
    }
    fn to_static<'a>(row: &Self::Row<'a>) -> Self::Row<'static> {
        BillingIraucsurplus5Row {
            contractyear: row.contractyear.clone(),
            weekno: row.weekno.clone(),
            residueyear: row.residueyear.clone(),
            quarter: row.quarter.clone(),
            billrunno: row.billrunno.clone(),
            contractid: row.contractid.clone(),
            participantid: row.participantid.clone(),
            interconnectorid: row.interconnectorid.clone(),
            fromregionid: row.fromregionid.clone(),
            totalresidues: row.totalresidues.clone(),
            adjustment: row.adjustment.clone(),
            lastchanged: row.lastchanged.clone(),
            backing_data: row.backing_data.to_owned(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct BillingIraucsurplus5PrimaryKey {
    pub billrunno: rust_decimal::Decimal,
    pub contractid: alloc::string::String,
    pub contractyear: rust_decimal::Decimal,
    pub fromregionid: alloc::string::String,
    pub interconnectorid: alloc::string::String,
    pub participantid: alloc::string::String,
    pub weekno: rust_decimal::Decimal,
}
impl mmsdm_core::PrimaryKey for BillingIraucsurplus5PrimaryKey {}
impl<'data> mmsdm_core::CompareWithRow for BillingIraucsurplus5Row<'data> {
    type Row<'other> = BillingIraucsurplus5Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractid() == row.contractid()
            && self.contractyear == row.contractyear
            && self.fromregionid() == row.fromregionid()
            && self.interconnectorid() == row.interconnectorid()
            && self.participantid() == row.participantid() && self.weekno == row.weekno
    }
}
impl<'data> mmsdm_core::CompareWithPrimaryKey for BillingIraucsurplus5Row<'data> {
    type PrimaryKey = BillingIraucsurplus5PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractid() == key.contractid
            && self.contractyear == key.contractyear
            && self.fromregionid() == key.fromregionid
            && self.interconnectorid() == key.interconnectorid
            && self.participantid() == key.participantid && self.weekno == key.weekno
    }
}
impl<'data> mmsdm_core::CompareWithRow for BillingIraucsurplus5PrimaryKey {
    type Row<'other> = BillingIraucsurplus5Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractid == row.contractid()
            && self.contractyear == row.contractyear
            && self.fromregionid == row.fromregionid()
            && self.interconnectorid == row.interconnectorid()
            && self.participantid == row.participantid() && self.weekno == row.weekno
    }
}
impl mmsdm_core::CompareWithPrimaryKey for BillingIraucsurplus5PrimaryKey {
    type PrimaryKey = BillingIraucsurplus5PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractid == key.contractid
            && self.contractyear == key.contractyear
            && self.fromregionid == key.fromregionid
            && self.interconnectorid == key.interconnectorid
            && self.participantid == key.participantid && self.weekno == key.weekno
    }
}
#[cfg(feature = "arrow")]
impl mmsdm_core::ArrowSchema for BillingIraucsurplus5 {
    type Builder = BillingIraucsurplus5Builder;
    fn schema() -> arrow::datatypes::Schema {
        arrow::datatypes::Schema::new(
            alloc::vec::Vec::from([
                arrow::datatypes::Field::new(
                    "contractyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "weekno",
                    arrow::datatypes::DataType::Decimal128(2, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "residueyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "quarter",
                    arrow::datatypes::DataType::Decimal128(2, 0),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "billrunno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "contractid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "participantid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "interconnectorid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "fromregionid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "totalresidues",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "adjustment",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lastchanged",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    true,
                ),
            ]),
        )
    }
    fn new_builder() -> Self::Builder {
        BillingIraucsurplus5Builder {
            contractyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            weekno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(2, 0)),
            residueyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            quarter_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(2, 0)),
            billrunno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            contractid_array: arrow::array::builder::StringBuilder::new(),
            participantid_array: arrow::array::builder::StringBuilder::new(),
            interconnectorid_array: arrow::array::builder::StringBuilder::new(),
            fromregionid_array: arrow::array::builder::StringBuilder::new(),
            totalresidues_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            adjustment_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
        }
    }
    fn append_builder(builder: &mut Self::Builder, row: Self::Row<'_>) {
        builder
            .contractyear_array
            .append_value({
                let mut val = row.contractyear;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .weekno_array
            .append_value({
                let mut val = row.weekno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .residueyear_array
            .append_option({
                row.residueyear
                    .map(|mut val| {
                        val.rescale(0);
                        val.mantissa()
                    })
            });
        builder
            .quarter_array
            .append_option({
                row.quarter
                    .map(|mut val| {
                        val.rescale(0);
                        val.mantissa()
                    })
            });
        builder
            .billrunno_array
            .append_value({
                let mut val = row.billrunno;
                val.rescale(0);
                val.mantissa()
            });
        builder.contractid_array.append_value(row.contractid());
        builder.participantid_array.append_value(row.participantid());
        builder.interconnectorid_array.append_value(row.interconnectorid());
        builder.fromregionid_array.append_value(row.fromregionid());
        builder
            .totalresidues_array
            .append_option({
                row.totalresidues
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .adjustment_array
            .append_option({
                row.adjustment
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .lastchanged_array
            .append_option(row.lastchanged.map(|val| val.and_utc().timestamp_millis()));
    }
    fn finalize_builder(
        builder: &mut Self::Builder,
    ) -> mmsdm_core::Result<arrow::array::RecordBatch> {
        arrow::array::RecordBatch::try_new(
                alloc::sync::Arc::new(<Self as mmsdm_core::ArrowSchema>::schema()),
                alloc::vec::Vec::from([
                    alloc::sync::Arc::new(builder.contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.residueyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.quarter_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.contractid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.participantid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.interconnectorid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.fromregionid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.totalresidues_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.adjustment_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lastchanged_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                ]),
            )
            .map_err(Into::into)
    }
}
#[cfg(feature = "arrow")]
pub struct BillingIraucsurplus5Builder {
    contractyear_array: arrow::array::builder::Decimal128Builder,
    weekno_array: arrow::array::builder::Decimal128Builder,
    residueyear_array: arrow::array::builder::Decimal128Builder,
    quarter_array: arrow::array::builder::Decimal128Builder,
    billrunno_array: arrow::array::builder::Decimal128Builder,
    contractid_array: arrow::array::builder::StringBuilder,
    participantid_array: arrow::array::builder::StringBuilder,
    interconnectorid_array: arrow::array::builder::StringBuilder,
    fromregionid_array: arrow::array::builder::StringBuilder,
    totalresidues_array: arrow::array::builder::Decimal128Builder,
    adjustment_array: arrow::array::builder::Decimal128Builder,
    lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder,
}
pub struct BillingIraucsurplussum7 {
    extract_row_partition: alloc::boxed::Box<
        dyn Fn(
            &BillingIraucsurplussum7Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    >,
    row_partition_key: mmsdm_core::PartitionKey,
}
impl BillingIraucsurplussum7 {
    pub fn new(
        row_partition_key: mmsdm_core::PartitionKey,
        func: impl Fn(
            &<Self as mmsdm_core::GetTable>::Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    ) -> Self {
        Self {
            extract_row_partition: alloc::boxed::Box::new(func),
            row_partition_key,
        }
    }
}
pub struct BillingIraucsurplussum7Mapping([usize; 16]);
/// # Summary
///
/// ## BILLINGIRAUCSURPLUSSUM
///  _BILLINGIRAUCSURPLUSSUM contains Auction fees and Settlements Residue Auction distribution that may arise from unpurchased auction units that accrue to Transmission Network Service Providers._
///
/// * Data Set Name: Billing
/// * File Name: Iraucsurplussum
/// * Data Version: 7
///
/// # Description
///  BILLINGIRAUCSURPLUSSUM is confidential to the relevant participant. Source BILLINGIRAUCSURPLUSSUM is populated by the posting of a billing run where there are unpurchased auction units. Volume An indicative maximum is eight records inserted per billing run, or 88 records inserted per week.
///
///
///
/// # Primary Key Columns
///
/// * BILLRUNNO
/// * CONTRACTYEAR
/// * FROMREGIONID
/// * INTERCONNECTORID
/// * PARTICIPANTID
/// * QUARTER
/// * RESIDUEYEAR
/// * WEEKNO
#[derive(Debug, PartialEq, Eq)]
pub struct BillingIraucsurplussum7Row<'data> {
    /// Contracted Year (calendar year)
    pub contractyear: rust_decimal::Decimal,
    /// Week no within the contract year. Week no 1 is the week containing 1st January
    pub weekno: rust_decimal::Decimal,
    /// Year of the Residue Contract; may differ from the calendar year at week 1.
    pub residueyear: rust_decimal::Decimal,
    /// Residue Contract Quarter
    pub quarter: rust_decimal::Decimal,
    /// The sequential number of a billing run
    pub billrunno: rust_decimal::Decimal,
    /// Contracted Interconnector
    pub interconnectorid: core::ops::Range<usize>,
    /// Nominated source region for Interconnector
    pub fromregionid: core::ops::Range<usize>,
    /// Unique participant identifier
    pub participantid: core::ops::Range<usize>,
    /// Total residue amount allocated to participant
    pub totalsurplus: Option<rust_decimal::Decimal>,
    /// Total auction fees payable in this week (negative amount). If AUCTIONFEES + AUCTIONFEES_GST &gt;= TOTALSURPLUS then ACTUALPAYMENT is zero
    pub auctionfees: Option<rust_decimal::Decimal>,
    /// Net payment to participant, including auction fees
    pub actualpayment: Option<rust_decimal::Decimal>,
    /// The GST amount on the auction fees, always being zero.
    pub auctionfees_gst: Option<rust_decimal::Decimal>,
    /// Date and time this record was last modified
    pub lastchanged: Option<chrono::NaiveDateTime>,
    /// The CSP derogation amount applied as an adjustment to SRA.
    pub csp_derogation_amount: Option<rust_decimal::Decimal>,
    /// The SRA amount unadjusted by CSP.
    pub unadjusted_irsr: Option<rust_decimal::Decimal>,
    /// Negative residues in the billing week for this participant in the SRA Year/Quarter
    pub negative_residues: Option<rust_decimal::Decimal>,
    backing_data: mmsdm_core::CsvRow<'data>,
}
impl<'data> BillingIraucsurplussum7Row<'data> {
    pub fn interconnectorid(&self) -> &str {
        core::ops::Index::index(
            self.backing_data.as_slice(),
            self.interconnectorid.clone(),
        )
    }
    pub fn fromregionid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.fromregionid.clone())
    }
    pub fn participantid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.participantid.clone())
    }
}
impl mmsdm_core::GetTable for BillingIraucsurplussum7 {
    const VERSION: i32 = 7;
    const DATA_SET_NAME: &'static str = "BILLING";
    const TABLE_NAME: &'static str = "IRAUCSURPLUSSUM";
    const DEFAULT_FIELD_MAPPING: Self::FieldMapping = BillingIraucsurplussum7Mapping([
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
    ]);
    const COLUMNS: &'static [&'static str] = &[
        "CONTRACTYEAR",
        "WEEKNO",
        "RESIDUEYEAR",
        "QUARTER",
        "BILLRUNNO",
        "INTERCONNECTORID",
        "FROMREGIONID",
        "PARTICIPANTID",
        "TOTALSURPLUS",
        "AUCTIONFEES",
        "ACTUALPAYMENT",
        "AUCTIONFEES_GST",
        "LASTCHANGED",
        "CSP_DEROGATION_AMOUNT",
        "UNADJUSTED_IRSR",
        "NEGATIVE_RESIDUES",
    ];
    type Row<'row> = BillingIraucsurplussum7Row<'row>;
    type FieldMapping = BillingIraucsurplussum7Mapping;
    type PrimaryKey = BillingIraucsurplussum7PrimaryKey;
    fn from_row<'data>(
        row: mmsdm_core::CsvRow<'data>,
        field_mapping: &Self::FieldMapping,
    ) -> mmsdm_core::Result<Self::Row<'data>> {
        Ok(BillingIraucsurplussum7Row {
            contractyear: row
                .get_custom_parsed_at_idx(
                    "contractyear",
                    field_mapping.0[0],
                    mmsdm_core::mms_decimal::parse,
                )?,
            weekno: row
                .get_custom_parsed_at_idx(
                    "weekno",
                    field_mapping.0[1],
                    mmsdm_core::mms_decimal::parse,
                )?,
            residueyear: row
                .get_custom_parsed_at_idx(
                    "residueyear",
                    field_mapping.0[2],
                    mmsdm_core::mms_decimal::parse,
                )?,
            quarter: row
                .get_custom_parsed_at_idx(
                    "quarter",
                    field_mapping.0[3],
                    mmsdm_core::mms_decimal::parse,
                )?,
            billrunno: row
                .get_custom_parsed_at_idx(
                    "billrunno",
                    field_mapping.0[4],
                    mmsdm_core::mms_decimal::parse,
                )?,
            interconnectorid: row.get_range("interconnectorid", field_mapping.0[5])?,
            fromregionid: row.get_range("fromregionid", field_mapping.0[6])?,
            participantid: row.get_range("participantid", field_mapping.0[7])?,
            totalsurplus: row
                .get_opt_custom_parsed_at_idx(
                    "totalsurplus",
                    field_mapping.0[8],
                    mmsdm_core::mms_decimal::parse,
                )?,
            auctionfees: row
                .get_opt_custom_parsed_at_idx(
                    "auctionfees",
                    field_mapping.0[9],
                    mmsdm_core::mms_decimal::parse,
                )?,
            actualpayment: row
                .get_opt_custom_parsed_at_idx(
                    "actualpayment",
                    field_mapping.0[10],
                    mmsdm_core::mms_decimal::parse,
                )?,
            auctionfees_gst: row
                .get_opt_custom_parsed_at_idx(
                    "auctionfees_gst",
                    field_mapping.0[11],
                    mmsdm_core::mms_decimal::parse,
                )?,
            lastchanged: row
                .get_opt_custom_parsed_at_idx(
                    "lastchanged",
                    field_mapping.0[12],
                    mmsdm_core::mms_datetime::parse,
                )?,
            csp_derogation_amount: row
                .get_opt_custom_parsed_at_idx(
                    "csp_derogation_amount",
                    field_mapping.0[13],
                    mmsdm_core::mms_decimal::parse,
                )?,
            unadjusted_irsr: row
                .get_opt_custom_parsed_at_idx(
                    "unadjusted_irsr",
                    field_mapping.0[14],
                    mmsdm_core::mms_decimal::parse,
                )?,
            negative_residues: row
                .get_opt_custom_parsed_at_idx(
                    "negative_residues",
                    field_mapping.0[15],
                    mmsdm_core::mms_decimal::parse,
                )?,
            backing_data: row,
        })
    }
    fn field_mapping_from_row<'a>(
        mut row: mmsdm_core::CsvRow<'a>,
    ) -> mmsdm_core::Result<Self::FieldMapping> {
        if !row.is_heading() {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!("Expected an I row but got {row:?}"),
                ),
            );
        }
        let row_key = mmsdm_core::FileKey::from_row(row.borrow())?;
        if !Self::matches_file_key(&row_key, row_key.version) {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!(
                        "Expected a row matching {}.{}.v{} but got {row_key}",
                        Self::DATA_SET_NAME, Self::TABLE_NAME, Self::VERSION
                    ),
                ),
            );
        }
        let mut base_mapping = Self::DEFAULT_FIELD_MAPPING.0;
        for (field_index, field) in Self::COLUMNS.iter().enumerate() {
            base_mapping[field_index] = row
                .iter_fields()
                .position(|f| f == *field)
                .unwrap_or(usize::MAX);
        }
        Ok(BillingIraucsurplussum7Mapping(base_mapping))
    }
    fn matches_file_key(key: &mmsdm_core::FileKey<'_>, version: i32) -> bool {
        version == key.version && Self::DATA_SET_NAME == key.data_set_name()
            && Self::TABLE_NAME == key.table_name()
    }
    fn primary_key(row: &Self::Row<'_>) -> BillingIraucsurplussum7PrimaryKey {
        BillingIraucsurplussum7PrimaryKey {
            billrunno: row.billrunno,
            contractyear: row.contractyear,
            fromregionid: row.fromregionid().to_string(),
            interconnectorid: row.interconnectorid().to_string(),
            participantid: row.participantid().to_string(),
            quarter: row.quarter,
            residueyear: row.residueyear,
            weekno: row.weekno,
        }
    }
    fn partition_value(&self, row: &Self::Row<'_>) -> mmsdm_core::PartitionValue {
        (self.extract_row_partition)(row)
    }
    fn partition_name(&self, row: &Self::Row<'_>) -> alloc::string::String {
        alloc::format!("billing_iraucsurplussum_v7_{}", self.partition_value(row))
    }
    fn partition_key(&self) -> mmsdm_core::PartitionKey {
        self.row_partition_key
    }
    fn to_static<'a>(row: &Self::Row<'a>) -> Self::Row<'static> {
        BillingIraucsurplussum7Row {
            contractyear: row.contractyear.clone(),
            weekno: row.weekno.clone(),
            residueyear: row.residueyear.clone(),
            quarter: row.quarter.clone(),
            billrunno: row.billrunno.clone(),
            interconnectorid: row.interconnectorid.clone(),
            fromregionid: row.fromregionid.clone(),
            participantid: row.participantid.clone(),
            totalsurplus: row.totalsurplus.clone(),
            auctionfees: row.auctionfees.clone(),
            actualpayment: row.actualpayment.clone(),
            auctionfees_gst: row.auctionfees_gst.clone(),
            lastchanged: row.lastchanged.clone(),
            csp_derogation_amount: row.csp_derogation_amount.clone(),
            unadjusted_irsr: row.unadjusted_irsr.clone(),
            negative_residues: row.negative_residues.clone(),
            backing_data: row.backing_data.to_owned(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct BillingIraucsurplussum7PrimaryKey {
    pub billrunno: rust_decimal::Decimal,
    pub contractyear: rust_decimal::Decimal,
    pub fromregionid: alloc::string::String,
    pub interconnectorid: alloc::string::String,
    pub participantid: alloc::string::String,
    pub quarter: rust_decimal::Decimal,
    pub residueyear: rust_decimal::Decimal,
    pub weekno: rust_decimal::Decimal,
}
impl mmsdm_core::PrimaryKey for BillingIraucsurplussum7PrimaryKey {}
impl<'data> mmsdm_core::CompareWithRow for BillingIraucsurplussum7Row<'data> {
    type Row<'other> = BillingIraucsurplussum7Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.fromregionid() == row.fromregionid()
            && self.interconnectorid() == row.interconnectorid()
            && self.participantid() == row.participantid() && self.quarter == row.quarter
            && self.residueyear == row.residueyear && self.weekno == row.weekno
    }
}
impl<'data> mmsdm_core::CompareWithPrimaryKey for BillingIraucsurplussum7Row<'data> {
    type PrimaryKey = BillingIraucsurplussum7PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.fromregionid() == key.fromregionid
            && self.interconnectorid() == key.interconnectorid
            && self.participantid() == key.participantid && self.quarter == key.quarter
            && self.residueyear == key.residueyear && self.weekno == key.weekno
    }
}
impl<'data> mmsdm_core::CompareWithRow for BillingIraucsurplussum7PrimaryKey {
    type Row<'other> = BillingIraucsurplussum7Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.fromregionid == row.fromregionid()
            && self.interconnectorid == row.interconnectorid()
            && self.participantid == row.participantid() && self.quarter == row.quarter
            && self.residueyear == row.residueyear && self.weekno == row.weekno
    }
}
impl mmsdm_core::CompareWithPrimaryKey for BillingIraucsurplussum7PrimaryKey {
    type PrimaryKey = BillingIraucsurplussum7PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.fromregionid == key.fromregionid
            && self.interconnectorid == key.interconnectorid
            && self.participantid == key.participantid && self.quarter == key.quarter
            && self.residueyear == key.residueyear && self.weekno == key.weekno
    }
}
#[cfg(feature = "arrow")]
impl mmsdm_core::ArrowSchema for BillingIraucsurplussum7 {
    type Builder = BillingIraucsurplussum7Builder;
    fn schema() -> arrow::datatypes::Schema {
        arrow::datatypes::Schema::new(
            alloc::vec::Vec::from([
                arrow::datatypes::Field::new(
                    "contractyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "weekno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "residueyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "quarter",
                    arrow::datatypes::DataType::Decimal128(2, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "billrunno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "interconnectorid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "fromregionid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "participantid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "totalsurplus",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "auctionfees",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "actualpayment",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "auctionfees_gst",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lastchanged",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "csp_derogation_amount",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "unadjusted_irsr",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "negative_residues",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
            ]),
        )
    }
    fn new_builder() -> Self::Builder {
        BillingIraucsurplussum7Builder {
            contractyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            weekno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            residueyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            quarter_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(2, 0)),
            billrunno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            interconnectorid_array: arrow::array::builder::StringBuilder::new(),
            fromregionid_array: arrow::array::builder::StringBuilder::new(),
            participantid_array: arrow::array::builder::StringBuilder::new(),
            totalsurplus_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            auctionfees_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            actualpayment_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            auctionfees_gst_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
            csp_derogation_amount_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            unadjusted_irsr_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            negative_residues_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
        }
    }
    fn append_builder(builder: &mut Self::Builder, row: Self::Row<'_>) {
        builder
            .contractyear_array
            .append_value({
                let mut val = row.contractyear;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .weekno_array
            .append_value({
                let mut val = row.weekno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .residueyear_array
            .append_value({
                let mut val = row.residueyear;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .quarter_array
            .append_value({
                let mut val = row.quarter;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .billrunno_array
            .append_value({
                let mut val = row.billrunno;
                val.rescale(0);
                val.mantissa()
            });
        builder.interconnectorid_array.append_value(row.interconnectorid());
        builder.fromregionid_array.append_value(row.fromregionid());
        builder.participantid_array.append_value(row.participantid());
        builder
            .totalsurplus_array
            .append_option({
                row.totalsurplus
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .auctionfees_array
            .append_option({
                row.auctionfees
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .actualpayment_array
            .append_option({
                row.actualpayment
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .auctionfees_gst_array
            .append_option({
                row.auctionfees_gst
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .lastchanged_array
            .append_option(row.lastchanged.map(|val| val.and_utc().timestamp_millis()));
        builder
            .csp_derogation_amount_array
            .append_option({
                row.csp_derogation_amount
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .unadjusted_irsr_array
            .append_option({
                row.unadjusted_irsr
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .negative_residues_array
            .append_option({
                row.negative_residues
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
    }
    fn finalize_builder(
        builder: &mut Self::Builder,
    ) -> mmsdm_core::Result<arrow::array::RecordBatch> {
        arrow::array::RecordBatch::try_new(
                alloc::sync::Arc::new(<Self as mmsdm_core::ArrowSchema>::schema()),
                alloc::vec::Vec::from([
                    alloc::sync::Arc::new(builder.contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.residueyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.quarter_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.interconnectorid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.fromregionid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.participantid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.totalsurplus_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.auctionfees_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.actualpayment_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.auctionfees_gst_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lastchanged_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.csp_derogation_amount_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.unadjusted_irsr_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.negative_residues_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                ]),
            )
            .map_err(Into::into)
    }
}
#[cfg(feature = "arrow")]
pub struct BillingIraucsurplussum7Builder {
    contractyear_array: arrow::array::builder::Decimal128Builder,
    weekno_array: arrow::array::builder::Decimal128Builder,
    residueyear_array: arrow::array::builder::Decimal128Builder,
    quarter_array: arrow::array::builder::Decimal128Builder,
    billrunno_array: arrow::array::builder::Decimal128Builder,
    interconnectorid_array: arrow::array::builder::StringBuilder,
    fromregionid_array: arrow::array::builder::StringBuilder,
    participantid_array: arrow::array::builder::StringBuilder,
    totalsurplus_array: arrow::array::builder::Decimal128Builder,
    auctionfees_array: arrow::array::builder::Decimal128Builder,
    actualpayment_array: arrow::array::builder::Decimal128Builder,
    auctionfees_gst_array: arrow::array::builder::Decimal128Builder,
    lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder,
    csp_derogation_amount_array: arrow::array::builder::Decimal128Builder,
    unadjusted_irsr_array: arrow::array::builder::Decimal128Builder,
    negative_residues_array: arrow::array::builder::Decimal128Builder,
}
pub struct BillingIrnspsurplus5 {
    extract_row_partition: alloc::boxed::Box<
        dyn Fn(
            &BillingIrnspsurplus5Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    >,
    row_partition_key: mmsdm_core::PartitionKey,
}
impl BillingIrnspsurplus5 {
    pub fn new(
        row_partition_key: mmsdm_core::PartitionKey,
        func: impl Fn(
            &<Self as mmsdm_core::GetTable>::Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    ) -> Self {
        Self {
            extract_row_partition: alloc::boxed::Box::new(func),
            row_partition_key,
        }
    }
}
pub struct BillingIrnspsurplus5Mapping([usize; 12]);
/// # Summary
///
/// ## BILLINGIRNSPSURPLUS
///  _BILLINGIRNSPSURPLUS supports the Settlements Residue Auction (SRA), by showing the weekly billing Interconnector Residue (IR) payments as calculated for each bill run for Transmission Network Service Providers (TNSP) from the amount paid by participants (i.e. derogated amounts)._
///
/// * Data Set Name: Billing
/// * File Name: Irnspsurplus
/// * Data Version: 5
///
/// # Description
///  BILLINGIRNSPSURPLUS data is confidential to the relevant participant. Source BILLINGIRNSPSURPLUS updates in a billing run where any derogated Settlement Residue Auction purchase flows to a TNSP. Volume BILLINGIRNSPSURPLUS contains a maximum of 30, 000 records per year.
///
///
///
/// # Primary Key Columns
///
/// * BILLRUNNO
/// * CONTRACTID
/// * CONTRACTYEAR
/// * FROMREGIONID
/// * INTERCONNECTORID
/// * PARTICIPANTID
/// * WEEKNO
#[derive(Debug, PartialEq, Eq)]
pub struct BillingIrnspsurplus5Row<'data> {
    /// AEMO Contract Year number starting in week containing 1st January
    pub contractyear: rust_decimal::Decimal,
    /// Week no within the contract year. Week no 1 is the week containing 1st January
    pub weekno: rust_decimal::Decimal,
    /// Year of the Residue Contract; may differ from the calendar year at week 1.
    pub residueyear: Option<rust_decimal::Decimal>,
    /// Residue Contract Quarter
    pub quarter: Option<rust_decimal::Decimal>,
    /// The sequential number of a billing run
    pub billrunno: rust_decimal::Decimal,
    /// SRA Contract unique identifier
    pub contractid: core::ops::Range<usize>,
    /// Unique participant identifier
    pub participantid: core::ops::Range<usize>,
    /// Contracted Interconnector
    pub interconnectorid: core::ops::Range<usize>,
    /// Nominated source region for Interconnector
    pub fromregionid: core::ops::Range<usize>,
    /// Total residues allocated to participant
    pub totalresidues: Option<rust_decimal::Decimal>,
    /// Adjustment allocated to participant
    pub adjustment: Option<rust_decimal::Decimal>,
    /// Date and time this record was last modified
    pub lastchanged: Option<chrono::NaiveDateTime>,
    backing_data: mmsdm_core::CsvRow<'data>,
}
impl<'data> BillingIrnspsurplus5Row<'data> {
    pub fn contractid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.contractid.clone())
    }
    pub fn participantid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.participantid.clone())
    }
    pub fn interconnectorid(&self) -> &str {
        core::ops::Index::index(
            self.backing_data.as_slice(),
            self.interconnectorid.clone(),
        )
    }
    pub fn fromregionid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.fromregionid.clone())
    }
}
impl mmsdm_core::GetTable for BillingIrnspsurplus5 {
    const VERSION: i32 = 5;
    const DATA_SET_NAME: &'static str = "BILLING";
    const TABLE_NAME: &'static str = "IRNSPSURPLUS";
    const DEFAULT_FIELD_MAPPING: Self::FieldMapping = BillingIrnspsurplus5Mapping([
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
    ]);
    const COLUMNS: &'static [&'static str] = &[
        "CONTRACTYEAR",
        "WEEKNO",
        "RESIDUEYEAR",
        "QUARTER",
        "BILLRUNNO",
        "CONTRACTID",
        "PARTICIPANTID",
        "INTERCONNECTORID",
        "FROMREGIONID",
        "TOTALRESIDUES",
        "ADJUSTMENT",
        "LASTCHANGED",
    ];
    type Row<'row> = BillingIrnspsurplus5Row<'row>;
    type FieldMapping = BillingIrnspsurplus5Mapping;
    type PrimaryKey = BillingIrnspsurplus5PrimaryKey;
    fn from_row<'data>(
        row: mmsdm_core::CsvRow<'data>,
        field_mapping: &Self::FieldMapping,
    ) -> mmsdm_core::Result<Self::Row<'data>> {
        Ok(BillingIrnspsurplus5Row {
            contractyear: row
                .get_custom_parsed_at_idx(
                    "contractyear",
                    field_mapping.0[0],
                    mmsdm_core::mms_decimal::parse,
                )?,
            weekno: row
                .get_custom_parsed_at_idx(
                    "weekno",
                    field_mapping.0[1],
                    mmsdm_core::mms_decimal::parse,
                )?,
            residueyear: row
                .get_opt_custom_parsed_at_idx(
                    "residueyear",
                    field_mapping.0[2],
                    mmsdm_core::mms_decimal::parse,
                )?,
            quarter: row
                .get_opt_custom_parsed_at_idx(
                    "quarter",
                    field_mapping.0[3],
                    mmsdm_core::mms_decimal::parse,
                )?,
            billrunno: row
                .get_custom_parsed_at_idx(
                    "billrunno",
                    field_mapping.0[4],
                    mmsdm_core::mms_decimal::parse,
                )?,
            contractid: row.get_range("contractid", field_mapping.0[5])?,
            participantid: row.get_range("participantid", field_mapping.0[6])?,
            interconnectorid: row.get_range("interconnectorid", field_mapping.0[7])?,
            fromregionid: row.get_range("fromregionid", field_mapping.0[8])?,
            totalresidues: row
                .get_opt_custom_parsed_at_idx(
                    "totalresidues",
                    field_mapping.0[9],
                    mmsdm_core::mms_decimal::parse,
                )?,
            adjustment: row
                .get_opt_custom_parsed_at_idx(
                    "adjustment",
                    field_mapping.0[10],
                    mmsdm_core::mms_decimal::parse,
                )?,
            lastchanged: row
                .get_opt_custom_parsed_at_idx(
                    "lastchanged",
                    field_mapping.0[11],
                    mmsdm_core::mms_datetime::parse,
                )?,
            backing_data: row,
        })
    }
    fn field_mapping_from_row<'a>(
        mut row: mmsdm_core::CsvRow<'a>,
    ) -> mmsdm_core::Result<Self::FieldMapping> {
        if !row.is_heading() {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!("Expected an I row but got {row:?}"),
                ),
            );
        }
        let row_key = mmsdm_core::FileKey::from_row(row.borrow())?;
        if !Self::matches_file_key(&row_key, row_key.version) {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!(
                        "Expected a row matching {}.{}.v{} but got {row_key}",
                        Self::DATA_SET_NAME, Self::TABLE_NAME, Self::VERSION
                    ),
                ),
            );
        }
        let mut base_mapping = Self::DEFAULT_FIELD_MAPPING.0;
        for (field_index, field) in Self::COLUMNS.iter().enumerate() {
            base_mapping[field_index] = row
                .iter_fields()
                .position(|f| f == *field)
                .unwrap_or(usize::MAX);
        }
        Ok(BillingIrnspsurplus5Mapping(base_mapping))
    }
    fn matches_file_key(key: &mmsdm_core::FileKey<'_>, version: i32) -> bool {
        version == key.version && Self::DATA_SET_NAME == key.data_set_name()
            && Self::TABLE_NAME == key.table_name()
    }
    fn primary_key(row: &Self::Row<'_>) -> BillingIrnspsurplus5PrimaryKey {
        BillingIrnspsurplus5PrimaryKey {
            billrunno: row.billrunno,
            contractid: row.contractid().to_string(),
            contractyear: row.contractyear,
            fromregionid: row.fromregionid().to_string(),
            interconnectorid: row.interconnectorid().to_string(),
            participantid: row.participantid().to_string(),
            weekno: row.weekno,
        }
    }
    fn partition_value(&self, row: &Self::Row<'_>) -> mmsdm_core::PartitionValue {
        (self.extract_row_partition)(row)
    }
    fn partition_name(&self, row: &Self::Row<'_>) -> alloc::string::String {
        alloc::format!("billing_irnspsurplus_v5_{}", self.partition_value(row))
    }
    fn partition_key(&self) -> mmsdm_core::PartitionKey {
        self.row_partition_key
    }
    fn to_static<'a>(row: &Self::Row<'a>) -> Self::Row<'static> {
        BillingIrnspsurplus5Row {
            contractyear: row.contractyear.clone(),
            weekno: row.weekno.clone(),
            residueyear: row.residueyear.clone(),
            quarter: row.quarter.clone(),
            billrunno: row.billrunno.clone(),
            contractid: row.contractid.clone(),
            participantid: row.participantid.clone(),
            interconnectorid: row.interconnectorid.clone(),
            fromregionid: row.fromregionid.clone(),
            totalresidues: row.totalresidues.clone(),
            adjustment: row.adjustment.clone(),
            lastchanged: row.lastchanged.clone(),
            backing_data: row.backing_data.to_owned(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct BillingIrnspsurplus5PrimaryKey {
    pub billrunno: rust_decimal::Decimal,
    pub contractid: alloc::string::String,
    pub contractyear: rust_decimal::Decimal,
    pub fromregionid: alloc::string::String,
    pub interconnectorid: alloc::string::String,
    pub participantid: alloc::string::String,
    pub weekno: rust_decimal::Decimal,
}
impl mmsdm_core::PrimaryKey for BillingIrnspsurplus5PrimaryKey {}
impl<'data> mmsdm_core::CompareWithRow for BillingIrnspsurplus5Row<'data> {
    type Row<'other> = BillingIrnspsurplus5Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractid() == row.contractid()
            && self.contractyear == row.contractyear
            && self.fromregionid() == row.fromregionid()
            && self.interconnectorid() == row.interconnectorid()
            && self.participantid() == row.participantid() && self.weekno == row.weekno
    }
}
impl<'data> mmsdm_core::CompareWithPrimaryKey for BillingIrnspsurplus5Row<'data> {
    type PrimaryKey = BillingIrnspsurplus5PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractid() == key.contractid
            && self.contractyear == key.contractyear
            && self.fromregionid() == key.fromregionid
            && self.interconnectorid() == key.interconnectorid
            && self.participantid() == key.participantid && self.weekno == key.weekno
    }
}
impl<'data> mmsdm_core::CompareWithRow for BillingIrnspsurplus5PrimaryKey {
    type Row<'other> = BillingIrnspsurplus5Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractid == row.contractid()
            && self.contractyear == row.contractyear
            && self.fromregionid == row.fromregionid()
            && self.interconnectorid == row.interconnectorid()
            && self.participantid == row.participantid() && self.weekno == row.weekno
    }
}
impl mmsdm_core::CompareWithPrimaryKey for BillingIrnspsurplus5PrimaryKey {
    type PrimaryKey = BillingIrnspsurplus5PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractid == key.contractid
            && self.contractyear == key.contractyear
            && self.fromregionid == key.fromregionid
            && self.interconnectorid == key.interconnectorid
            && self.participantid == key.participantid && self.weekno == key.weekno
    }
}
#[cfg(feature = "arrow")]
impl mmsdm_core::ArrowSchema for BillingIrnspsurplus5 {
    type Builder = BillingIrnspsurplus5Builder;
    fn schema() -> arrow::datatypes::Schema {
        arrow::datatypes::Schema::new(
            alloc::vec::Vec::from([
                arrow::datatypes::Field::new(
                    "contractyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "weekno",
                    arrow::datatypes::DataType::Decimal128(2, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "residueyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "quarter",
                    arrow::datatypes::DataType::Decimal128(2, 0),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "billrunno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "contractid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "participantid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "interconnectorid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "fromregionid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "totalresidues",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "adjustment",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lastchanged",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    true,
                ),
            ]),
        )
    }
    fn new_builder() -> Self::Builder {
        BillingIrnspsurplus5Builder {
            contractyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            weekno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(2, 0)),
            residueyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            quarter_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(2, 0)),
            billrunno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            contractid_array: arrow::array::builder::StringBuilder::new(),
            participantid_array: arrow::array::builder::StringBuilder::new(),
            interconnectorid_array: arrow::array::builder::StringBuilder::new(),
            fromregionid_array: arrow::array::builder::StringBuilder::new(),
            totalresidues_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            adjustment_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
        }
    }
    fn append_builder(builder: &mut Self::Builder, row: Self::Row<'_>) {
        builder
            .contractyear_array
            .append_value({
                let mut val = row.contractyear;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .weekno_array
            .append_value({
                let mut val = row.weekno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .residueyear_array
            .append_option({
                row.residueyear
                    .map(|mut val| {
                        val.rescale(0);
                        val.mantissa()
                    })
            });
        builder
            .quarter_array
            .append_option({
                row.quarter
                    .map(|mut val| {
                        val.rescale(0);
                        val.mantissa()
                    })
            });
        builder
            .billrunno_array
            .append_value({
                let mut val = row.billrunno;
                val.rescale(0);
                val.mantissa()
            });
        builder.contractid_array.append_value(row.contractid());
        builder.participantid_array.append_value(row.participantid());
        builder.interconnectorid_array.append_value(row.interconnectorid());
        builder.fromregionid_array.append_value(row.fromregionid());
        builder
            .totalresidues_array
            .append_option({
                row.totalresidues
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .adjustment_array
            .append_option({
                row.adjustment
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .lastchanged_array
            .append_option(row.lastchanged.map(|val| val.and_utc().timestamp_millis()));
    }
    fn finalize_builder(
        builder: &mut Self::Builder,
    ) -> mmsdm_core::Result<arrow::array::RecordBatch> {
        arrow::array::RecordBatch::try_new(
                alloc::sync::Arc::new(<Self as mmsdm_core::ArrowSchema>::schema()),
                alloc::vec::Vec::from([
                    alloc::sync::Arc::new(builder.contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.residueyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.quarter_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.contractid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.participantid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.interconnectorid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.fromregionid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.totalresidues_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.adjustment_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lastchanged_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                ]),
            )
            .map_err(Into::into)
    }
}
#[cfg(feature = "arrow")]
pub struct BillingIrnspsurplus5Builder {
    contractyear_array: arrow::array::builder::Decimal128Builder,
    weekno_array: arrow::array::builder::Decimal128Builder,
    residueyear_array: arrow::array::builder::Decimal128Builder,
    quarter_array: arrow::array::builder::Decimal128Builder,
    billrunno_array: arrow::array::builder::Decimal128Builder,
    contractid_array: arrow::array::builder::StringBuilder,
    participantid_array: arrow::array::builder::StringBuilder,
    interconnectorid_array: arrow::array::builder::StringBuilder,
    fromregionid_array: arrow::array::builder::StringBuilder,
    totalresidues_array: arrow::array::builder::Decimal128Builder,
    adjustment_array: arrow::array::builder::Decimal128Builder,
    lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder,
}
pub struct BillingIrnspsurplussum6 {
    extract_row_partition: alloc::boxed::Box<
        dyn Fn(
            &BillingIrnspsurplussum6Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    >,
    row_partition_key: mmsdm_core::PartitionKey,
}
impl BillingIrnspsurplussum6 {
    pub fn new(
        row_partition_key: mmsdm_core::PartitionKey,
        func: impl Fn(
            &<Self as mmsdm_core::GetTable>::Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    ) -> Self {
        Self {
            extract_row_partition: alloc::boxed::Box::new(func),
            row_partition_key,
        }
    }
}
pub struct BillingIrnspsurplussum6Mapping([usize; 14]);
/// # Summary
///
/// ## BILLINGIRNSPSURPLUSSUM
///  _BILLINGIRNSPSURPLUSSUM contains derogated payments made to TNSPs arising from the Settlements Residue Auction process._
///
/// * Data Set Name: Billing
/// * File Name: Irnspsurplussum
/// * Data Version: 6
///
/// # Description
///  BILLINGIRNSPSURPLUSSUM data is confidential to the relevant participant. Source BILLINGIRNSPSURPLUSSUM is populated by the posting of a billing run where derogated payments apply. Volume An indicative maximum is two records inserted per billing run, or 22 records inserted per week.
///
///
///
/// # Primary Key Columns
///
/// * BILLRUNNO
/// * CONTRACTYEAR
/// * FROMREGIONID
/// * INTERCONNECTORID
/// * PARTICIPANTID
/// * QUARTER
/// * RESIDUEYEAR
/// * WEEKNO
#[derive(Debug, PartialEq, Eq)]
pub struct BillingIrnspsurplussum6Row<'data> {
    /// SRA Contracted Year (calendar year)
    pub contractyear: rust_decimal::Decimal,
    /// Week no within the contract year. Week no 1 is the week containing 1st January
    pub weekno: rust_decimal::Decimal,
    /// Year of the Residue Contract; may differ from the calendar year at week 1.
    pub residueyear: rust_decimal::Decimal,
    /// SRA Contracted Quarter
    pub quarter: rust_decimal::Decimal,
    /// The sequential number of a billing run
    pub billrunno: rust_decimal::Decimal,
    /// Contracted Interconnector
    pub interconnectorid: core::ops::Range<usize>,
    /// Nominated source region for Interconnector
    pub fromregionid: core::ops::Range<usize>,
    /// Unique participant identifier
    pub participantid: core::ops::Range<usize>,
    /// Total residue amount allocated to participant
    pub totalsurplus: Option<rust_decimal::Decimal>,
    /// This field is 0.
    pub auctionfees: Option<rust_decimal::Decimal>,
    /// The GST amount on the auction fees, always being zero.
    pub auctionfees_gst: Option<rust_decimal::Decimal>,
    /// Date and time this record was last modified
    pub lastchanged: Option<chrono::NaiveDateTime>,
    /// The CSP derogation amount applied as an adjustment to SRA.
    pub csp_derogation_amount: Option<rust_decimal::Decimal>,
    /// The SRA amount unadjusted by CSP.
    pub unadjusted_irsr: Option<rust_decimal::Decimal>,
    backing_data: mmsdm_core::CsvRow<'data>,
}
impl<'data> BillingIrnspsurplussum6Row<'data> {
    pub fn interconnectorid(&self) -> &str {
        core::ops::Index::index(
            self.backing_data.as_slice(),
            self.interconnectorid.clone(),
        )
    }
    pub fn fromregionid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.fromregionid.clone())
    }
    pub fn participantid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.participantid.clone())
    }
}
impl mmsdm_core::GetTable for BillingIrnspsurplussum6 {
    const VERSION: i32 = 6;
    const DATA_SET_NAME: &'static str = "BILLING";
    const TABLE_NAME: &'static str = "IRNSPSURPLUSSUM";
    const DEFAULT_FIELD_MAPPING: Self::FieldMapping = BillingIrnspsurplussum6Mapping([
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
    ]);
    const COLUMNS: &'static [&'static str] = &[
        "CONTRACTYEAR",
        "WEEKNO",
        "RESIDUEYEAR",
        "QUARTER",
        "BILLRUNNO",
        "INTERCONNECTORID",
        "FROMREGIONID",
        "PARTICIPANTID",
        "TOTALSURPLUS",
        "AUCTIONFEES",
        "AUCTIONFEES_GST",
        "LASTCHANGED",
        "CSP_DEROGATION_AMOUNT",
        "UNADJUSTED_IRSR",
    ];
    type Row<'row> = BillingIrnspsurplussum6Row<'row>;
    type FieldMapping = BillingIrnspsurplussum6Mapping;
    type PrimaryKey = BillingIrnspsurplussum6PrimaryKey;
    fn from_row<'data>(
        row: mmsdm_core::CsvRow<'data>,
        field_mapping: &Self::FieldMapping,
    ) -> mmsdm_core::Result<Self::Row<'data>> {
        Ok(BillingIrnspsurplussum6Row {
            contractyear: row
                .get_custom_parsed_at_idx(
                    "contractyear",
                    field_mapping.0[0],
                    mmsdm_core::mms_decimal::parse,
                )?,
            weekno: row
                .get_custom_parsed_at_idx(
                    "weekno",
                    field_mapping.0[1],
                    mmsdm_core::mms_decimal::parse,
                )?,
            residueyear: row
                .get_custom_parsed_at_idx(
                    "residueyear",
                    field_mapping.0[2],
                    mmsdm_core::mms_decimal::parse,
                )?,
            quarter: row
                .get_custom_parsed_at_idx(
                    "quarter",
                    field_mapping.0[3],
                    mmsdm_core::mms_decimal::parse,
                )?,
            billrunno: row
                .get_custom_parsed_at_idx(
                    "billrunno",
                    field_mapping.0[4],
                    mmsdm_core::mms_decimal::parse,
                )?,
            interconnectorid: row.get_range("interconnectorid", field_mapping.0[5])?,
            fromregionid: row.get_range("fromregionid", field_mapping.0[6])?,
            participantid: row.get_range("participantid", field_mapping.0[7])?,
            totalsurplus: row
                .get_opt_custom_parsed_at_idx(
                    "totalsurplus",
                    field_mapping.0[8],
                    mmsdm_core::mms_decimal::parse,
                )?,
            auctionfees: row
                .get_opt_custom_parsed_at_idx(
                    "auctionfees",
                    field_mapping.0[9],
                    mmsdm_core::mms_decimal::parse,
                )?,
            auctionfees_gst: row
                .get_opt_custom_parsed_at_idx(
                    "auctionfees_gst",
                    field_mapping.0[10],
                    mmsdm_core::mms_decimal::parse,
                )?,
            lastchanged: row
                .get_opt_custom_parsed_at_idx(
                    "lastchanged",
                    field_mapping.0[11],
                    mmsdm_core::mms_datetime::parse,
                )?,
            csp_derogation_amount: row
                .get_opt_custom_parsed_at_idx(
                    "csp_derogation_amount",
                    field_mapping.0[12],
                    mmsdm_core::mms_decimal::parse,
                )?,
            unadjusted_irsr: row
                .get_opt_custom_parsed_at_idx(
                    "unadjusted_irsr",
                    field_mapping.0[13],
                    mmsdm_core::mms_decimal::parse,
                )?,
            backing_data: row,
        })
    }
    fn field_mapping_from_row<'a>(
        mut row: mmsdm_core::CsvRow<'a>,
    ) -> mmsdm_core::Result<Self::FieldMapping> {
        if !row.is_heading() {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!("Expected an I row but got {row:?}"),
                ),
            );
        }
        let row_key = mmsdm_core::FileKey::from_row(row.borrow())?;
        if !Self::matches_file_key(&row_key, row_key.version) {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!(
                        "Expected a row matching {}.{}.v{} but got {row_key}",
                        Self::DATA_SET_NAME, Self::TABLE_NAME, Self::VERSION
                    ),
                ),
            );
        }
        let mut base_mapping = Self::DEFAULT_FIELD_MAPPING.0;
        for (field_index, field) in Self::COLUMNS.iter().enumerate() {
            base_mapping[field_index] = row
                .iter_fields()
                .position(|f| f == *field)
                .unwrap_or(usize::MAX);
        }
        Ok(BillingIrnspsurplussum6Mapping(base_mapping))
    }
    fn matches_file_key(key: &mmsdm_core::FileKey<'_>, version: i32) -> bool {
        version == key.version && Self::DATA_SET_NAME == key.data_set_name()
            && Self::TABLE_NAME == key.table_name()
    }
    fn primary_key(row: &Self::Row<'_>) -> BillingIrnspsurplussum6PrimaryKey {
        BillingIrnspsurplussum6PrimaryKey {
            billrunno: row.billrunno,
            contractyear: row.contractyear,
            fromregionid: row.fromregionid().to_string(),
            interconnectorid: row.interconnectorid().to_string(),
            participantid: row.participantid().to_string(),
            quarter: row.quarter,
            residueyear: row.residueyear,
            weekno: row.weekno,
        }
    }
    fn partition_value(&self, row: &Self::Row<'_>) -> mmsdm_core::PartitionValue {
        (self.extract_row_partition)(row)
    }
    fn partition_name(&self, row: &Self::Row<'_>) -> alloc::string::String {
        alloc::format!("billing_irnspsurplussum_v6_{}", self.partition_value(row))
    }
    fn partition_key(&self) -> mmsdm_core::PartitionKey {
        self.row_partition_key
    }
    fn to_static<'a>(row: &Self::Row<'a>) -> Self::Row<'static> {
        BillingIrnspsurplussum6Row {
            contractyear: row.contractyear.clone(),
            weekno: row.weekno.clone(),
            residueyear: row.residueyear.clone(),
            quarter: row.quarter.clone(),
            billrunno: row.billrunno.clone(),
            interconnectorid: row.interconnectorid.clone(),
            fromregionid: row.fromregionid.clone(),
            participantid: row.participantid.clone(),
            totalsurplus: row.totalsurplus.clone(),
            auctionfees: row.auctionfees.clone(),
            auctionfees_gst: row.auctionfees_gst.clone(),
            lastchanged: row.lastchanged.clone(),
            csp_derogation_amount: row.csp_derogation_amount.clone(),
            unadjusted_irsr: row.unadjusted_irsr.clone(),
            backing_data: row.backing_data.to_owned(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct BillingIrnspsurplussum6PrimaryKey {
    pub billrunno: rust_decimal::Decimal,
    pub contractyear: rust_decimal::Decimal,
    pub fromregionid: alloc::string::String,
    pub interconnectorid: alloc::string::String,
    pub participantid: alloc::string::String,
    pub quarter: rust_decimal::Decimal,
    pub residueyear: rust_decimal::Decimal,
    pub weekno: rust_decimal::Decimal,
}
impl mmsdm_core::PrimaryKey for BillingIrnspsurplussum6PrimaryKey {}
impl<'data> mmsdm_core::CompareWithRow for BillingIrnspsurplussum6Row<'data> {
    type Row<'other> = BillingIrnspsurplussum6Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.fromregionid() == row.fromregionid()
            && self.interconnectorid() == row.interconnectorid()
            && self.participantid() == row.participantid() && self.quarter == row.quarter
            && self.residueyear == row.residueyear && self.weekno == row.weekno
    }
}
impl<'data> mmsdm_core::CompareWithPrimaryKey for BillingIrnspsurplussum6Row<'data> {
    type PrimaryKey = BillingIrnspsurplussum6PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.fromregionid() == key.fromregionid
            && self.interconnectorid() == key.interconnectorid
            && self.participantid() == key.participantid && self.quarter == key.quarter
            && self.residueyear == key.residueyear && self.weekno == key.weekno
    }
}
impl<'data> mmsdm_core::CompareWithRow for BillingIrnspsurplussum6PrimaryKey {
    type Row<'other> = BillingIrnspsurplussum6Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.fromregionid == row.fromregionid()
            && self.interconnectorid == row.interconnectorid()
            && self.participantid == row.participantid() && self.quarter == row.quarter
            && self.residueyear == row.residueyear && self.weekno == row.weekno
    }
}
impl mmsdm_core::CompareWithPrimaryKey for BillingIrnspsurplussum6PrimaryKey {
    type PrimaryKey = BillingIrnspsurplussum6PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.fromregionid == key.fromregionid
            && self.interconnectorid == key.interconnectorid
            && self.participantid == key.participantid && self.quarter == key.quarter
            && self.residueyear == key.residueyear && self.weekno == key.weekno
    }
}
#[cfg(feature = "arrow")]
impl mmsdm_core::ArrowSchema for BillingIrnspsurplussum6 {
    type Builder = BillingIrnspsurplussum6Builder;
    fn schema() -> arrow::datatypes::Schema {
        arrow::datatypes::Schema::new(
            alloc::vec::Vec::from([
                arrow::datatypes::Field::new(
                    "contractyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "weekno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "residueyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "quarter",
                    arrow::datatypes::DataType::Decimal128(2, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "billrunno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "interconnectorid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "fromregionid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "participantid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "totalsurplus",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "auctionfees",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "auctionfees_gst",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lastchanged",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "csp_derogation_amount",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "unadjusted_irsr",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
            ]),
        )
    }
    fn new_builder() -> Self::Builder {
        BillingIrnspsurplussum6Builder {
            contractyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            weekno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            residueyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            quarter_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(2, 0)),
            billrunno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            interconnectorid_array: arrow::array::builder::StringBuilder::new(),
            fromregionid_array: arrow::array::builder::StringBuilder::new(),
            participantid_array: arrow::array::builder::StringBuilder::new(),
            totalsurplus_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            auctionfees_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            auctionfees_gst_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
            csp_derogation_amount_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            unadjusted_irsr_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
        }
    }
    fn append_builder(builder: &mut Self::Builder, row: Self::Row<'_>) {
        builder
            .contractyear_array
            .append_value({
                let mut val = row.contractyear;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .weekno_array
            .append_value({
                let mut val = row.weekno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .residueyear_array
            .append_value({
                let mut val = row.residueyear;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .quarter_array
            .append_value({
                let mut val = row.quarter;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .billrunno_array
            .append_value({
                let mut val = row.billrunno;
                val.rescale(0);
                val.mantissa()
            });
        builder.interconnectorid_array.append_value(row.interconnectorid());
        builder.fromregionid_array.append_value(row.fromregionid());
        builder.participantid_array.append_value(row.participantid());
        builder
            .totalsurplus_array
            .append_option({
                row.totalsurplus
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .auctionfees_array
            .append_option({
                row.auctionfees
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .auctionfees_gst_array
            .append_option({
                row.auctionfees_gst
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .lastchanged_array
            .append_option(row.lastchanged.map(|val| val.and_utc().timestamp_millis()));
        builder
            .csp_derogation_amount_array
            .append_option({
                row.csp_derogation_amount
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .unadjusted_irsr_array
            .append_option({
                row.unadjusted_irsr
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
    }
    fn finalize_builder(
        builder: &mut Self::Builder,
    ) -> mmsdm_core::Result<arrow::array::RecordBatch> {
        arrow::array::RecordBatch::try_new(
                alloc::sync::Arc::new(<Self as mmsdm_core::ArrowSchema>::schema()),
                alloc::vec::Vec::from([
                    alloc::sync::Arc::new(builder.contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.residueyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.quarter_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.interconnectorid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.fromregionid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.participantid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.totalsurplus_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.auctionfees_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.auctionfees_gst_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lastchanged_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.csp_derogation_amount_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.unadjusted_irsr_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                ]),
            )
            .map_err(Into::into)
    }
}
#[cfg(feature = "arrow")]
pub struct BillingIrnspsurplussum6Builder {
    contractyear_array: arrow::array::builder::Decimal128Builder,
    weekno_array: arrow::array::builder::Decimal128Builder,
    residueyear_array: arrow::array::builder::Decimal128Builder,
    quarter_array: arrow::array::builder::Decimal128Builder,
    billrunno_array: arrow::array::builder::Decimal128Builder,
    interconnectorid_array: arrow::array::builder::StringBuilder,
    fromregionid_array: arrow::array::builder::StringBuilder,
    participantid_array: arrow::array::builder::StringBuilder,
    totalsurplus_array: arrow::array::builder::Decimal128Builder,
    auctionfees_array: arrow::array::builder::Decimal128Builder,
    auctionfees_gst_array: arrow::array::builder::Decimal128Builder,
    lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder,
    csp_derogation_amount_array: arrow::array::builder::Decimal128Builder,
    unadjusted_irsr_array: arrow::array::builder::Decimal128Builder,
}
pub struct BillingIrpartsurplus5 {
    extract_row_partition: alloc::boxed::Box<
        dyn Fn(
            &BillingIrpartsurplus5Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    >,
    row_partition_key: mmsdm_core::PartitionKey,
}
impl BillingIrpartsurplus5 {
    pub fn new(
        row_partition_key: mmsdm_core::PartitionKey,
        func: impl Fn(
            &<Self as mmsdm_core::GetTable>::Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    ) -> Self {
        Self {
            extract_row_partition: alloc::boxed::Box::new(func),
            row_partition_key,
        }
    }
}
pub struct BillingIrpartsurplus5Mapping([usize; 13]);
/// # Summary
///
/// ## BILLINGIRPARTSURPLUS
///  _BILLINGIRPARTSURPLUS supports the Settlements Residue Auction, by showing the weekly billing SRA distribution to Auction participants by Contract Identifier._
///
/// * Data Set Name: Billing
/// * File Name: Irpartsurplus
/// * Data Version: 5
///
/// # Description
///  BILLINGIRPARTSURPLUS data is confidential to the relevant participant. Source BILLINGIRPARTSURPLUS is populated by the posting of a billing run where the participant has purchased auction units relating to that billing run. Volume An indicative maximum is 64 records inserted per billing run, or 700 records inserted per week.
///
///
///
/// # Primary Key Columns
///
/// * BILLRUNNO
/// * CONTRACTID
/// * CONTRACTYEAR
/// * FROMREGIONID
/// * INTERCONNECTORID
/// * PARTICIPANTID
/// * WEEKNO
#[derive(Debug, PartialEq, Eq)]
pub struct BillingIrpartsurplus5Row<'data> {
    /// SRA Contracted Year (calendar year)
    pub contractyear: rust_decimal::Decimal,
    /// Week no within the contract year. Week no 1 is the week containing 1st January
    pub weekno: rust_decimal::Decimal,
    /// Year of the Residue Contract; may differ from the calendar year at week 1.
    pub residueyear: Option<rust_decimal::Decimal>,
    /// Residue Contract Quarter
    pub quarter: Option<rust_decimal::Decimal>,
    /// The sequential number of a billing run
    pub billrunno: rust_decimal::Decimal,
    /// SRA Contract unique identifier
    pub contractid: core::ops::Range<usize>,
    /// Unique participant identifier
    pub participantid: core::ops::Range<usize>,
    /// Contracted Interconnector
    pub interconnectorid: core::ops::Range<usize>,
    /// Nominated source region for Interconnector
    pub fromregionid: core::ops::Range<usize>,
    /// Total residues allocated to participant
    pub totalresidues: Option<rust_decimal::Decimal>,
    /// Adjustment allocated to participant
    pub adjustment: Option<rust_decimal::Decimal>,
    /// Date and time this record was last modified
    pub lastchanged: Option<chrono::NaiveDateTime>,
    /// Net actual payment to participant, including auction fees
    pub actualpayment: Option<rust_decimal::Decimal>,
    backing_data: mmsdm_core::CsvRow<'data>,
}
impl<'data> BillingIrpartsurplus5Row<'data> {
    pub fn contractid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.contractid.clone())
    }
    pub fn participantid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.participantid.clone())
    }
    pub fn interconnectorid(&self) -> &str {
        core::ops::Index::index(
            self.backing_data.as_slice(),
            self.interconnectorid.clone(),
        )
    }
    pub fn fromregionid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.fromregionid.clone())
    }
}
impl mmsdm_core::GetTable for BillingIrpartsurplus5 {
    const VERSION: i32 = 5;
    const DATA_SET_NAME: &'static str = "BILLING";
    const TABLE_NAME: &'static str = "IRPARTSURPLUS";
    const DEFAULT_FIELD_MAPPING: Self::FieldMapping = BillingIrpartsurplus5Mapping([
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
    ]);
    const COLUMNS: &'static [&'static str] = &[
        "CONTRACTYEAR",
        "WEEKNO",
        "RESIDUEYEAR",
        "QUARTER",
        "BILLRUNNO",
        "CONTRACTID",
        "PARTICIPANTID",
        "INTERCONNECTORID",
        "FROMREGIONID",
        "TOTALRESIDUES",
        "ADJUSTMENT",
        "LASTCHANGED",
        "ACTUALPAYMENT",
    ];
    type Row<'row> = BillingIrpartsurplus5Row<'row>;
    type FieldMapping = BillingIrpartsurplus5Mapping;
    type PrimaryKey = BillingIrpartsurplus5PrimaryKey;
    fn from_row<'data>(
        row: mmsdm_core::CsvRow<'data>,
        field_mapping: &Self::FieldMapping,
    ) -> mmsdm_core::Result<Self::Row<'data>> {
        Ok(BillingIrpartsurplus5Row {
            contractyear: row
                .get_custom_parsed_at_idx(
                    "contractyear",
                    field_mapping.0[0],
                    mmsdm_core::mms_decimal::parse,
                )?,
            weekno: row
                .get_custom_parsed_at_idx(
                    "weekno",
                    field_mapping.0[1],
                    mmsdm_core::mms_decimal::parse,
                )?,
            residueyear: row
                .get_opt_custom_parsed_at_idx(
                    "residueyear",
                    field_mapping.0[2],
                    mmsdm_core::mms_decimal::parse,
                )?,
            quarter: row
                .get_opt_custom_parsed_at_idx(
                    "quarter",
                    field_mapping.0[3],
                    mmsdm_core::mms_decimal::parse,
                )?,
            billrunno: row
                .get_custom_parsed_at_idx(
                    "billrunno",
                    field_mapping.0[4],
                    mmsdm_core::mms_decimal::parse,
                )?,
            contractid: row.get_range("contractid", field_mapping.0[5])?,
            participantid: row.get_range("participantid", field_mapping.0[6])?,
            interconnectorid: row.get_range("interconnectorid", field_mapping.0[7])?,
            fromregionid: row.get_range("fromregionid", field_mapping.0[8])?,
            totalresidues: row
                .get_opt_custom_parsed_at_idx(
                    "totalresidues",
                    field_mapping.0[9],
                    mmsdm_core::mms_decimal::parse,
                )?,
            adjustment: row
                .get_opt_custom_parsed_at_idx(
                    "adjustment",
                    field_mapping.0[10],
                    mmsdm_core::mms_decimal::parse,
                )?,
            lastchanged: row
                .get_opt_custom_parsed_at_idx(
                    "lastchanged",
                    field_mapping.0[11],
                    mmsdm_core::mms_datetime::parse,
                )?,
            actualpayment: row
                .get_opt_custom_parsed_at_idx(
                    "actualpayment",
                    field_mapping.0[12],
                    mmsdm_core::mms_decimal::parse,
                )?,
            backing_data: row,
        })
    }
    fn field_mapping_from_row<'a>(
        mut row: mmsdm_core::CsvRow<'a>,
    ) -> mmsdm_core::Result<Self::FieldMapping> {
        if !row.is_heading() {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!("Expected an I row but got {row:?}"),
                ),
            );
        }
        let row_key = mmsdm_core::FileKey::from_row(row.borrow())?;
        if !Self::matches_file_key(&row_key, row_key.version) {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!(
                        "Expected a row matching {}.{}.v{} but got {row_key}",
                        Self::DATA_SET_NAME, Self::TABLE_NAME, Self::VERSION
                    ),
                ),
            );
        }
        let mut base_mapping = Self::DEFAULT_FIELD_MAPPING.0;
        for (field_index, field) in Self::COLUMNS.iter().enumerate() {
            base_mapping[field_index] = row
                .iter_fields()
                .position(|f| f == *field)
                .unwrap_or(usize::MAX);
        }
        Ok(BillingIrpartsurplus5Mapping(base_mapping))
    }
    fn matches_file_key(key: &mmsdm_core::FileKey<'_>, version: i32) -> bool {
        version == key.version && Self::DATA_SET_NAME == key.data_set_name()
            && Self::TABLE_NAME == key.table_name()
    }
    fn primary_key(row: &Self::Row<'_>) -> BillingIrpartsurplus5PrimaryKey {
        BillingIrpartsurplus5PrimaryKey {
            billrunno: row.billrunno,
            contractid: row.contractid().to_string(),
            contractyear: row.contractyear,
            fromregionid: row.fromregionid().to_string(),
            interconnectorid: row.interconnectorid().to_string(),
            participantid: row.participantid().to_string(),
            weekno: row.weekno,
        }
    }
    fn partition_value(&self, row: &Self::Row<'_>) -> mmsdm_core::PartitionValue {
        (self.extract_row_partition)(row)
    }
    fn partition_name(&self, row: &Self::Row<'_>) -> alloc::string::String {
        alloc::format!("billing_irpartsurplus_v5_{}", self.partition_value(row))
    }
    fn partition_key(&self) -> mmsdm_core::PartitionKey {
        self.row_partition_key
    }
    fn to_static<'a>(row: &Self::Row<'a>) -> Self::Row<'static> {
        BillingIrpartsurplus5Row {
            contractyear: row.contractyear.clone(),
            weekno: row.weekno.clone(),
            residueyear: row.residueyear.clone(),
            quarter: row.quarter.clone(),
            billrunno: row.billrunno.clone(),
            contractid: row.contractid.clone(),
            participantid: row.participantid.clone(),
            interconnectorid: row.interconnectorid.clone(),
            fromregionid: row.fromregionid.clone(),
            totalresidues: row.totalresidues.clone(),
            adjustment: row.adjustment.clone(),
            lastchanged: row.lastchanged.clone(),
            actualpayment: row.actualpayment.clone(),
            backing_data: row.backing_data.to_owned(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct BillingIrpartsurplus5PrimaryKey {
    pub billrunno: rust_decimal::Decimal,
    pub contractid: alloc::string::String,
    pub contractyear: rust_decimal::Decimal,
    pub fromregionid: alloc::string::String,
    pub interconnectorid: alloc::string::String,
    pub participantid: alloc::string::String,
    pub weekno: rust_decimal::Decimal,
}
impl mmsdm_core::PrimaryKey for BillingIrpartsurplus5PrimaryKey {}
impl<'data> mmsdm_core::CompareWithRow for BillingIrpartsurplus5Row<'data> {
    type Row<'other> = BillingIrpartsurplus5Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractid() == row.contractid()
            && self.contractyear == row.contractyear
            && self.fromregionid() == row.fromregionid()
            && self.interconnectorid() == row.interconnectorid()
            && self.participantid() == row.participantid() && self.weekno == row.weekno
    }
}
impl<'data> mmsdm_core::CompareWithPrimaryKey for BillingIrpartsurplus5Row<'data> {
    type PrimaryKey = BillingIrpartsurplus5PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractid() == key.contractid
            && self.contractyear == key.contractyear
            && self.fromregionid() == key.fromregionid
            && self.interconnectorid() == key.interconnectorid
            && self.participantid() == key.participantid && self.weekno == key.weekno
    }
}
impl<'data> mmsdm_core::CompareWithRow for BillingIrpartsurplus5PrimaryKey {
    type Row<'other> = BillingIrpartsurplus5Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractid == row.contractid()
            && self.contractyear == row.contractyear
            && self.fromregionid == row.fromregionid()
            && self.interconnectorid == row.interconnectorid()
            && self.participantid == row.participantid() && self.weekno == row.weekno
    }
}
impl mmsdm_core::CompareWithPrimaryKey for BillingIrpartsurplus5PrimaryKey {
    type PrimaryKey = BillingIrpartsurplus5PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractid == key.contractid
            && self.contractyear == key.contractyear
            && self.fromregionid == key.fromregionid
            && self.interconnectorid == key.interconnectorid
            && self.participantid == key.participantid && self.weekno == key.weekno
    }
}
#[cfg(feature = "arrow")]
impl mmsdm_core::ArrowSchema for BillingIrpartsurplus5 {
    type Builder = BillingIrpartsurplus5Builder;
    fn schema() -> arrow::datatypes::Schema {
        arrow::datatypes::Schema::new(
            alloc::vec::Vec::from([
                arrow::datatypes::Field::new(
                    "contractyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "weekno",
                    arrow::datatypes::DataType::Decimal128(2, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "residueyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "quarter",
                    arrow::datatypes::DataType::Decimal128(2, 0),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "billrunno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "contractid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "participantid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "interconnectorid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "fromregionid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "totalresidues",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "adjustment",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lastchanged",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "actualpayment",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
            ]),
        )
    }
    fn new_builder() -> Self::Builder {
        BillingIrpartsurplus5Builder {
            contractyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            weekno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(2, 0)),
            residueyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            quarter_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(2, 0)),
            billrunno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            contractid_array: arrow::array::builder::StringBuilder::new(),
            participantid_array: arrow::array::builder::StringBuilder::new(),
            interconnectorid_array: arrow::array::builder::StringBuilder::new(),
            fromregionid_array: arrow::array::builder::StringBuilder::new(),
            totalresidues_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            adjustment_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
            actualpayment_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
        }
    }
    fn append_builder(builder: &mut Self::Builder, row: Self::Row<'_>) {
        builder
            .contractyear_array
            .append_value({
                let mut val = row.contractyear;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .weekno_array
            .append_value({
                let mut val = row.weekno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .residueyear_array
            .append_option({
                row.residueyear
                    .map(|mut val| {
                        val.rescale(0);
                        val.mantissa()
                    })
            });
        builder
            .quarter_array
            .append_option({
                row.quarter
                    .map(|mut val| {
                        val.rescale(0);
                        val.mantissa()
                    })
            });
        builder
            .billrunno_array
            .append_value({
                let mut val = row.billrunno;
                val.rescale(0);
                val.mantissa()
            });
        builder.contractid_array.append_value(row.contractid());
        builder.participantid_array.append_value(row.participantid());
        builder.interconnectorid_array.append_value(row.interconnectorid());
        builder.fromregionid_array.append_value(row.fromregionid());
        builder
            .totalresidues_array
            .append_option({
                row.totalresidues
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .adjustment_array
            .append_option({
                row.adjustment
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .lastchanged_array
            .append_option(row.lastchanged.map(|val| val.and_utc().timestamp_millis()));
        builder
            .actualpayment_array
            .append_option({
                row.actualpayment
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
    }
    fn finalize_builder(
        builder: &mut Self::Builder,
    ) -> mmsdm_core::Result<arrow::array::RecordBatch> {
        arrow::array::RecordBatch::try_new(
                alloc::sync::Arc::new(<Self as mmsdm_core::ArrowSchema>::schema()),
                alloc::vec::Vec::from([
                    alloc::sync::Arc::new(builder.contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.residueyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.quarter_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.contractid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.participantid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.interconnectorid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.fromregionid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.totalresidues_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.adjustment_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lastchanged_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.actualpayment_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                ]),
            )
            .map_err(Into::into)
    }
}
#[cfg(feature = "arrow")]
pub struct BillingIrpartsurplus5Builder {
    contractyear_array: arrow::array::builder::Decimal128Builder,
    weekno_array: arrow::array::builder::Decimal128Builder,
    residueyear_array: arrow::array::builder::Decimal128Builder,
    quarter_array: arrow::array::builder::Decimal128Builder,
    billrunno_array: arrow::array::builder::Decimal128Builder,
    contractid_array: arrow::array::builder::StringBuilder,
    participantid_array: arrow::array::builder::StringBuilder,
    interconnectorid_array: arrow::array::builder::StringBuilder,
    fromregionid_array: arrow::array::builder::StringBuilder,
    totalresidues_array: arrow::array::builder::Decimal128Builder,
    adjustment_array: arrow::array::builder::Decimal128Builder,
    lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder,
    actualpayment_array: arrow::array::builder::Decimal128Builder,
}
pub struct BillingIrpartsurplussum7 {
    extract_row_partition: alloc::boxed::Box<
        dyn Fn(
            &BillingIrpartsurplussum7Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    >,
    row_partition_key: mmsdm_core::PartitionKey,
}
impl BillingIrpartsurplussum7 {
    pub fn new(
        row_partition_key: mmsdm_core::PartitionKey,
        func: impl Fn(
            &<Self as mmsdm_core::GetTable>::Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    ) -> Self {
        Self {
            extract_row_partition: alloc::boxed::Box::new(func),
            row_partition_key,
        }
    }
}
pub struct BillingIrpartsurplussum7Mapping([usize; 16]);
/// # Summary
///
/// ## BILLINGIRPARTSURPLUSSUM
///  _BILLINGIRPARTSURPLUSSUM supports the Settlements Residue Auction, by showing the weekly billing SRA distribution and associated fees to Auction participants._
///
/// * Data Set Name: Billing
/// * File Name: Irpartsurplussum
/// * Data Version: 7
///
/// # Description
///  BILLINGIRPARTSURPLUSSUM data is confidential to the relevant participant. Source BILLINGIRPARTSURPLUSSUM is populated by the posting of a billing run where the participant has purchased auction units relating to that billing run. Volume An indicative maximum is 16 records inserted per billing run, or 166 records inserted per week.
///
///
///
/// # Primary Key Columns
///
/// * BILLRUNNO
/// * CONTRACTYEAR
/// * FROMREGIONID
/// * INTERCONNECTORID
/// * PARTICIPANTID
/// * QUARTER
/// * RESIDUEYEAR
/// * WEEKNO
#[derive(Debug, PartialEq, Eq)]
pub struct BillingIrpartsurplussum7Row<'data> {
    /// SRA Contracted Year (calendar year)
    pub contractyear: rust_decimal::Decimal,
    /// Week no within the contract year. Week no 1 is the week containing 1st January
    pub weekno: rust_decimal::Decimal,
    /// Year of the Residue Contract; may differ from the calendar year at week 1.
    pub residueyear: rust_decimal::Decimal,
    /// Residue Contract Quarter
    pub quarter: rust_decimal::Decimal,
    /// The sequential number of a billing run
    pub billrunno: rust_decimal::Decimal,
    /// Contracted Interconnector
    pub interconnectorid: core::ops::Range<usize>,
    /// Nominated source region for Interconnector
    pub fromregionid: core::ops::Range<usize>,
    /// Unique participant identifier
    pub participantid: core::ops::Range<usize>,
    /// Total residue amount allocated to participant
    pub totalsurplus: Option<rust_decimal::Decimal>,
    /// Total auction fees payable in this week (negative amount). If AUCTIONFEES + AUCTIONFEES_GST &gt;= TOTALSURPLUS then ACTUALPAYMENT is zero.
    pub auctionfees: Option<rust_decimal::Decimal>,
    /// Net payment to participant, including auction fees
    pub actualpayment: Option<rust_decimal::Decimal>,
    /// The GST amount on the auction fees, always being zero.
    pub auctionfees_gst: Option<rust_decimal::Decimal>,
    /// Date and time this record was last modified
    pub lastchanged: Option<chrono::NaiveDateTime>,
    /// The CSP derogation amount applied as an adjustment to SRA.
    pub csp_derogation_amount: Option<rust_decimal::Decimal>,
    /// The SRA amount unadjusted by CSP.
    pub unadjusted_irsr: Option<rust_decimal::Decimal>,
    /// The adjusted total Auction fees for the Directional Interconnector. Calculated as the amount of the total fees due from the SRA Auction Participant, pro-rated based on the total surplus for each Directional Interconnector the SRA Auction Participant contracted.
    pub auctionfees_totalgross_adj: Option<rust_decimal::Decimal>,
    backing_data: mmsdm_core::CsvRow<'data>,
}
impl<'data> BillingIrpartsurplussum7Row<'data> {
    pub fn interconnectorid(&self) -> &str {
        core::ops::Index::index(
            self.backing_data.as_slice(),
            self.interconnectorid.clone(),
        )
    }
    pub fn fromregionid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.fromregionid.clone())
    }
    pub fn participantid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.participantid.clone())
    }
}
impl mmsdm_core::GetTable for BillingIrpartsurplussum7 {
    const VERSION: i32 = 7;
    const DATA_SET_NAME: &'static str = "BILLING";
    const TABLE_NAME: &'static str = "IRPARTSURPLUSSUM";
    const DEFAULT_FIELD_MAPPING: Self::FieldMapping = BillingIrpartsurplussum7Mapping([
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
    ]);
    const COLUMNS: &'static [&'static str] = &[
        "CONTRACTYEAR",
        "WEEKNO",
        "RESIDUEYEAR",
        "QUARTER",
        "BILLRUNNO",
        "INTERCONNECTORID",
        "FROMREGIONID",
        "PARTICIPANTID",
        "TOTALSURPLUS",
        "AUCTIONFEES",
        "ACTUALPAYMENT",
        "AUCTIONFEES_GST",
        "LASTCHANGED",
        "CSP_DEROGATION_AMOUNT",
        "UNADJUSTED_IRSR",
        "AUCTIONFEES_TOTALGROSS_ADJ",
    ];
    type Row<'row> = BillingIrpartsurplussum7Row<'row>;
    type FieldMapping = BillingIrpartsurplussum7Mapping;
    type PrimaryKey = BillingIrpartsurplussum7PrimaryKey;
    fn from_row<'data>(
        row: mmsdm_core::CsvRow<'data>,
        field_mapping: &Self::FieldMapping,
    ) -> mmsdm_core::Result<Self::Row<'data>> {
        Ok(BillingIrpartsurplussum7Row {
            contractyear: row
                .get_custom_parsed_at_idx(
                    "contractyear",
                    field_mapping.0[0],
                    mmsdm_core::mms_decimal::parse,
                )?,
            weekno: row
                .get_custom_parsed_at_idx(
                    "weekno",
                    field_mapping.0[1],
                    mmsdm_core::mms_decimal::parse,
                )?,
            residueyear: row
                .get_custom_parsed_at_idx(
                    "residueyear",
                    field_mapping.0[2],
                    mmsdm_core::mms_decimal::parse,
                )?,
            quarter: row
                .get_custom_parsed_at_idx(
                    "quarter",
                    field_mapping.0[3],
                    mmsdm_core::mms_decimal::parse,
                )?,
            billrunno: row
                .get_custom_parsed_at_idx(
                    "billrunno",
                    field_mapping.0[4],
                    mmsdm_core::mms_decimal::parse,
                )?,
            interconnectorid: row.get_range("interconnectorid", field_mapping.0[5])?,
            fromregionid: row.get_range("fromregionid", field_mapping.0[6])?,
            participantid: row.get_range("participantid", field_mapping.0[7])?,
            totalsurplus: row
                .get_opt_custom_parsed_at_idx(
                    "totalsurplus",
                    field_mapping.0[8],
                    mmsdm_core::mms_decimal::parse,
                )?,
            auctionfees: row
                .get_opt_custom_parsed_at_idx(
                    "auctionfees",
                    field_mapping.0[9],
                    mmsdm_core::mms_decimal::parse,
                )?,
            actualpayment: row
                .get_opt_custom_parsed_at_idx(
                    "actualpayment",
                    field_mapping.0[10],
                    mmsdm_core::mms_decimal::parse,
                )?,
            auctionfees_gst: row
                .get_opt_custom_parsed_at_idx(
                    "auctionfees_gst",
                    field_mapping.0[11],
                    mmsdm_core::mms_decimal::parse,
                )?,
            lastchanged: row
                .get_opt_custom_parsed_at_idx(
                    "lastchanged",
                    field_mapping.0[12],
                    mmsdm_core::mms_datetime::parse,
                )?,
            csp_derogation_amount: row
                .get_opt_custom_parsed_at_idx(
                    "csp_derogation_amount",
                    field_mapping.0[13],
                    mmsdm_core::mms_decimal::parse,
                )?,
            unadjusted_irsr: row
                .get_opt_custom_parsed_at_idx(
                    "unadjusted_irsr",
                    field_mapping.0[14],
                    mmsdm_core::mms_decimal::parse,
                )?,
            auctionfees_totalgross_adj: row
                .get_opt_custom_parsed_at_idx(
                    "auctionfees_totalgross_adj",
                    field_mapping.0[15],
                    mmsdm_core::mms_decimal::parse,
                )?,
            backing_data: row,
        })
    }
    fn field_mapping_from_row<'a>(
        mut row: mmsdm_core::CsvRow<'a>,
    ) -> mmsdm_core::Result<Self::FieldMapping> {
        if !row.is_heading() {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!("Expected an I row but got {row:?}"),
                ),
            );
        }
        let row_key = mmsdm_core::FileKey::from_row(row.borrow())?;
        if !Self::matches_file_key(&row_key, row_key.version) {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!(
                        "Expected a row matching {}.{}.v{} but got {row_key}",
                        Self::DATA_SET_NAME, Self::TABLE_NAME, Self::VERSION
                    ),
                ),
            );
        }
        let mut base_mapping = Self::DEFAULT_FIELD_MAPPING.0;
        for (field_index, field) in Self::COLUMNS.iter().enumerate() {
            base_mapping[field_index] = row
                .iter_fields()
                .position(|f| f == *field)
                .unwrap_or(usize::MAX);
        }
        Ok(BillingIrpartsurplussum7Mapping(base_mapping))
    }
    fn matches_file_key(key: &mmsdm_core::FileKey<'_>, version: i32) -> bool {
        version == key.version && Self::DATA_SET_NAME == key.data_set_name()
            && Self::TABLE_NAME == key.table_name()
    }
    fn primary_key(row: &Self::Row<'_>) -> BillingIrpartsurplussum7PrimaryKey {
        BillingIrpartsurplussum7PrimaryKey {
            billrunno: row.billrunno,
            contractyear: row.contractyear,
            fromregionid: row.fromregionid().to_string(),
            interconnectorid: row.interconnectorid().to_string(),
            participantid: row.participantid().to_string(),
            quarter: row.quarter,
            residueyear: row.residueyear,
            weekno: row.weekno,
        }
    }
    fn partition_value(&self, row: &Self::Row<'_>) -> mmsdm_core::PartitionValue {
        (self.extract_row_partition)(row)
    }
    fn partition_name(&self, row: &Self::Row<'_>) -> alloc::string::String {
        alloc::format!("billing_irpartsurplussum_v7_{}", self.partition_value(row))
    }
    fn partition_key(&self) -> mmsdm_core::PartitionKey {
        self.row_partition_key
    }
    fn to_static<'a>(row: &Self::Row<'a>) -> Self::Row<'static> {
        BillingIrpartsurplussum7Row {
            contractyear: row.contractyear.clone(),
            weekno: row.weekno.clone(),
            residueyear: row.residueyear.clone(),
            quarter: row.quarter.clone(),
            billrunno: row.billrunno.clone(),
            interconnectorid: row.interconnectorid.clone(),
            fromregionid: row.fromregionid.clone(),
            participantid: row.participantid.clone(),
            totalsurplus: row.totalsurplus.clone(),
            auctionfees: row.auctionfees.clone(),
            actualpayment: row.actualpayment.clone(),
            auctionfees_gst: row.auctionfees_gst.clone(),
            lastchanged: row.lastchanged.clone(),
            csp_derogation_amount: row.csp_derogation_amount.clone(),
            unadjusted_irsr: row.unadjusted_irsr.clone(),
            auctionfees_totalgross_adj: row.auctionfees_totalgross_adj.clone(),
            backing_data: row.backing_data.to_owned(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct BillingIrpartsurplussum7PrimaryKey {
    pub billrunno: rust_decimal::Decimal,
    pub contractyear: rust_decimal::Decimal,
    pub fromregionid: alloc::string::String,
    pub interconnectorid: alloc::string::String,
    pub participantid: alloc::string::String,
    pub quarter: rust_decimal::Decimal,
    pub residueyear: rust_decimal::Decimal,
    pub weekno: rust_decimal::Decimal,
}
impl mmsdm_core::PrimaryKey for BillingIrpartsurplussum7PrimaryKey {}
impl<'data> mmsdm_core::CompareWithRow for BillingIrpartsurplussum7Row<'data> {
    type Row<'other> = BillingIrpartsurplussum7Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.fromregionid() == row.fromregionid()
            && self.interconnectorid() == row.interconnectorid()
            && self.participantid() == row.participantid() && self.quarter == row.quarter
            && self.residueyear == row.residueyear && self.weekno == row.weekno
    }
}
impl<'data> mmsdm_core::CompareWithPrimaryKey for BillingIrpartsurplussum7Row<'data> {
    type PrimaryKey = BillingIrpartsurplussum7PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.fromregionid() == key.fromregionid
            && self.interconnectorid() == key.interconnectorid
            && self.participantid() == key.participantid && self.quarter == key.quarter
            && self.residueyear == key.residueyear && self.weekno == key.weekno
    }
}
impl<'data> mmsdm_core::CompareWithRow for BillingIrpartsurplussum7PrimaryKey {
    type Row<'other> = BillingIrpartsurplussum7Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.fromregionid == row.fromregionid()
            && self.interconnectorid == row.interconnectorid()
            && self.participantid == row.participantid() && self.quarter == row.quarter
            && self.residueyear == row.residueyear && self.weekno == row.weekno
    }
}
impl mmsdm_core::CompareWithPrimaryKey for BillingIrpartsurplussum7PrimaryKey {
    type PrimaryKey = BillingIrpartsurplussum7PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.fromregionid == key.fromregionid
            && self.interconnectorid == key.interconnectorid
            && self.participantid == key.participantid && self.quarter == key.quarter
            && self.residueyear == key.residueyear && self.weekno == key.weekno
    }
}
#[cfg(feature = "arrow")]
impl mmsdm_core::ArrowSchema for BillingIrpartsurplussum7 {
    type Builder = BillingIrpartsurplussum7Builder;
    fn schema() -> arrow::datatypes::Schema {
        arrow::datatypes::Schema::new(
            alloc::vec::Vec::from([
                arrow::datatypes::Field::new(
                    "contractyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "weekno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "residueyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "quarter",
                    arrow::datatypes::DataType::Decimal128(2, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "billrunno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "interconnectorid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "fromregionid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "participantid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "totalsurplus",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "auctionfees",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "actualpayment",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "auctionfees_gst",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lastchanged",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "csp_derogation_amount",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "unadjusted_irsr",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "auctionfees_totalgross_adj",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
            ]),
        )
    }
    fn new_builder() -> Self::Builder {
        BillingIrpartsurplussum7Builder {
            contractyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            weekno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            residueyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            quarter_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(2, 0)),
            billrunno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            interconnectorid_array: arrow::array::builder::StringBuilder::new(),
            fromregionid_array: arrow::array::builder::StringBuilder::new(),
            participantid_array: arrow::array::builder::StringBuilder::new(),
            totalsurplus_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            auctionfees_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            actualpayment_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            auctionfees_gst_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
            csp_derogation_amount_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            unadjusted_irsr_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            auctionfees_totalgross_adj_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
        }
    }
    fn append_builder(builder: &mut Self::Builder, row: Self::Row<'_>) {
        builder
            .contractyear_array
            .append_value({
                let mut val = row.contractyear;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .weekno_array
            .append_value({
                let mut val = row.weekno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .residueyear_array
            .append_value({
                let mut val = row.residueyear;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .quarter_array
            .append_value({
                let mut val = row.quarter;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .billrunno_array
            .append_value({
                let mut val = row.billrunno;
                val.rescale(0);
                val.mantissa()
            });
        builder.interconnectorid_array.append_value(row.interconnectorid());
        builder.fromregionid_array.append_value(row.fromregionid());
        builder.participantid_array.append_value(row.participantid());
        builder
            .totalsurplus_array
            .append_option({
                row.totalsurplus
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .auctionfees_array
            .append_option({
                row.auctionfees
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .actualpayment_array
            .append_option({
                row.actualpayment
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .auctionfees_gst_array
            .append_option({
                row.auctionfees_gst
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .lastchanged_array
            .append_option(row.lastchanged.map(|val| val.and_utc().timestamp_millis()));
        builder
            .csp_derogation_amount_array
            .append_option({
                row.csp_derogation_amount
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .unadjusted_irsr_array
            .append_option({
                row.unadjusted_irsr
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .auctionfees_totalgross_adj_array
            .append_option({
                row.auctionfees_totalgross_adj
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
    }
    fn finalize_builder(
        builder: &mut Self::Builder,
    ) -> mmsdm_core::Result<arrow::array::RecordBatch> {
        arrow::array::RecordBatch::try_new(
                alloc::sync::Arc::new(<Self as mmsdm_core::ArrowSchema>::schema()),
                alloc::vec::Vec::from([
                    alloc::sync::Arc::new(builder.contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.residueyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.quarter_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.interconnectorid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.fromregionid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.participantid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.totalsurplus_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.auctionfees_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.actualpayment_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.auctionfees_gst_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lastchanged_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.csp_derogation_amount_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.unadjusted_irsr_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(
                        builder.auctionfees_totalgross_adj_array.finish(),
                    ) as alloc::sync::Arc<dyn arrow::array::Array>,
                ]),
            )
            .map_err(Into::into)
    }
}
#[cfg(feature = "arrow")]
pub struct BillingIrpartsurplussum7Builder {
    contractyear_array: arrow::array::builder::Decimal128Builder,
    weekno_array: arrow::array::builder::Decimal128Builder,
    residueyear_array: arrow::array::builder::Decimal128Builder,
    quarter_array: arrow::array::builder::Decimal128Builder,
    billrunno_array: arrow::array::builder::Decimal128Builder,
    interconnectorid_array: arrow::array::builder::StringBuilder,
    fromregionid_array: arrow::array::builder::StringBuilder,
    participantid_array: arrow::array::builder::StringBuilder,
    totalsurplus_array: arrow::array::builder::Decimal128Builder,
    auctionfees_array: arrow::array::builder::Decimal128Builder,
    actualpayment_array: arrow::array::builder::Decimal128Builder,
    auctionfees_gst_array: arrow::array::builder::Decimal128Builder,
    lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder,
    csp_derogation_amount_array: arrow::array::builder::Decimal128Builder,
    unadjusted_irsr_array: arrow::array::builder::Decimal128Builder,
    auctionfees_totalgross_adj_array: arrow::array::builder::Decimal128Builder,
}
pub struct BillingPrioradjustments5 {
    extract_row_partition: alloc::boxed::Box<
        dyn Fn(
            &BillingPrioradjustments5Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    >,
    row_partition_key: mmsdm_core::PartitionKey,
}
impl BillingPrioradjustments5 {
    pub fn new(
        row_partition_key: mmsdm_core::PartitionKey,
        func: impl Fn(
            &<Self as mmsdm_core::GetTable>::Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    ) -> Self {
        Self {
            extract_row_partition: alloc::boxed::Box::new(func),
            row_partition_key,
        }
    }
}
pub struct BillingPrioradjustments5Mapping([usize; 16]);
/// # Summary
///
/// ## BILLINGPRIORADJUSTMENTS
///  _BILLINGPRIORADJUSTMENTS sets out prior period adjustments and associated interest inserted in subsequent Final Statements arising from Revision Statement postings._
///
/// * Data Set Name: Billing
/// * File Name: Prioradjustments
/// * Data Version: 5
///
/// # Description
///  BILLINGPRIORADJUSTMENTS data is confidential to the relevant participant. Source BILLINGPRIORADJUSTMENTS is populated on the posting of a Final billing run only. Volume Approximately two records inserted per week. Note Actual adjustment payable is ADJAMOUNT - PERAMOUNT + INTEREST AMOUNT.
///
///
///
/// # Primary Key Columns
///
/// * ADJBILLRUNNO
/// * ADJCONTRACTYEAR
/// * ADJWEEKNO
/// * BILLRUNNO
/// * CONTRACTYEAR
/// * PARTICIPANTID
/// * WEEKNO
#[derive(Debug, PartialEq, Eq)]
pub struct BillingPrioradjustments5Row<'data> {
    /// Settlement year.
    pub contractyear: rust_decimal::Decimal,
    /// Settlement week number.
    pub weekno: rust_decimal::Decimal,
    /// Billing run number.
    pub billrunno: rust_decimal::Decimal,
    /// ContractYear of the posted revision statement inserted to the Final Statement
    pub adjcontractyear: rust_decimal::Decimal,
    /// WeekNo of the posted revision statement inserted to the Final Statement
    pub adjweekno: rust_decimal::Decimal,
    /// Bill run number of the posted revision statement inserted to the Final Statement
    pub adjbillrunno: rust_decimal::Decimal,
    /// Participant ID
    pub participantid: core::ops::Range<usize>,
    /// Statement total of the previous posted revision statement inserted to the Final Statement.
    pub prevamount: Option<rust_decimal::Decimal>,
    /// Adjusted amount.
    pub adjamount: Option<rust_decimal::Decimal>,
    /// Interest rate applied to the revision adjustment
    pub irn: Option<rust_decimal::Decimal>,
    /// unused; always null
    pub irp: Option<rust_decimal::Decimal>,
    /// Interest amount.
    pub interestamount: Option<rust_decimal::Decimal>,
    /// Last changed.
    pub lastchanged: Option<chrono::NaiveDateTime>,
    /// unused; always null
    pub irsr_prevamount: Option<rust_decimal::Decimal>,
    /// unused; always null
    pub irsr_adjamount: Option<rust_decimal::Decimal>,
    /// unused; always null
    pub irsr_interestamount: Option<rust_decimal::Decimal>,
    backing_data: mmsdm_core::CsvRow<'data>,
}
impl<'data> BillingPrioradjustments5Row<'data> {
    pub fn participantid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.participantid.clone())
    }
}
impl mmsdm_core::GetTable for BillingPrioradjustments5 {
    const VERSION: i32 = 5;
    const DATA_SET_NAME: &'static str = "BILLING";
    const TABLE_NAME: &'static str = "PRIORADJUSTMENTS";
    const DEFAULT_FIELD_MAPPING: Self::FieldMapping = BillingPrioradjustments5Mapping([
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
    ]);
    const COLUMNS: &'static [&'static str] = &[
        "CONTRACTYEAR",
        "WEEKNO",
        "BILLRUNNO",
        "ADJCONTRACTYEAR",
        "ADJWEEKNO",
        "ADJBILLRUNNO",
        "PARTICIPANTID",
        "PREVAMOUNT",
        "ADJAMOUNT",
        "IRN",
        "IRP",
        "INTERESTAMOUNT",
        "LASTCHANGED",
        "IRSR_PREVAMOUNT",
        "IRSR_ADJAMOUNT",
        "IRSR_INTERESTAMOUNT",
    ];
    type Row<'row> = BillingPrioradjustments5Row<'row>;
    type FieldMapping = BillingPrioradjustments5Mapping;
    type PrimaryKey = BillingPrioradjustments5PrimaryKey;
    fn from_row<'data>(
        row: mmsdm_core::CsvRow<'data>,
        field_mapping: &Self::FieldMapping,
    ) -> mmsdm_core::Result<Self::Row<'data>> {
        Ok(BillingPrioradjustments5Row {
            contractyear: row
                .get_custom_parsed_at_idx(
                    "contractyear",
                    field_mapping.0[0],
                    mmsdm_core::mms_decimal::parse,
                )?,
            weekno: row
                .get_custom_parsed_at_idx(
                    "weekno",
                    field_mapping.0[1],
                    mmsdm_core::mms_decimal::parse,
                )?,
            billrunno: row
                .get_custom_parsed_at_idx(
                    "billrunno",
                    field_mapping.0[2],
                    mmsdm_core::mms_decimal::parse,
                )?,
            adjcontractyear: row
                .get_custom_parsed_at_idx(
                    "adjcontractyear",
                    field_mapping.0[3],
                    mmsdm_core::mms_decimal::parse,
                )?,
            adjweekno: row
                .get_custom_parsed_at_idx(
                    "adjweekno",
                    field_mapping.0[4],
                    mmsdm_core::mms_decimal::parse,
                )?,
            adjbillrunno: row
                .get_custom_parsed_at_idx(
                    "adjbillrunno",
                    field_mapping.0[5],
                    mmsdm_core::mms_decimal::parse,
                )?,
            participantid: row.get_range("participantid", field_mapping.0[6])?,
            prevamount: row
                .get_opt_custom_parsed_at_idx(
                    "prevamount",
                    field_mapping.0[7],
                    mmsdm_core::mms_decimal::parse,
                )?,
            adjamount: row
                .get_opt_custom_parsed_at_idx(
                    "adjamount",
                    field_mapping.0[8],
                    mmsdm_core::mms_decimal::parse,
                )?,
            irn: row
                .get_opt_custom_parsed_at_idx(
                    "irn",
                    field_mapping.0[9],
                    mmsdm_core::mms_decimal::parse,
                )?,
            irp: row
                .get_opt_custom_parsed_at_idx(
                    "irp",
                    field_mapping.0[10],
                    mmsdm_core::mms_decimal::parse,
                )?,
            interestamount: row
                .get_opt_custom_parsed_at_idx(
                    "interestamount",
                    field_mapping.0[11],
                    mmsdm_core::mms_decimal::parse,
                )?,
            lastchanged: row
                .get_opt_custom_parsed_at_idx(
                    "lastchanged",
                    field_mapping.0[12],
                    mmsdm_core::mms_datetime::parse,
                )?,
            irsr_prevamount: row
                .get_opt_custom_parsed_at_idx(
                    "irsr_prevamount",
                    field_mapping.0[13],
                    mmsdm_core::mms_decimal::parse,
                )?,
            irsr_adjamount: row
                .get_opt_custom_parsed_at_idx(
                    "irsr_adjamount",
                    field_mapping.0[14],
                    mmsdm_core::mms_decimal::parse,
                )?,
            irsr_interestamount: row
                .get_opt_custom_parsed_at_idx(
                    "irsr_interestamount",
                    field_mapping.0[15],
                    mmsdm_core::mms_decimal::parse,
                )?,
            backing_data: row,
        })
    }
    fn field_mapping_from_row<'a>(
        mut row: mmsdm_core::CsvRow<'a>,
    ) -> mmsdm_core::Result<Self::FieldMapping> {
        if !row.is_heading() {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!("Expected an I row but got {row:?}"),
                ),
            );
        }
        let row_key = mmsdm_core::FileKey::from_row(row.borrow())?;
        if !Self::matches_file_key(&row_key, row_key.version) {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!(
                        "Expected a row matching {}.{}.v{} but got {row_key}",
                        Self::DATA_SET_NAME, Self::TABLE_NAME, Self::VERSION
                    ),
                ),
            );
        }
        let mut base_mapping = Self::DEFAULT_FIELD_MAPPING.0;
        for (field_index, field) in Self::COLUMNS.iter().enumerate() {
            base_mapping[field_index] = row
                .iter_fields()
                .position(|f| f == *field)
                .unwrap_or(usize::MAX);
        }
        Ok(BillingPrioradjustments5Mapping(base_mapping))
    }
    fn matches_file_key(key: &mmsdm_core::FileKey<'_>, version: i32) -> bool {
        version == key.version && Self::DATA_SET_NAME == key.data_set_name()
            && Self::TABLE_NAME == key.table_name()
    }
    fn primary_key(row: &Self::Row<'_>) -> BillingPrioradjustments5PrimaryKey {
        BillingPrioradjustments5PrimaryKey {
            adjbillrunno: row.adjbillrunno,
            adjcontractyear: row.adjcontractyear,
            adjweekno: row.adjweekno,
            billrunno: row.billrunno,
            contractyear: row.contractyear,
            participantid: row.participantid().to_string(),
            weekno: row.weekno,
        }
    }
    fn partition_value(&self, row: &Self::Row<'_>) -> mmsdm_core::PartitionValue {
        (self.extract_row_partition)(row)
    }
    fn partition_name(&self, row: &Self::Row<'_>) -> alloc::string::String {
        alloc::format!("billing_prioradjustments_v5_{}", self.partition_value(row))
    }
    fn partition_key(&self) -> mmsdm_core::PartitionKey {
        self.row_partition_key
    }
    fn to_static<'a>(row: &Self::Row<'a>) -> Self::Row<'static> {
        BillingPrioradjustments5Row {
            contractyear: row.contractyear.clone(),
            weekno: row.weekno.clone(),
            billrunno: row.billrunno.clone(),
            adjcontractyear: row.adjcontractyear.clone(),
            adjweekno: row.adjweekno.clone(),
            adjbillrunno: row.adjbillrunno.clone(),
            participantid: row.participantid.clone(),
            prevamount: row.prevamount.clone(),
            adjamount: row.adjamount.clone(),
            irn: row.irn.clone(),
            irp: row.irp.clone(),
            interestamount: row.interestamount.clone(),
            lastchanged: row.lastchanged.clone(),
            irsr_prevamount: row.irsr_prevamount.clone(),
            irsr_adjamount: row.irsr_adjamount.clone(),
            irsr_interestamount: row.irsr_interestamount.clone(),
            backing_data: row.backing_data.to_owned(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct BillingPrioradjustments5PrimaryKey {
    pub adjbillrunno: rust_decimal::Decimal,
    pub adjcontractyear: rust_decimal::Decimal,
    pub adjweekno: rust_decimal::Decimal,
    pub billrunno: rust_decimal::Decimal,
    pub contractyear: rust_decimal::Decimal,
    pub participantid: alloc::string::String,
    pub weekno: rust_decimal::Decimal,
}
impl mmsdm_core::PrimaryKey for BillingPrioradjustments5PrimaryKey {}
impl<'data> mmsdm_core::CompareWithRow for BillingPrioradjustments5Row<'data> {
    type Row<'other> = BillingPrioradjustments5Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.adjbillrunno == row.adjbillrunno
            && self.adjcontractyear == row.adjcontractyear
            && self.adjweekno == row.adjweekno && self.billrunno == row.billrunno
            && self.contractyear == row.contractyear
            && self.participantid() == row.participantid() && self.weekno == row.weekno
    }
}
impl<'data> mmsdm_core::CompareWithPrimaryKey for BillingPrioradjustments5Row<'data> {
    type PrimaryKey = BillingPrioradjustments5PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.adjbillrunno == key.adjbillrunno
            && self.adjcontractyear == key.adjcontractyear
            && self.adjweekno == key.adjweekno && self.billrunno == key.billrunno
            && self.contractyear == key.contractyear
            && self.participantid() == key.participantid && self.weekno == key.weekno
    }
}
impl<'data> mmsdm_core::CompareWithRow for BillingPrioradjustments5PrimaryKey {
    type Row<'other> = BillingPrioradjustments5Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.adjbillrunno == row.adjbillrunno
            && self.adjcontractyear == row.adjcontractyear
            && self.adjweekno == row.adjweekno && self.billrunno == row.billrunno
            && self.contractyear == row.contractyear
            && self.participantid == row.participantid() && self.weekno == row.weekno
    }
}
impl mmsdm_core::CompareWithPrimaryKey for BillingPrioradjustments5PrimaryKey {
    type PrimaryKey = BillingPrioradjustments5PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.adjbillrunno == key.adjbillrunno
            && self.adjcontractyear == key.adjcontractyear
            && self.adjweekno == key.adjweekno && self.billrunno == key.billrunno
            && self.contractyear == key.contractyear
            && self.participantid == key.participantid && self.weekno == key.weekno
    }
}
#[cfg(feature = "arrow")]
impl mmsdm_core::ArrowSchema for BillingPrioradjustments5 {
    type Builder = BillingPrioradjustments5Builder;
    fn schema() -> arrow::datatypes::Schema {
        arrow::datatypes::Schema::new(
            alloc::vec::Vec::from([
                arrow::datatypes::Field::new(
                    "contractyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "weekno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "billrunno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "adjcontractyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "adjweekno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "adjbillrunno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "participantid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "prevamount",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "adjamount",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "irn",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "irp",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "interestamount",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lastchanged",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "irsr_prevamount",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "irsr_adjamount",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "irsr_interestamount",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
            ]),
        )
    }
    fn new_builder() -> Self::Builder {
        BillingPrioradjustments5Builder {
            contractyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            weekno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            billrunno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            adjcontractyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            adjweekno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            adjbillrunno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            participantid_array: arrow::array::builder::StringBuilder::new(),
            prevamount_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            adjamount_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            irn_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            irp_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            interestamount_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
            irsr_prevamount_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            irsr_adjamount_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            irsr_interestamount_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
        }
    }
    fn append_builder(builder: &mut Self::Builder, row: Self::Row<'_>) {
        builder
            .contractyear_array
            .append_value({
                let mut val = row.contractyear;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .weekno_array
            .append_value({
                let mut val = row.weekno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .billrunno_array
            .append_value({
                let mut val = row.billrunno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .adjcontractyear_array
            .append_value({
                let mut val = row.adjcontractyear;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .adjweekno_array
            .append_value({
                let mut val = row.adjweekno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .adjbillrunno_array
            .append_value({
                let mut val = row.adjbillrunno;
                val.rescale(0);
                val.mantissa()
            });
        builder.participantid_array.append_value(row.participantid());
        builder
            .prevamount_array
            .append_option({
                row.prevamount
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .adjamount_array
            .append_option({
                row.adjamount
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .irn_array
            .append_option({
                row.irn
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .irp_array
            .append_option({
                row.irp
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .interestamount_array
            .append_option({
                row.interestamount
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .lastchanged_array
            .append_option(row.lastchanged.map(|val| val.and_utc().timestamp_millis()));
        builder
            .irsr_prevamount_array
            .append_option({
                row.irsr_prevamount
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .irsr_adjamount_array
            .append_option({
                row.irsr_adjamount
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .irsr_interestamount_array
            .append_option({
                row.irsr_interestamount
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
    }
    fn finalize_builder(
        builder: &mut Self::Builder,
    ) -> mmsdm_core::Result<arrow::array::RecordBatch> {
        arrow::array::RecordBatch::try_new(
                alloc::sync::Arc::new(<Self as mmsdm_core::ArrowSchema>::schema()),
                alloc::vec::Vec::from([
                    alloc::sync::Arc::new(builder.contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.adjcontractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.adjweekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.adjbillrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.participantid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.prevamount_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.adjamount_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.irn_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.irp_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.interestamount_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lastchanged_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.irsr_prevamount_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.irsr_adjamount_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.irsr_interestamount_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                ]),
            )
            .map_err(Into::into)
    }
}
#[cfg(feature = "arrow")]
pub struct BillingPrioradjustments5Builder {
    contractyear_array: arrow::array::builder::Decimal128Builder,
    weekno_array: arrow::array::builder::Decimal128Builder,
    billrunno_array: arrow::array::builder::Decimal128Builder,
    adjcontractyear_array: arrow::array::builder::Decimal128Builder,
    adjweekno_array: arrow::array::builder::Decimal128Builder,
    adjbillrunno_array: arrow::array::builder::Decimal128Builder,
    participantid_array: arrow::array::builder::StringBuilder,
    prevamount_array: arrow::array::builder::Decimal128Builder,
    adjamount_array: arrow::array::builder::Decimal128Builder,
    irn_array: arrow::array::builder::Decimal128Builder,
    irp_array: arrow::array::builder::Decimal128Builder,
    interestamount_array: arrow::array::builder::Decimal128Builder,
    lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder,
    irsr_prevamount_array: arrow::array::builder::Decimal128Builder,
    irsr_adjamount_array: arrow::array::builder::Decimal128Builder,
    irsr_interestamount_array: arrow::array::builder::Decimal128Builder,
}
pub struct BillingRealloc5 {
    extract_row_partition: alloc::boxed::Box<
        dyn Fn(
            &BillingRealloc5Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    >,
    row_partition_key: mmsdm_core::PartitionKey,
}
impl BillingRealloc5 {
    pub fn new(
        row_partition_key: mmsdm_core::PartitionKey,
        func: impl Fn(
            &<Self as mmsdm_core::GetTable>::Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    ) -> Self {
        Self {
            extract_row_partition: alloc::boxed::Box::new(func),
            row_partition_key,
        }
    }
}
pub struct BillingRealloc5Mapping([usize; 7]);
/// # Summary
///
/// ## BILLINGREALLOC
///  _BILLINGREALLOC shows reallocation contract values in each billing run, where participants have used reallocations._
///
/// * Data Set Name: Billing
/// * File Name: Realloc
/// * Data Version: 5
///
/// # Description
///  BILLINGREALLOC data is confidential to the relevant participant. Source BILLINGREALLOC is populated by the posting of a billing run. Volume An indicative maximum is two records inserted per billing run, or 22 records inserted per week.
///
///
///
/// # Primary Key Columns
///
/// * BILLRUNNO
/// * CONTRACTYEAR
/// * COUNTERPARTY
/// * PARTICIPANTID
/// * WEEKNO
#[derive(Debug, PartialEq, Eq)]
pub struct BillingRealloc5Row<'data> {
    /// AEMO Contract Year number starting in week containing 1st January
    pub contractyear: rust_decimal::Decimal,
    /// Week no within the contract year. Week no 1 is the week containing 1st January
    pub weekno: rust_decimal::Decimal,
    /// Unique run no within a given contract year and week no
    pub billrunno: rust_decimal::Decimal,
    /// Unique participant identifier
    pub participantid: core::ops::Range<usize>,
    /// Participant who is the counter party to this contract
    pub counterparty: core::ops::Range<usize>,
    /// Value billed on this contract
    pub value: Option<rust_decimal::Decimal>,
    /// Last date and time record changed
    pub lastchanged: Option<chrono::NaiveDateTime>,
    backing_data: mmsdm_core::CsvRow<'data>,
}
impl<'data> BillingRealloc5Row<'data> {
    pub fn participantid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.participantid.clone())
    }
    pub fn counterparty(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.counterparty.clone())
    }
}
impl mmsdm_core::GetTable for BillingRealloc5 {
    const VERSION: i32 = 5;
    const DATA_SET_NAME: &'static str = "BILLING";
    const TABLE_NAME: &'static str = "REALLOC";
    const DEFAULT_FIELD_MAPPING: Self::FieldMapping = BillingRealloc5Mapping([
        4,
        5,
        6,
        7,
        8,
        9,
        10,
    ]);
    const COLUMNS: &'static [&'static str] = &[
        "CONTRACTYEAR",
        "WEEKNO",
        "BILLRUNNO",
        "PARTICIPANTID",
        "COUNTERPARTY",
        "VALUE",
        "LASTCHANGED",
    ];
    type Row<'row> = BillingRealloc5Row<'row>;
    type FieldMapping = BillingRealloc5Mapping;
    type PrimaryKey = BillingRealloc5PrimaryKey;
    fn from_row<'data>(
        row: mmsdm_core::CsvRow<'data>,
        field_mapping: &Self::FieldMapping,
    ) -> mmsdm_core::Result<Self::Row<'data>> {
        Ok(BillingRealloc5Row {
            contractyear: row
                .get_custom_parsed_at_idx(
                    "contractyear",
                    field_mapping.0[0],
                    mmsdm_core::mms_decimal::parse,
                )?,
            weekno: row
                .get_custom_parsed_at_idx(
                    "weekno",
                    field_mapping.0[1],
                    mmsdm_core::mms_decimal::parse,
                )?,
            billrunno: row
                .get_custom_parsed_at_idx(
                    "billrunno",
                    field_mapping.0[2],
                    mmsdm_core::mms_decimal::parse,
                )?,
            participantid: row.get_range("participantid", field_mapping.0[3])?,
            counterparty: row.get_range("counterparty", field_mapping.0[4])?,
            value: row
                .get_opt_custom_parsed_at_idx(
                    "value",
                    field_mapping.0[5],
                    mmsdm_core::mms_decimal::parse,
                )?,
            lastchanged: row
                .get_opt_custom_parsed_at_idx(
                    "lastchanged",
                    field_mapping.0[6],
                    mmsdm_core::mms_datetime::parse,
                )?,
            backing_data: row,
        })
    }
    fn field_mapping_from_row<'a>(
        mut row: mmsdm_core::CsvRow<'a>,
    ) -> mmsdm_core::Result<Self::FieldMapping> {
        if !row.is_heading() {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!("Expected an I row but got {row:?}"),
                ),
            );
        }
        let row_key = mmsdm_core::FileKey::from_row(row.borrow())?;
        if !Self::matches_file_key(&row_key, row_key.version) {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!(
                        "Expected a row matching {}.{}.v{} but got {row_key}",
                        Self::DATA_SET_NAME, Self::TABLE_NAME, Self::VERSION
                    ),
                ),
            );
        }
        let mut base_mapping = Self::DEFAULT_FIELD_MAPPING.0;
        for (field_index, field) in Self::COLUMNS.iter().enumerate() {
            base_mapping[field_index] = row
                .iter_fields()
                .position(|f| f == *field)
                .unwrap_or(usize::MAX);
        }
        Ok(BillingRealloc5Mapping(base_mapping))
    }
    fn matches_file_key(key: &mmsdm_core::FileKey<'_>, version: i32) -> bool {
        version == key.version && Self::DATA_SET_NAME == key.data_set_name()
            && Self::TABLE_NAME == key.table_name()
    }
    fn primary_key(row: &Self::Row<'_>) -> BillingRealloc5PrimaryKey {
        BillingRealloc5PrimaryKey {
            billrunno: row.billrunno,
            contractyear: row.contractyear,
            counterparty: row.counterparty().to_string(),
            participantid: row.participantid().to_string(),
            weekno: row.weekno,
        }
    }
    fn partition_value(&self, row: &Self::Row<'_>) -> mmsdm_core::PartitionValue {
        (self.extract_row_partition)(row)
    }
    fn partition_name(&self, row: &Self::Row<'_>) -> alloc::string::String {
        alloc::format!("billing_realloc_v5_{}", self.partition_value(row))
    }
    fn partition_key(&self) -> mmsdm_core::PartitionKey {
        self.row_partition_key
    }
    fn to_static<'a>(row: &Self::Row<'a>) -> Self::Row<'static> {
        BillingRealloc5Row {
            contractyear: row.contractyear.clone(),
            weekno: row.weekno.clone(),
            billrunno: row.billrunno.clone(),
            participantid: row.participantid.clone(),
            counterparty: row.counterparty.clone(),
            value: row.value.clone(),
            lastchanged: row.lastchanged.clone(),
            backing_data: row.backing_data.to_owned(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct BillingRealloc5PrimaryKey {
    pub billrunno: rust_decimal::Decimal,
    pub contractyear: rust_decimal::Decimal,
    pub counterparty: alloc::string::String,
    pub participantid: alloc::string::String,
    pub weekno: rust_decimal::Decimal,
}
impl mmsdm_core::PrimaryKey for BillingRealloc5PrimaryKey {}
impl<'data> mmsdm_core::CompareWithRow for BillingRealloc5Row<'data> {
    type Row<'other> = BillingRealloc5Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.counterparty() == row.counterparty()
            && self.participantid() == row.participantid() && self.weekno == row.weekno
    }
}
impl<'data> mmsdm_core::CompareWithPrimaryKey for BillingRealloc5Row<'data> {
    type PrimaryKey = BillingRealloc5PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.counterparty() == key.counterparty
            && self.participantid() == key.participantid && self.weekno == key.weekno
    }
}
impl<'data> mmsdm_core::CompareWithRow for BillingRealloc5PrimaryKey {
    type Row<'other> = BillingRealloc5Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.counterparty == row.counterparty()
            && self.participantid == row.participantid() && self.weekno == row.weekno
    }
}
impl mmsdm_core::CompareWithPrimaryKey for BillingRealloc5PrimaryKey {
    type PrimaryKey = BillingRealloc5PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.counterparty == key.counterparty
            && self.participantid == key.participantid && self.weekno == key.weekno
    }
}
#[cfg(feature = "arrow")]
impl mmsdm_core::ArrowSchema for BillingRealloc5 {
    type Builder = BillingRealloc5Builder;
    fn schema() -> arrow::datatypes::Schema {
        arrow::datatypes::Schema::new(
            alloc::vec::Vec::from([
                arrow::datatypes::Field::new(
                    "contractyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "weekno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "billrunno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "participantid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "counterparty",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "value",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lastchanged",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    true,
                ),
            ]),
        )
    }
    fn new_builder() -> Self::Builder {
        BillingRealloc5Builder {
            contractyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            weekno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            billrunno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            participantid_array: arrow::array::builder::StringBuilder::new(),
            counterparty_array: arrow::array::builder::StringBuilder::new(),
            value_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
        }
    }
    fn append_builder(builder: &mut Self::Builder, row: Self::Row<'_>) {
        builder
            .contractyear_array
            .append_value({
                let mut val = row.contractyear;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .weekno_array
            .append_value({
                let mut val = row.weekno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .billrunno_array
            .append_value({
                let mut val = row.billrunno;
                val.rescale(0);
                val.mantissa()
            });
        builder.participantid_array.append_value(row.participantid());
        builder.counterparty_array.append_value(row.counterparty());
        builder
            .value_array
            .append_option({
                row.value
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .lastchanged_array
            .append_option(row.lastchanged.map(|val| val.and_utc().timestamp_millis()));
    }
    fn finalize_builder(
        builder: &mut Self::Builder,
    ) -> mmsdm_core::Result<arrow::array::RecordBatch> {
        arrow::array::RecordBatch::try_new(
                alloc::sync::Arc::new(<Self as mmsdm_core::ArrowSchema>::schema()),
                alloc::vec::Vec::from([
                    alloc::sync::Arc::new(builder.contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.participantid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.counterparty_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.value_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lastchanged_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                ]),
            )
            .map_err(Into::into)
    }
}
#[cfg(feature = "arrow")]
pub struct BillingRealloc5Builder {
    contractyear_array: arrow::array::builder::Decimal128Builder,
    weekno_array: arrow::array::builder::Decimal128Builder,
    billrunno_array: arrow::array::builder::Decimal128Builder,
    participantid_array: arrow::array::builder::StringBuilder,
    counterparty_array: arrow::array::builder::StringBuilder,
    value_array: arrow::array::builder::Decimal128Builder,
    lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder,
}
pub struct BillingReallocDetail5 {
    extract_row_partition: alloc::boxed::Box<
        dyn Fn(
            &BillingReallocDetail5Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    >,
    row_partition_key: mmsdm_core::PartitionKey,
}
impl BillingReallocDetail5 {
    pub fn new(
        row_partition_key: mmsdm_core::PartitionKey,
        func: impl Fn(
            &<Self as mmsdm_core::GetTable>::Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    ) -> Self {
        Self {
            extract_row_partition: alloc::boxed::Box::new(func),
            row_partition_key,
        }
    }
}
pub struct BillingReallocDetail5Mapping([usize; 8]);
/// # Summary
///
/// ## BILLINGREALLOC_DETAIL
///  _Billing Reallocation Data aggregated by REALLOCATIONID for each billing run over the billing week._
///
/// * Data Set Name: Billing
/// * File Name: Realloc Detail
/// * Data Version: 5
///
/// # Description
///  The BILLINGREALLOC_DETAIL table that will give a breakdown of the reallocations that form part of that billing run. This assists participants in their settlement reconciliation process. &nbsp; Private data Volume max 100 rows per day
///
///
///
/// # Primary Key Columns
///
/// * BILLRUNNO
/// * CONTRACTYEAR
/// * COUNTERPARTY
/// * PARTICIPANTID
/// * REALLOCATIONID
/// * WEEKNO
#[derive(Debug, PartialEq, Eq)]
pub struct BillingReallocDetail5Row<'data> {
    /// BILLING CONTRACTYEAR
    pub contractyear: rust_decimal::Decimal,
    /// BILLING WEEKNO
    pub weekno: rust_decimal::Decimal,
    /// BILLING RUN NO
    pub billrunno: rust_decimal::Decimal,
    /// REALLOCATION PARTICIPANTID
    pub participantid: core::ops::Range<usize>,
    /// REALLOCATION COUNTERPARTY PARTICIPANTID
    pub counterparty: core::ops::Range<usize>,
    /// REALLOCATIONID
    pub reallocationid: core::ops::Range<usize>,
    /// REALLOCATION VALUE
    pub value: Option<rust_decimal::Decimal>,
    /// DATETIME WHEN RECORD SAVED
    pub lastchanged: Option<chrono::NaiveDateTime>,
    backing_data: mmsdm_core::CsvRow<'data>,
}
impl<'data> BillingReallocDetail5Row<'data> {
    pub fn participantid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.participantid.clone())
    }
    pub fn counterparty(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.counterparty.clone())
    }
    pub fn reallocationid(&self) -> &str {
        core::ops::Index::index(
            self.backing_data.as_slice(),
            self.reallocationid.clone(),
        )
    }
}
impl mmsdm_core::GetTable for BillingReallocDetail5 {
    const VERSION: i32 = 5;
    const DATA_SET_NAME: &'static str = "BILLING";
    const TABLE_NAME: &'static str = "REALLOC_DETAIL";
    const DEFAULT_FIELD_MAPPING: Self::FieldMapping = BillingReallocDetail5Mapping([
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
    ]);
    const COLUMNS: &'static [&'static str] = &[
        "CONTRACTYEAR",
        "WEEKNO",
        "BILLRUNNO",
        "PARTICIPANTID",
        "COUNTERPARTY",
        "REALLOCATIONID",
        "VALUE",
        "LASTCHANGED",
    ];
    type Row<'row> = BillingReallocDetail5Row<'row>;
    type FieldMapping = BillingReallocDetail5Mapping;
    type PrimaryKey = BillingReallocDetail5PrimaryKey;
    fn from_row<'data>(
        row: mmsdm_core::CsvRow<'data>,
        field_mapping: &Self::FieldMapping,
    ) -> mmsdm_core::Result<Self::Row<'data>> {
        Ok(BillingReallocDetail5Row {
            contractyear: row
                .get_custom_parsed_at_idx(
                    "contractyear",
                    field_mapping.0[0],
                    mmsdm_core::mms_decimal::parse,
                )?,
            weekno: row
                .get_custom_parsed_at_idx(
                    "weekno",
                    field_mapping.0[1],
                    mmsdm_core::mms_decimal::parse,
                )?,
            billrunno: row
                .get_custom_parsed_at_idx(
                    "billrunno",
                    field_mapping.0[2],
                    mmsdm_core::mms_decimal::parse,
                )?,
            participantid: row.get_range("participantid", field_mapping.0[3])?,
            counterparty: row.get_range("counterparty", field_mapping.0[4])?,
            reallocationid: row.get_range("reallocationid", field_mapping.0[5])?,
            value: row
                .get_opt_custom_parsed_at_idx(
                    "value",
                    field_mapping.0[6],
                    mmsdm_core::mms_decimal::parse,
                )?,
            lastchanged: row
                .get_opt_custom_parsed_at_idx(
                    "lastchanged",
                    field_mapping.0[7],
                    mmsdm_core::mms_datetime::parse,
                )?,
            backing_data: row,
        })
    }
    fn field_mapping_from_row<'a>(
        mut row: mmsdm_core::CsvRow<'a>,
    ) -> mmsdm_core::Result<Self::FieldMapping> {
        if !row.is_heading() {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!("Expected an I row but got {row:?}"),
                ),
            );
        }
        let row_key = mmsdm_core::FileKey::from_row(row.borrow())?;
        if !Self::matches_file_key(&row_key, row_key.version) {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!(
                        "Expected a row matching {}.{}.v{} but got {row_key}",
                        Self::DATA_SET_NAME, Self::TABLE_NAME, Self::VERSION
                    ),
                ),
            );
        }
        let mut base_mapping = Self::DEFAULT_FIELD_MAPPING.0;
        for (field_index, field) in Self::COLUMNS.iter().enumerate() {
            base_mapping[field_index] = row
                .iter_fields()
                .position(|f| f == *field)
                .unwrap_or(usize::MAX);
        }
        Ok(BillingReallocDetail5Mapping(base_mapping))
    }
    fn matches_file_key(key: &mmsdm_core::FileKey<'_>, version: i32) -> bool {
        version == key.version && Self::DATA_SET_NAME == key.data_set_name()
            && Self::TABLE_NAME == key.table_name()
    }
    fn primary_key(row: &Self::Row<'_>) -> BillingReallocDetail5PrimaryKey {
        BillingReallocDetail5PrimaryKey {
            billrunno: row.billrunno,
            contractyear: row.contractyear,
            counterparty: row.counterparty().to_string(),
            participantid: row.participantid().to_string(),
            reallocationid: row.reallocationid().to_string(),
            weekno: row.weekno,
        }
    }
    fn partition_value(&self, row: &Self::Row<'_>) -> mmsdm_core::PartitionValue {
        (self.extract_row_partition)(row)
    }
    fn partition_name(&self, row: &Self::Row<'_>) -> alloc::string::String {
        alloc::format!("billing_realloc_detail_v5_{}", self.partition_value(row))
    }
    fn partition_key(&self) -> mmsdm_core::PartitionKey {
        self.row_partition_key
    }
    fn to_static<'a>(row: &Self::Row<'a>) -> Self::Row<'static> {
        BillingReallocDetail5Row {
            contractyear: row.contractyear.clone(),
            weekno: row.weekno.clone(),
            billrunno: row.billrunno.clone(),
            participantid: row.participantid.clone(),
            counterparty: row.counterparty.clone(),
            reallocationid: row.reallocationid.clone(),
            value: row.value.clone(),
            lastchanged: row.lastchanged.clone(),
            backing_data: row.backing_data.to_owned(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct BillingReallocDetail5PrimaryKey {
    pub billrunno: rust_decimal::Decimal,
    pub contractyear: rust_decimal::Decimal,
    pub counterparty: alloc::string::String,
    pub participantid: alloc::string::String,
    pub reallocationid: alloc::string::String,
    pub weekno: rust_decimal::Decimal,
}
impl mmsdm_core::PrimaryKey for BillingReallocDetail5PrimaryKey {}
impl<'data> mmsdm_core::CompareWithRow for BillingReallocDetail5Row<'data> {
    type Row<'other> = BillingReallocDetail5Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.counterparty() == row.counterparty()
            && self.participantid() == row.participantid()
            && self.reallocationid() == row.reallocationid() && self.weekno == row.weekno
    }
}
impl<'data> mmsdm_core::CompareWithPrimaryKey for BillingReallocDetail5Row<'data> {
    type PrimaryKey = BillingReallocDetail5PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.counterparty() == key.counterparty
            && self.participantid() == key.participantid
            && self.reallocationid() == key.reallocationid && self.weekno == key.weekno
    }
}
impl<'data> mmsdm_core::CompareWithRow for BillingReallocDetail5PrimaryKey {
    type Row<'other> = BillingReallocDetail5Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.counterparty == row.counterparty()
            && self.participantid == row.participantid()
            && self.reallocationid == row.reallocationid() && self.weekno == row.weekno
    }
}
impl mmsdm_core::CompareWithPrimaryKey for BillingReallocDetail5PrimaryKey {
    type PrimaryKey = BillingReallocDetail5PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.counterparty == key.counterparty
            && self.participantid == key.participantid
            && self.reallocationid == key.reallocationid && self.weekno == key.weekno
    }
}
#[cfg(feature = "arrow")]
impl mmsdm_core::ArrowSchema for BillingReallocDetail5 {
    type Builder = BillingReallocDetail5Builder;
    fn schema() -> arrow::datatypes::Schema {
        arrow::datatypes::Schema::new(
            alloc::vec::Vec::from([
                arrow::datatypes::Field::new(
                    "contractyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "weekno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "billrunno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "participantid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "counterparty",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "reallocationid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "value",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lastchanged",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    true,
                ),
            ]),
        )
    }
    fn new_builder() -> Self::Builder {
        BillingReallocDetail5Builder {
            contractyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            weekno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            billrunno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            participantid_array: arrow::array::builder::StringBuilder::new(),
            counterparty_array: arrow::array::builder::StringBuilder::new(),
            reallocationid_array: arrow::array::builder::StringBuilder::new(),
            value_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
        }
    }
    fn append_builder(builder: &mut Self::Builder, row: Self::Row<'_>) {
        builder
            .contractyear_array
            .append_value({
                let mut val = row.contractyear;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .weekno_array
            .append_value({
                let mut val = row.weekno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .billrunno_array
            .append_value({
                let mut val = row.billrunno;
                val.rescale(0);
                val.mantissa()
            });
        builder.participantid_array.append_value(row.participantid());
        builder.counterparty_array.append_value(row.counterparty());
        builder.reallocationid_array.append_value(row.reallocationid());
        builder
            .value_array
            .append_option({
                row.value
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .lastchanged_array
            .append_option(row.lastchanged.map(|val| val.and_utc().timestamp_millis()));
    }
    fn finalize_builder(
        builder: &mut Self::Builder,
    ) -> mmsdm_core::Result<arrow::array::RecordBatch> {
        arrow::array::RecordBatch::try_new(
                alloc::sync::Arc::new(<Self as mmsdm_core::ArrowSchema>::schema()),
                alloc::vec::Vec::from([
                    alloc::sync::Arc::new(builder.contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.participantid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.counterparty_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.reallocationid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.value_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lastchanged_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                ]),
            )
            .map_err(Into::into)
    }
}
#[cfg(feature = "arrow")]
pub struct BillingReallocDetail5Builder {
    contractyear_array: arrow::array::builder::Decimal128Builder,
    weekno_array: arrow::array::builder::Decimal128Builder,
    billrunno_array: arrow::array::builder::Decimal128Builder,
    participantid_array: arrow::array::builder::StringBuilder,
    counterparty_array: arrow::array::builder::StringBuilder,
    reallocationid_array: arrow::array::builder::StringBuilder,
    value_array: arrow::array::builder::Decimal128Builder,
    lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder,
}
pub struct BillingRegionexports5 {
    extract_row_partition: alloc::boxed::Box<
        dyn Fn(
            &BillingRegionexports5Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    >,
    row_partition_key: mmsdm_core::PartitionKey,
}
impl BillingRegionexports5 {
    pub fn new(
        row_partition_key: mmsdm_core::PartitionKey,
        func: impl Fn(
            &<Self as mmsdm_core::GetTable>::Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    ) -> Self {
        Self {
            extract_row_partition: alloc::boxed::Box::new(func),
            row_partition_key,
        }
    }
}
pub struct BillingRegionexports5Mapping([usize; 10]);
/// # Summary
///
/// ## BILLINGREGIONEXPORTS
///  _BILLINGREGIONEXPORTS sets out the region summary table of overall energy exported to and from each region for each billing run._
///
/// * Data Set Name: Billing
/// * File Name: Regionexports
/// * Data Version: 5
///
/// # Description
///  BILLINGREGIONEXPORTS  data is public, and is available to all participants. Source BILLINGREGIONEXPORTS is populated by the posting of a billing run. Volume Eight records inserted per billing run, or 88 records inserted per week.
///
///
///
/// # Primary Key Columns
///
/// * BILLRUNNO
/// * CONTRACTYEAR
/// * EXPORTTO
/// * REGIONID
/// * WEEKNO
#[derive(Debug, PartialEq, Eq)]
pub struct BillingRegionexports5Row<'data> {
    /// AEMO Contract Year number starting in week containing 1st January
    pub contractyear: rust_decimal::Decimal,
    /// Week no within the contract year. Week no 1 is the week containing 1st January
    pub weekno: rust_decimal::Decimal,
    /// Unique run no within a given contract year and week no
    pub billrunno: rust_decimal::Decimal,
    /// Unique region identifier
    pub regionid: core::ops::Range<usize>,
    /// Region exported to
    pub exportto: core::ops::Range<usize>,
    /// MWh Energy value exported
    pub energy: Option<rust_decimal::Decimal>,
    /// $ Value of energy exported
    pub value: Option<rust_decimal::Decimal>,
    /// This field is populated with 0
    pub surplusenergy: Option<rust_decimal::Decimal>,
    /// $ Interregional residue
    pub surplusvalue: Option<rust_decimal::Decimal>,
    /// Last date and time record changed
    pub lastchanged: Option<chrono::NaiveDateTime>,
    backing_data: mmsdm_core::CsvRow<'data>,
}
impl<'data> BillingRegionexports5Row<'data> {
    pub fn regionid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.regionid.clone())
    }
    pub fn exportto(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.exportto.clone())
    }
}
impl mmsdm_core::GetTable for BillingRegionexports5 {
    const VERSION: i32 = 5;
    const DATA_SET_NAME: &'static str = "BILLING";
    const TABLE_NAME: &'static str = "REGIONEXPORTS";
    const DEFAULT_FIELD_MAPPING: Self::FieldMapping = BillingRegionexports5Mapping([
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
    ]);
    const COLUMNS: &'static [&'static str] = &[
        "CONTRACTYEAR",
        "WEEKNO",
        "BILLRUNNO",
        "REGIONID",
        "EXPORTTO",
        "ENERGY",
        "VALUE",
        "SURPLUSENERGY",
        "SURPLUSVALUE",
        "LASTCHANGED",
    ];
    type Row<'row> = BillingRegionexports5Row<'row>;
    type FieldMapping = BillingRegionexports5Mapping;
    type PrimaryKey = BillingRegionexports5PrimaryKey;
    fn from_row<'data>(
        row: mmsdm_core::CsvRow<'data>,
        field_mapping: &Self::FieldMapping,
    ) -> mmsdm_core::Result<Self::Row<'data>> {
        Ok(BillingRegionexports5Row {
            contractyear: row
                .get_custom_parsed_at_idx(
                    "contractyear",
                    field_mapping.0[0],
                    mmsdm_core::mms_decimal::parse,
                )?,
            weekno: row
                .get_custom_parsed_at_idx(
                    "weekno",
                    field_mapping.0[1],
                    mmsdm_core::mms_decimal::parse,
                )?,
            billrunno: row
                .get_custom_parsed_at_idx(
                    "billrunno",
                    field_mapping.0[2],
                    mmsdm_core::mms_decimal::parse,
                )?,
            regionid: row.get_range("regionid", field_mapping.0[3])?,
            exportto: row.get_range("exportto", field_mapping.0[4])?,
            energy: row
                .get_opt_custom_parsed_at_idx(
                    "energy",
                    field_mapping.0[5],
                    mmsdm_core::mms_decimal::parse,
                )?,
            value: row
                .get_opt_custom_parsed_at_idx(
                    "value",
                    field_mapping.0[6],
                    mmsdm_core::mms_decimal::parse,
                )?,
            surplusenergy: row
                .get_opt_custom_parsed_at_idx(
                    "surplusenergy",
                    field_mapping.0[7],
                    mmsdm_core::mms_decimal::parse,
                )?,
            surplusvalue: row
                .get_opt_custom_parsed_at_idx(
                    "surplusvalue",
                    field_mapping.0[8],
                    mmsdm_core::mms_decimal::parse,
                )?,
            lastchanged: row
                .get_opt_custom_parsed_at_idx(
                    "lastchanged",
                    field_mapping.0[9],
                    mmsdm_core::mms_datetime::parse,
                )?,
            backing_data: row,
        })
    }
    fn field_mapping_from_row<'a>(
        mut row: mmsdm_core::CsvRow<'a>,
    ) -> mmsdm_core::Result<Self::FieldMapping> {
        if !row.is_heading() {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!("Expected an I row but got {row:?}"),
                ),
            );
        }
        let row_key = mmsdm_core::FileKey::from_row(row.borrow())?;
        if !Self::matches_file_key(&row_key, row_key.version) {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!(
                        "Expected a row matching {}.{}.v{} but got {row_key}",
                        Self::DATA_SET_NAME, Self::TABLE_NAME, Self::VERSION
                    ),
                ),
            );
        }
        let mut base_mapping = Self::DEFAULT_FIELD_MAPPING.0;
        for (field_index, field) in Self::COLUMNS.iter().enumerate() {
            base_mapping[field_index] = row
                .iter_fields()
                .position(|f| f == *field)
                .unwrap_or(usize::MAX);
        }
        Ok(BillingRegionexports5Mapping(base_mapping))
    }
    fn matches_file_key(key: &mmsdm_core::FileKey<'_>, version: i32) -> bool {
        version == key.version && Self::DATA_SET_NAME == key.data_set_name()
            && Self::TABLE_NAME == key.table_name()
    }
    fn primary_key(row: &Self::Row<'_>) -> BillingRegionexports5PrimaryKey {
        BillingRegionexports5PrimaryKey {
            billrunno: row.billrunno,
            contractyear: row.contractyear,
            exportto: row.exportto().to_string(),
            regionid: row.regionid().to_string(),
            weekno: row.weekno,
        }
    }
    fn partition_value(&self, row: &Self::Row<'_>) -> mmsdm_core::PartitionValue {
        (self.extract_row_partition)(row)
    }
    fn partition_name(&self, row: &Self::Row<'_>) -> alloc::string::String {
        alloc::format!("billing_regionexports_v5_{}", self.partition_value(row))
    }
    fn partition_key(&self) -> mmsdm_core::PartitionKey {
        self.row_partition_key
    }
    fn to_static<'a>(row: &Self::Row<'a>) -> Self::Row<'static> {
        BillingRegionexports5Row {
            contractyear: row.contractyear.clone(),
            weekno: row.weekno.clone(),
            billrunno: row.billrunno.clone(),
            regionid: row.regionid.clone(),
            exportto: row.exportto.clone(),
            energy: row.energy.clone(),
            value: row.value.clone(),
            surplusenergy: row.surplusenergy.clone(),
            surplusvalue: row.surplusvalue.clone(),
            lastchanged: row.lastchanged.clone(),
            backing_data: row.backing_data.to_owned(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct BillingRegionexports5PrimaryKey {
    pub billrunno: rust_decimal::Decimal,
    pub contractyear: rust_decimal::Decimal,
    pub exportto: alloc::string::String,
    pub regionid: alloc::string::String,
    pub weekno: rust_decimal::Decimal,
}
impl mmsdm_core::PrimaryKey for BillingRegionexports5PrimaryKey {}
impl<'data> mmsdm_core::CompareWithRow for BillingRegionexports5Row<'data> {
    type Row<'other> = BillingRegionexports5Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.exportto() == row.exportto() && self.regionid() == row.regionid()
            && self.weekno == row.weekno
    }
}
impl<'data> mmsdm_core::CompareWithPrimaryKey for BillingRegionexports5Row<'data> {
    type PrimaryKey = BillingRegionexports5PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.exportto() == key.exportto && self.regionid() == key.regionid
            && self.weekno == key.weekno
    }
}
impl<'data> mmsdm_core::CompareWithRow for BillingRegionexports5PrimaryKey {
    type Row<'other> = BillingRegionexports5Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.exportto == row.exportto() && self.regionid == row.regionid()
            && self.weekno == row.weekno
    }
}
impl mmsdm_core::CompareWithPrimaryKey for BillingRegionexports5PrimaryKey {
    type PrimaryKey = BillingRegionexports5PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.exportto == key.exportto && self.regionid == key.regionid
            && self.weekno == key.weekno
    }
}
#[cfg(feature = "arrow")]
impl mmsdm_core::ArrowSchema for BillingRegionexports5 {
    type Builder = BillingRegionexports5Builder;
    fn schema() -> arrow::datatypes::Schema {
        arrow::datatypes::Schema::new(
            alloc::vec::Vec::from([
                arrow::datatypes::Field::new(
                    "contractyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "weekno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "billrunno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "regionid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "exportto",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "energy",
                    arrow::datatypes::DataType::Decimal128(16, 6),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "value",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "surplusenergy",
                    arrow::datatypes::DataType::Decimal128(16, 6),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "surplusvalue",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lastchanged",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    true,
                ),
            ]),
        )
    }
    fn new_builder() -> Self::Builder {
        BillingRegionexports5Builder {
            contractyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            weekno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            billrunno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            regionid_array: arrow::array::builder::StringBuilder::new(),
            exportto_array: arrow::array::builder::StringBuilder::new(),
            energy_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(16, 6)),
            value_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            surplusenergy_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(16, 6)),
            surplusvalue_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
        }
    }
    fn append_builder(builder: &mut Self::Builder, row: Self::Row<'_>) {
        builder
            .contractyear_array
            .append_value({
                let mut val = row.contractyear;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .weekno_array
            .append_value({
                let mut val = row.weekno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .billrunno_array
            .append_value({
                let mut val = row.billrunno;
                val.rescale(0);
                val.mantissa()
            });
        builder.regionid_array.append_value(row.regionid());
        builder.exportto_array.append_value(row.exportto());
        builder
            .energy_array
            .append_option({
                row.energy
                    .map(|mut val| {
                        val.rescale(6);
                        val.mantissa()
                    })
            });
        builder
            .value_array
            .append_option({
                row.value
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .surplusenergy_array
            .append_option({
                row.surplusenergy
                    .map(|mut val| {
                        val.rescale(6);
                        val.mantissa()
                    })
            });
        builder
            .surplusvalue_array
            .append_option({
                row.surplusvalue
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .lastchanged_array
            .append_option(row.lastchanged.map(|val| val.and_utc().timestamp_millis()));
    }
    fn finalize_builder(
        builder: &mut Self::Builder,
    ) -> mmsdm_core::Result<arrow::array::RecordBatch> {
        arrow::array::RecordBatch::try_new(
                alloc::sync::Arc::new(<Self as mmsdm_core::ArrowSchema>::schema()),
                alloc::vec::Vec::from([
                    alloc::sync::Arc::new(builder.contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.regionid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.exportto_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.energy_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.value_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.surplusenergy_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.surplusvalue_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lastchanged_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                ]),
            )
            .map_err(Into::into)
    }
}
#[cfg(feature = "arrow")]
pub struct BillingRegionexports5Builder {
    contractyear_array: arrow::array::builder::Decimal128Builder,
    weekno_array: arrow::array::builder::Decimal128Builder,
    billrunno_array: arrow::array::builder::Decimal128Builder,
    regionid_array: arrow::array::builder::StringBuilder,
    exportto_array: arrow::array::builder::StringBuilder,
    energy_array: arrow::array::builder::Decimal128Builder,
    value_array: arrow::array::builder::Decimal128Builder,
    surplusenergy_array: arrow::array::builder::Decimal128Builder,
    surplusvalue_array: arrow::array::builder::Decimal128Builder,
    lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder,
}
pub struct BillingRegionfigures6 {
    extract_row_partition: alloc::boxed::Box<
        dyn Fn(
            &BillingRegionfigures6Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    >,
    row_partition_key: mmsdm_core::PartitionKey,
}
impl BillingRegionfigures6 {
    pub fn new(
        row_partition_key: mmsdm_core::PartitionKey,
        func: impl Fn(
            &<Self as mmsdm_core::GetTable>::Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    ) -> Self {
        Self {
            extract_row_partition: alloc::boxed::Box::new(func),
            row_partition_key,
        }
    }
}
pub struct BillingRegionfigures6Mapping([usize; 18]);
/// # Summary
///
/// ## BILLINGREGIONFIGURES
///  _BILLINGREGIONFIGURES sets out additional summary region details including ancillary service amounts for each billing run._
///
/// * Data Set Name: Billing
/// * File Name: Regionfigures
/// * Data Version: 6
///
/// # Description
///  BILLINGREGIONFIGURES is public data, and is available to all participants. Source BILLINGREGIONFIGURES is populated by the posting of a billing run. Volume Five records inserted per billing run, or 55 records inserted per week.
///
///
///
/// # Primary Key Columns
///
/// * BILLRUNNO
/// * CONTRACTYEAR
/// * REGIONID
/// * WEEKNO
#[derive(Debug, PartialEq, Eq)]
pub struct BillingRegionfigures6Row<'data> {
    /// AEMO Contract Year number starting in week containing 1st January
    pub contractyear: rust_decimal::Decimal,
    /// Week no within the contract year. Week no 1 is the week containing 1st January
    pub weekno: rust_decimal::Decimal,
    /// Unique run no within a given contract year and week no
    pub billrunno: rust_decimal::Decimal,
    /// Unique region identifier
    pub regionid: core::ops::Range<usize>,
    /// MWh Energy output in the region during the billing period
    pub energyout: Option<rust_decimal::Decimal>,
    /// $ Value of energy output in region during billing period
    pub valueout: Option<rust_decimal::Decimal>,
    /// MWh Amount of energy purchased in region during billing period
    pub energypurchased: Option<rust_decimal::Decimal>,
    /// $ Value of energy purchased during billing period
    pub valuepurchased: Option<rust_decimal::Decimal>,
    /// This field is populated with 0
    pub excessgen: Option<rust_decimal::Decimal>,
    /// This field is populated with 0
    pub reservetrading: Option<rust_decimal::Decimal>,
    /// This field is populated with 0
    pub intcompo: Option<rust_decimal::Decimal>,
    /// This field is populated with 0
    pub adminpricecompo: Option<rust_decimal::Decimal>,
    /// Intraregional residues in $
    pub settsurplus: Option<rust_decimal::Decimal>,
    /// Ancillary service payments in $
    pub aspayment: Option<rust_decimal::Decimal>,
    /// This field is populated with 0
    pub poolfees: Option<rust_decimal::Decimal>,
    /// Last date and time record changed
    pub lastchanged: Option<chrono::NaiveDateTime>,
    /// WDR Settlement Quantity Capped in MWh
    pub wdrsq: Option<rust_decimal::Decimal>,
    /// WDR transaction amount in $
    pub wdrta: Option<rust_decimal::Decimal>,
    backing_data: mmsdm_core::CsvRow<'data>,
}
impl<'data> BillingRegionfigures6Row<'data> {
    pub fn regionid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.regionid.clone())
    }
}
impl mmsdm_core::GetTable for BillingRegionfigures6 {
    const VERSION: i32 = 6;
    const DATA_SET_NAME: &'static str = "BILLING";
    const TABLE_NAME: &'static str = "REGIONFIGURES";
    const DEFAULT_FIELD_MAPPING: Self::FieldMapping = BillingRegionfigures6Mapping([
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
    ]);
    const COLUMNS: &'static [&'static str] = &[
        "CONTRACTYEAR",
        "WEEKNO",
        "BILLRUNNO",
        "REGIONID",
        "ENERGYOUT",
        "VALUEOUT",
        "ENERGYPURCHASED",
        "VALUEPURCHASED",
        "EXCESSGEN",
        "RESERVETRADING",
        "INTCOMPO",
        "ADMINPRICECOMPO",
        "SETTSURPLUS",
        "ASPAYMENT",
        "POOLFEES",
        "LASTCHANGED",
        "WDRSQ",
        "WDRTA",
    ];
    type Row<'row> = BillingRegionfigures6Row<'row>;
    type FieldMapping = BillingRegionfigures6Mapping;
    type PrimaryKey = BillingRegionfigures6PrimaryKey;
    fn from_row<'data>(
        row: mmsdm_core::CsvRow<'data>,
        field_mapping: &Self::FieldMapping,
    ) -> mmsdm_core::Result<Self::Row<'data>> {
        Ok(BillingRegionfigures6Row {
            contractyear: row
                .get_custom_parsed_at_idx(
                    "contractyear",
                    field_mapping.0[0],
                    mmsdm_core::mms_decimal::parse,
                )?,
            weekno: row
                .get_custom_parsed_at_idx(
                    "weekno",
                    field_mapping.0[1],
                    mmsdm_core::mms_decimal::parse,
                )?,
            billrunno: row
                .get_custom_parsed_at_idx(
                    "billrunno",
                    field_mapping.0[2],
                    mmsdm_core::mms_decimal::parse,
                )?,
            regionid: row.get_range("regionid", field_mapping.0[3])?,
            energyout: row
                .get_opt_custom_parsed_at_idx(
                    "energyout",
                    field_mapping.0[4],
                    mmsdm_core::mms_decimal::parse,
                )?,
            valueout: row
                .get_opt_custom_parsed_at_idx(
                    "valueout",
                    field_mapping.0[5],
                    mmsdm_core::mms_decimal::parse,
                )?,
            energypurchased: row
                .get_opt_custom_parsed_at_idx(
                    "energypurchased",
                    field_mapping.0[6],
                    mmsdm_core::mms_decimal::parse,
                )?,
            valuepurchased: row
                .get_opt_custom_parsed_at_idx(
                    "valuepurchased",
                    field_mapping.0[7],
                    mmsdm_core::mms_decimal::parse,
                )?,
            excessgen: row
                .get_opt_custom_parsed_at_idx(
                    "excessgen",
                    field_mapping.0[8],
                    mmsdm_core::mms_decimal::parse,
                )?,
            reservetrading: row
                .get_opt_custom_parsed_at_idx(
                    "reservetrading",
                    field_mapping.0[9],
                    mmsdm_core::mms_decimal::parse,
                )?,
            intcompo: row
                .get_opt_custom_parsed_at_idx(
                    "intcompo",
                    field_mapping.0[10],
                    mmsdm_core::mms_decimal::parse,
                )?,
            adminpricecompo: row
                .get_opt_custom_parsed_at_idx(
                    "adminpricecompo",
                    field_mapping.0[11],
                    mmsdm_core::mms_decimal::parse,
                )?,
            settsurplus: row
                .get_opt_custom_parsed_at_idx(
                    "settsurplus",
                    field_mapping.0[12],
                    mmsdm_core::mms_decimal::parse,
                )?,
            aspayment: row
                .get_opt_custom_parsed_at_idx(
                    "aspayment",
                    field_mapping.0[13],
                    mmsdm_core::mms_decimal::parse,
                )?,
            poolfees: row
                .get_opt_custom_parsed_at_idx(
                    "poolfees",
                    field_mapping.0[14],
                    mmsdm_core::mms_decimal::parse,
                )?,
            lastchanged: row
                .get_opt_custom_parsed_at_idx(
                    "lastchanged",
                    field_mapping.0[15],
                    mmsdm_core::mms_datetime::parse,
                )?,
            wdrsq: row
                .get_opt_custom_parsed_at_idx(
                    "wdrsq",
                    field_mapping.0[16],
                    mmsdm_core::mms_decimal::parse,
                )?,
            wdrta: row
                .get_opt_custom_parsed_at_idx(
                    "wdrta",
                    field_mapping.0[17],
                    mmsdm_core::mms_decimal::parse,
                )?,
            backing_data: row,
        })
    }
    fn field_mapping_from_row<'a>(
        mut row: mmsdm_core::CsvRow<'a>,
    ) -> mmsdm_core::Result<Self::FieldMapping> {
        if !row.is_heading() {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!("Expected an I row but got {row:?}"),
                ),
            );
        }
        let row_key = mmsdm_core::FileKey::from_row(row.borrow())?;
        if !Self::matches_file_key(&row_key, row_key.version) {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!(
                        "Expected a row matching {}.{}.v{} but got {row_key}",
                        Self::DATA_SET_NAME, Self::TABLE_NAME, Self::VERSION
                    ),
                ),
            );
        }
        let mut base_mapping = Self::DEFAULT_FIELD_MAPPING.0;
        for (field_index, field) in Self::COLUMNS.iter().enumerate() {
            base_mapping[field_index] = row
                .iter_fields()
                .position(|f| f == *field)
                .unwrap_or(usize::MAX);
        }
        Ok(BillingRegionfigures6Mapping(base_mapping))
    }
    fn matches_file_key(key: &mmsdm_core::FileKey<'_>, version: i32) -> bool {
        version == key.version && Self::DATA_SET_NAME == key.data_set_name()
            && Self::TABLE_NAME == key.table_name()
    }
    fn primary_key(row: &Self::Row<'_>) -> BillingRegionfigures6PrimaryKey {
        BillingRegionfigures6PrimaryKey {
            billrunno: row.billrunno,
            contractyear: row.contractyear,
            regionid: row.regionid().to_string(),
            weekno: row.weekno,
        }
    }
    fn partition_value(&self, row: &Self::Row<'_>) -> mmsdm_core::PartitionValue {
        (self.extract_row_partition)(row)
    }
    fn partition_name(&self, row: &Self::Row<'_>) -> alloc::string::String {
        alloc::format!("billing_regionfigures_v6_{}", self.partition_value(row))
    }
    fn partition_key(&self) -> mmsdm_core::PartitionKey {
        self.row_partition_key
    }
    fn to_static<'a>(row: &Self::Row<'a>) -> Self::Row<'static> {
        BillingRegionfigures6Row {
            contractyear: row.contractyear.clone(),
            weekno: row.weekno.clone(),
            billrunno: row.billrunno.clone(),
            regionid: row.regionid.clone(),
            energyout: row.energyout.clone(),
            valueout: row.valueout.clone(),
            energypurchased: row.energypurchased.clone(),
            valuepurchased: row.valuepurchased.clone(),
            excessgen: row.excessgen.clone(),
            reservetrading: row.reservetrading.clone(),
            intcompo: row.intcompo.clone(),
            adminpricecompo: row.adminpricecompo.clone(),
            settsurplus: row.settsurplus.clone(),
            aspayment: row.aspayment.clone(),
            poolfees: row.poolfees.clone(),
            lastchanged: row.lastchanged.clone(),
            wdrsq: row.wdrsq.clone(),
            wdrta: row.wdrta.clone(),
            backing_data: row.backing_data.to_owned(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct BillingRegionfigures6PrimaryKey {
    pub billrunno: rust_decimal::Decimal,
    pub contractyear: rust_decimal::Decimal,
    pub regionid: alloc::string::String,
    pub weekno: rust_decimal::Decimal,
}
impl mmsdm_core::PrimaryKey for BillingRegionfigures6PrimaryKey {}
impl<'data> mmsdm_core::CompareWithRow for BillingRegionfigures6Row<'data> {
    type Row<'other> = BillingRegionfigures6Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.regionid() == row.regionid() && self.weekno == row.weekno
    }
}
impl<'data> mmsdm_core::CompareWithPrimaryKey for BillingRegionfigures6Row<'data> {
    type PrimaryKey = BillingRegionfigures6PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.regionid() == key.regionid && self.weekno == key.weekno
    }
}
impl<'data> mmsdm_core::CompareWithRow for BillingRegionfigures6PrimaryKey {
    type Row<'other> = BillingRegionfigures6Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.regionid == row.regionid() && self.weekno == row.weekno
    }
}
impl mmsdm_core::CompareWithPrimaryKey for BillingRegionfigures6PrimaryKey {
    type PrimaryKey = BillingRegionfigures6PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.regionid == key.regionid && self.weekno == key.weekno
    }
}
#[cfg(feature = "arrow")]
impl mmsdm_core::ArrowSchema for BillingRegionfigures6 {
    type Builder = BillingRegionfigures6Builder;
    fn schema() -> arrow::datatypes::Schema {
        arrow::datatypes::Schema::new(
            alloc::vec::Vec::from([
                arrow::datatypes::Field::new(
                    "contractyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "weekno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "billrunno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "regionid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "energyout",
                    arrow::datatypes::DataType::Decimal128(16, 6),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "valueout",
                    arrow::datatypes::DataType::Decimal128(16, 6),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "energypurchased",
                    arrow::datatypes::DataType::Decimal128(16, 6),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "valuepurchased",
                    arrow::datatypes::DataType::Decimal128(16, 6),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "excessgen",
                    arrow::datatypes::DataType::Decimal128(16, 6),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "reservetrading",
                    arrow::datatypes::DataType::Decimal128(16, 6),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "intcompo",
                    arrow::datatypes::DataType::Decimal128(16, 6),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "adminpricecompo",
                    arrow::datatypes::DataType::Decimal128(16, 6),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "settsurplus",
                    arrow::datatypes::DataType::Decimal128(16, 6),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "aspayment",
                    arrow::datatypes::DataType::Decimal128(16, 6),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "poolfees",
                    arrow::datatypes::DataType::Decimal128(16, 6),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lastchanged",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "wdrsq",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "wdrta",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
            ]),
        )
    }
    fn new_builder() -> Self::Builder {
        BillingRegionfigures6Builder {
            contractyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            weekno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            billrunno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            regionid_array: arrow::array::builder::StringBuilder::new(),
            energyout_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(16, 6)),
            valueout_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(16, 6)),
            energypurchased_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(16, 6)),
            valuepurchased_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(16, 6)),
            excessgen_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(16, 6)),
            reservetrading_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(16, 6)),
            intcompo_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(16, 6)),
            adminpricecompo_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(16, 6)),
            settsurplus_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(16, 6)),
            aspayment_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(16, 6)),
            poolfees_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(16, 6)),
            lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
            wdrsq_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            wdrta_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
        }
    }
    fn append_builder(builder: &mut Self::Builder, row: Self::Row<'_>) {
        builder
            .contractyear_array
            .append_value({
                let mut val = row.contractyear;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .weekno_array
            .append_value({
                let mut val = row.weekno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .billrunno_array
            .append_value({
                let mut val = row.billrunno;
                val.rescale(0);
                val.mantissa()
            });
        builder.regionid_array.append_value(row.regionid());
        builder
            .energyout_array
            .append_option({
                row.energyout
                    .map(|mut val| {
                        val.rescale(6);
                        val.mantissa()
                    })
            });
        builder
            .valueout_array
            .append_option({
                row.valueout
                    .map(|mut val| {
                        val.rescale(6);
                        val.mantissa()
                    })
            });
        builder
            .energypurchased_array
            .append_option({
                row.energypurchased
                    .map(|mut val| {
                        val.rescale(6);
                        val.mantissa()
                    })
            });
        builder
            .valuepurchased_array
            .append_option({
                row.valuepurchased
                    .map(|mut val| {
                        val.rescale(6);
                        val.mantissa()
                    })
            });
        builder
            .excessgen_array
            .append_option({
                row.excessgen
                    .map(|mut val| {
                        val.rescale(6);
                        val.mantissa()
                    })
            });
        builder
            .reservetrading_array
            .append_option({
                row.reservetrading
                    .map(|mut val| {
                        val.rescale(6);
                        val.mantissa()
                    })
            });
        builder
            .intcompo_array
            .append_option({
                row.intcompo
                    .map(|mut val| {
                        val.rescale(6);
                        val.mantissa()
                    })
            });
        builder
            .adminpricecompo_array
            .append_option({
                row.adminpricecompo
                    .map(|mut val| {
                        val.rescale(6);
                        val.mantissa()
                    })
            });
        builder
            .settsurplus_array
            .append_option({
                row.settsurplus
                    .map(|mut val| {
                        val.rescale(6);
                        val.mantissa()
                    })
            });
        builder
            .aspayment_array
            .append_option({
                row.aspayment
                    .map(|mut val| {
                        val.rescale(6);
                        val.mantissa()
                    })
            });
        builder
            .poolfees_array
            .append_option({
                row.poolfees
                    .map(|mut val| {
                        val.rescale(6);
                        val.mantissa()
                    })
            });
        builder
            .lastchanged_array
            .append_option(row.lastchanged.map(|val| val.and_utc().timestamp_millis()));
        builder
            .wdrsq_array
            .append_option({
                row.wdrsq
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .wdrta_array
            .append_option({
                row.wdrta
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
    }
    fn finalize_builder(
        builder: &mut Self::Builder,
    ) -> mmsdm_core::Result<arrow::array::RecordBatch> {
        arrow::array::RecordBatch::try_new(
                alloc::sync::Arc::new(<Self as mmsdm_core::ArrowSchema>::schema()),
                alloc::vec::Vec::from([
                    alloc::sync::Arc::new(builder.contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.regionid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.energyout_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.valueout_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.energypurchased_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.valuepurchased_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.excessgen_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.reservetrading_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.intcompo_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.adminpricecompo_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.settsurplus_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.aspayment_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.poolfees_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lastchanged_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.wdrsq_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.wdrta_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                ]),
            )
            .map_err(Into::into)
    }
}
#[cfg(feature = "arrow")]
pub struct BillingRegionfigures6Builder {
    contractyear_array: arrow::array::builder::Decimal128Builder,
    weekno_array: arrow::array::builder::Decimal128Builder,
    billrunno_array: arrow::array::builder::Decimal128Builder,
    regionid_array: arrow::array::builder::StringBuilder,
    energyout_array: arrow::array::builder::Decimal128Builder,
    valueout_array: arrow::array::builder::Decimal128Builder,
    energypurchased_array: arrow::array::builder::Decimal128Builder,
    valuepurchased_array: arrow::array::builder::Decimal128Builder,
    excessgen_array: arrow::array::builder::Decimal128Builder,
    reservetrading_array: arrow::array::builder::Decimal128Builder,
    intcompo_array: arrow::array::builder::Decimal128Builder,
    adminpricecompo_array: arrow::array::builder::Decimal128Builder,
    settsurplus_array: arrow::array::builder::Decimal128Builder,
    aspayment_array: arrow::array::builder::Decimal128Builder,
    poolfees_array: arrow::array::builder::Decimal128Builder,
    lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder,
    wdrsq_array: arrow::array::builder::Decimal128Builder,
    wdrta_array: arrow::array::builder::Decimal128Builder,
}
pub struct BillingRegionimports5 {
    extract_row_partition: alloc::boxed::Box<
        dyn Fn(
            &BillingRegionimports5Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    >,
    row_partition_key: mmsdm_core::PartitionKey,
}
impl BillingRegionimports5 {
    pub fn new(
        row_partition_key: mmsdm_core::PartitionKey,
        func: impl Fn(
            &<Self as mmsdm_core::GetTable>::Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    ) -> Self {
        Self {
            extract_row_partition: alloc::boxed::Box::new(func),
            row_partition_key,
        }
    }
}
pub struct BillingRegionimports5Mapping([usize; 10]);
/// # Summary
///
/// ## BILLINGREGIONIMPORTS
///  _BILLINGREGIONIMPORTS sets out the region summary table of overall energy imported to and from each region for each billing run._
///
/// * Data Set Name: Billing
/// * File Name: Regionimports
/// * Data Version: 5
///
/// # Description
///  BILLINGREGIONIMPORTS is public data, and is available to all participants. Source BILLINGREGIONIMPORTS is populated by the posting of a billing run. Volume Eight records inserted per billing run, or 88 records inserted per week.
///
///
///
/// # Primary Key Columns
///
/// * BILLRUNNO
/// * CONTRACTYEAR
/// * IMPORTFROM
/// * REGIONID
/// * WEEKNO
#[derive(Debug, PartialEq, Eq)]
pub struct BillingRegionimports5Row<'data> {
    /// AEMO Contract Year number starting in week containing 1st January
    pub contractyear: rust_decimal::Decimal,
    /// Week no within the contract year. Week no 1 is the week containing 1st January
    pub weekno: rust_decimal::Decimal,
    /// Unique run no within a given contract year and week no
    pub billrunno: rust_decimal::Decimal,
    /// Unique region identifier
    pub regionid: core::ops::Range<usize>,
    /// Region energy imported from
    pub importfrom: core::ops::Range<usize>,
    /// Amount of energy imported
    pub energy: Option<rust_decimal::Decimal>,
    /// Value of energy imported
    pub value: Option<rust_decimal::Decimal>,
    /// Populated with 0
    pub surplusenergy: Option<rust_decimal::Decimal>,
    /// Interregional residue
    pub surplusvalue: Option<rust_decimal::Decimal>,
    /// Last date and time record changed
    pub lastchanged: Option<chrono::NaiveDateTime>,
    backing_data: mmsdm_core::CsvRow<'data>,
}
impl<'data> BillingRegionimports5Row<'data> {
    pub fn regionid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.regionid.clone())
    }
    pub fn importfrom(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.importfrom.clone())
    }
}
impl mmsdm_core::GetTable for BillingRegionimports5 {
    const VERSION: i32 = 5;
    const DATA_SET_NAME: &'static str = "BILLING";
    const TABLE_NAME: &'static str = "REGIONIMPORTS";
    const DEFAULT_FIELD_MAPPING: Self::FieldMapping = BillingRegionimports5Mapping([
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
    ]);
    const COLUMNS: &'static [&'static str] = &[
        "CONTRACTYEAR",
        "WEEKNO",
        "BILLRUNNO",
        "REGIONID",
        "IMPORTFROM",
        "ENERGY",
        "VALUE",
        "SURPLUSENERGY",
        "SURPLUSVALUE",
        "LASTCHANGED",
    ];
    type Row<'row> = BillingRegionimports5Row<'row>;
    type FieldMapping = BillingRegionimports5Mapping;
    type PrimaryKey = BillingRegionimports5PrimaryKey;
    fn from_row<'data>(
        row: mmsdm_core::CsvRow<'data>,
        field_mapping: &Self::FieldMapping,
    ) -> mmsdm_core::Result<Self::Row<'data>> {
        Ok(BillingRegionimports5Row {
            contractyear: row
                .get_custom_parsed_at_idx(
                    "contractyear",
                    field_mapping.0[0],
                    mmsdm_core::mms_decimal::parse,
                )?,
            weekno: row
                .get_custom_parsed_at_idx(
                    "weekno",
                    field_mapping.0[1],
                    mmsdm_core::mms_decimal::parse,
                )?,
            billrunno: row
                .get_custom_parsed_at_idx(
                    "billrunno",
                    field_mapping.0[2],
                    mmsdm_core::mms_decimal::parse,
                )?,
            regionid: row.get_range("regionid", field_mapping.0[3])?,
            importfrom: row.get_range("importfrom", field_mapping.0[4])?,
            energy: row
                .get_opt_custom_parsed_at_idx(
                    "energy",
                    field_mapping.0[5],
                    mmsdm_core::mms_decimal::parse,
                )?,
            value: row
                .get_opt_custom_parsed_at_idx(
                    "value",
                    field_mapping.0[6],
                    mmsdm_core::mms_decimal::parse,
                )?,
            surplusenergy: row
                .get_opt_custom_parsed_at_idx(
                    "surplusenergy",
                    field_mapping.0[7],
                    mmsdm_core::mms_decimal::parse,
                )?,
            surplusvalue: row
                .get_opt_custom_parsed_at_idx(
                    "surplusvalue",
                    field_mapping.0[8],
                    mmsdm_core::mms_decimal::parse,
                )?,
            lastchanged: row
                .get_opt_custom_parsed_at_idx(
                    "lastchanged",
                    field_mapping.0[9],
                    mmsdm_core::mms_datetime::parse,
                )?,
            backing_data: row,
        })
    }
    fn field_mapping_from_row<'a>(
        mut row: mmsdm_core::CsvRow<'a>,
    ) -> mmsdm_core::Result<Self::FieldMapping> {
        if !row.is_heading() {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!("Expected an I row but got {row:?}"),
                ),
            );
        }
        let row_key = mmsdm_core::FileKey::from_row(row.borrow())?;
        if !Self::matches_file_key(&row_key, row_key.version) {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!(
                        "Expected a row matching {}.{}.v{} but got {row_key}",
                        Self::DATA_SET_NAME, Self::TABLE_NAME, Self::VERSION
                    ),
                ),
            );
        }
        let mut base_mapping = Self::DEFAULT_FIELD_MAPPING.0;
        for (field_index, field) in Self::COLUMNS.iter().enumerate() {
            base_mapping[field_index] = row
                .iter_fields()
                .position(|f| f == *field)
                .unwrap_or(usize::MAX);
        }
        Ok(BillingRegionimports5Mapping(base_mapping))
    }
    fn matches_file_key(key: &mmsdm_core::FileKey<'_>, version: i32) -> bool {
        version == key.version && Self::DATA_SET_NAME == key.data_set_name()
            && Self::TABLE_NAME == key.table_name()
    }
    fn primary_key(row: &Self::Row<'_>) -> BillingRegionimports5PrimaryKey {
        BillingRegionimports5PrimaryKey {
            billrunno: row.billrunno,
            contractyear: row.contractyear,
            importfrom: row.importfrom().to_string(),
            regionid: row.regionid().to_string(),
            weekno: row.weekno,
        }
    }
    fn partition_value(&self, row: &Self::Row<'_>) -> mmsdm_core::PartitionValue {
        (self.extract_row_partition)(row)
    }
    fn partition_name(&self, row: &Self::Row<'_>) -> alloc::string::String {
        alloc::format!("billing_regionimports_v5_{}", self.partition_value(row))
    }
    fn partition_key(&self) -> mmsdm_core::PartitionKey {
        self.row_partition_key
    }
    fn to_static<'a>(row: &Self::Row<'a>) -> Self::Row<'static> {
        BillingRegionimports5Row {
            contractyear: row.contractyear.clone(),
            weekno: row.weekno.clone(),
            billrunno: row.billrunno.clone(),
            regionid: row.regionid.clone(),
            importfrom: row.importfrom.clone(),
            energy: row.energy.clone(),
            value: row.value.clone(),
            surplusenergy: row.surplusenergy.clone(),
            surplusvalue: row.surplusvalue.clone(),
            lastchanged: row.lastchanged.clone(),
            backing_data: row.backing_data.to_owned(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct BillingRegionimports5PrimaryKey {
    pub billrunno: rust_decimal::Decimal,
    pub contractyear: rust_decimal::Decimal,
    pub importfrom: alloc::string::String,
    pub regionid: alloc::string::String,
    pub weekno: rust_decimal::Decimal,
}
impl mmsdm_core::PrimaryKey for BillingRegionimports5PrimaryKey {}
impl<'data> mmsdm_core::CompareWithRow for BillingRegionimports5Row<'data> {
    type Row<'other> = BillingRegionimports5Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.importfrom() == row.importfrom() && self.regionid() == row.regionid()
            && self.weekno == row.weekno
    }
}
impl<'data> mmsdm_core::CompareWithPrimaryKey for BillingRegionimports5Row<'data> {
    type PrimaryKey = BillingRegionimports5PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.importfrom() == key.importfrom && self.regionid() == key.regionid
            && self.weekno == key.weekno
    }
}
impl<'data> mmsdm_core::CompareWithRow for BillingRegionimports5PrimaryKey {
    type Row<'other> = BillingRegionimports5Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.importfrom == row.importfrom() && self.regionid == row.regionid()
            && self.weekno == row.weekno
    }
}
impl mmsdm_core::CompareWithPrimaryKey for BillingRegionimports5PrimaryKey {
    type PrimaryKey = BillingRegionimports5PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.importfrom == key.importfrom && self.regionid == key.regionid
            && self.weekno == key.weekno
    }
}
#[cfg(feature = "arrow")]
impl mmsdm_core::ArrowSchema for BillingRegionimports5 {
    type Builder = BillingRegionimports5Builder;
    fn schema() -> arrow::datatypes::Schema {
        arrow::datatypes::Schema::new(
            alloc::vec::Vec::from([
                arrow::datatypes::Field::new(
                    "contractyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "weekno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "billrunno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "regionid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "importfrom",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "energy",
                    arrow::datatypes::DataType::Decimal128(16, 6),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "value",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "surplusenergy",
                    arrow::datatypes::DataType::Decimal128(16, 6),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "surplusvalue",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lastchanged",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    true,
                ),
            ]),
        )
    }
    fn new_builder() -> Self::Builder {
        BillingRegionimports5Builder {
            contractyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            weekno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            billrunno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            regionid_array: arrow::array::builder::StringBuilder::new(),
            importfrom_array: arrow::array::builder::StringBuilder::new(),
            energy_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(16, 6)),
            value_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            surplusenergy_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(16, 6)),
            surplusvalue_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
        }
    }
    fn append_builder(builder: &mut Self::Builder, row: Self::Row<'_>) {
        builder
            .contractyear_array
            .append_value({
                let mut val = row.contractyear;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .weekno_array
            .append_value({
                let mut val = row.weekno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .billrunno_array
            .append_value({
                let mut val = row.billrunno;
                val.rescale(0);
                val.mantissa()
            });
        builder.regionid_array.append_value(row.regionid());
        builder.importfrom_array.append_value(row.importfrom());
        builder
            .energy_array
            .append_option({
                row.energy
                    .map(|mut val| {
                        val.rescale(6);
                        val.mantissa()
                    })
            });
        builder
            .value_array
            .append_option({
                row.value
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .surplusenergy_array
            .append_option({
                row.surplusenergy
                    .map(|mut val| {
                        val.rescale(6);
                        val.mantissa()
                    })
            });
        builder
            .surplusvalue_array
            .append_option({
                row.surplusvalue
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .lastchanged_array
            .append_option(row.lastchanged.map(|val| val.and_utc().timestamp_millis()));
    }
    fn finalize_builder(
        builder: &mut Self::Builder,
    ) -> mmsdm_core::Result<arrow::array::RecordBatch> {
        arrow::array::RecordBatch::try_new(
                alloc::sync::Arc::new(<Self as mmsdm_core::ArrowSchema>::schema()),
                alloc::vec::Vec::from([
                    alloc::sync::Arc::new(builder.contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.regionid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.importfrom_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.energy_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.value_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.surplusenergy_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.surplusvalue_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lastchanged_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                ]),
            )
            .map_err(Into::into)
    }
}
#[cfg(feature = "arrow")]
pub struct BillingRegionimports5Builder {
    contractyear_array: arrow::array::builder::Decimal128Builder,
    weekno_array: arrow::array::builder::Decimal128Builder,
    billrunno_array: arrow::array::builder::Decimal128Builder,
    regionid_array: arrow::array::builder::StringBuilder,
    importfrom_array: arrow::array::builder::StringBuilder,
    energy_array: arrow::array::builder::Decimal128Builder,
    value_array: arrow::array::builder::Decimal128Builder,
    surplusenergy_array: arrow::array::builder::Decimal128Builder,
    surplusvalue_array: arrow::array::builder::Decimal128Builder,
    lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder,
}
pub struct BillingRuntrk5 {
    extract_row_partition: alloc::boxed::Box<
        dyn Fn(
            &BillingRuntrk5Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    >,
    row_partition_key: mmsdm_core::PartitionKey,
}
impl BillingRuntrk5 {
    pub fn new(
        row_partition_key: mmsdm_core::PartitionKey,
        func: impl Fn(
            &<Self as mmsdm_core::GetTable>::Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    ) -> Self {
        Self {
            extract_row_partition: alloc::boxed::Box::new(func),
            row_partition_key,
        }
    }
}
pub struct BillingRuntrk5Mapping([usize; 16]);
/// # Summary
///
/// ## BILLINGRUNTRK
///  _BILLINGRUNTRK identifies the Statement type (i.e. Status of PRELIM, FINAL, REVISE) and date of the BillRunNo posted, per WeekNo. This provides a further extension of tracking data from the BILLINGDAYTRK table._
///
/// * Data Set Name: Billing
/// * File Name: Runtrk
/// * Data Version: 5
///
/// # Description
///  BILLINGRUNTRK is public data, and is available to all participants. Source BILLINGRUNTRK is populated by the posting of a billing run. Volume An indicative maximum is one record inserted per billing run, or 11 records inserted per week.
///
///
///
/// # Primary Key Columns
///
/// * BILLRUNNO
/// * CONTRACTYEAR
/// * WEEKNO
#[derive(Debug, PartialEq, Eq)]
pub struct BillingRuntrk5Row<'data> {
    /// Year of the run
    pub contractyear: rust_decimal::Decimal,
    /// Week number of the run
    pub weekno: rust_decimal::Decimal,
    /// Sequential run number
    pub billrunno: rust_decimal::Decimal,
    /// The billing run type, PRELIM, FINAL, REVISE or INTERIM
    pub status: core::ops::Range<usize>,
    /// Flag
    pub adj_cleared: core::ops::Range<usize>,
    /// null, since not used
    pub authoriseddate: Option<chrono::NaiveDateTime>,
    /// null, since not used
    pub authorisedby: core::ops::Range<usize>,
    /// When the results were posted
    pub postdate: Option<chrono::NaiveDateTime>,
    /// Who posted the results
    pub postby: core::ops::Range<usize>,
    /// Last date and time record changed
    pub lastchanged: Option<chrono::NaiveDateTime>,
    /// null, since not used
    pub receiptpostdate: Option<chrono::NaiveDateTime>,
    /// null, since not used
    pub receiptpostby: core::ops::Range<usize>,
    /// When the payment was posted
    pub paymentpostdate: Option<chrono::NaiveDateTime>,
    /// Who posted the payment
    pub paymentpostby: core::ops::Range<usize>,
    /// Payment shortfall amount
    pub shortfall: Option<rust_decimal::Decimal>,
    /// Not Used
    pub makeup: Option<rust_decimal::Decimal>,
    backing_data: mmsdm_core::CsvRow<'data>,
}
impl<'data> BillingRuntrk5Row<'data> {
    pub fn status(&self) -> Option<&str> {
        if self.status.is_empty() {
            None
        } else {
            Some(
                core::ops::Index::index(
                    self.backing_data.as_slice(),
                    self.status.clone(),
                ),
            )
        }
    }
    pub fn adj_cleared(&self) -> Option<&str> {
        if self.adj_cleared.is_empty() {
            None
        } else {
            Some(
                core::ops::Index::index(
                    self.backing_data.as_slice(),
                    self.adj_cleared.clone(),
                ),
            )
        }
    }
    pub fn authorisedby(&self) -> Option<&str> {
        if self.authorisedby.is_empty() {
            None
        } else {
            Some(
                core::ops::Index::index(
                    self.backing_data.as_slice(),
                    self.authorisedby.clone(),
                ),
            )
        }
    }
    pub fn postby(&self) -> Option<&str> {
        if self.postby.is_empty() {
            None
        } else {
            Some(
                core::ops::Index::index(
                    self.backing_data.as_slice(),
                    self.postby.clone(),
                ),
            )
        }
    }
    pub fn receiptpostby(&self) -> Option<&str> {
        if self.receiptpostby.is_empty() {
            None
        } else {
            Some(
                core::ops::Index::index(
                    self.backing_data.as_slice(),
                    self.receiptpostby.clone(),
                ),
            )
        }
    }
    pub fn paymentpostby(&self) -> Option<&str> {
        if self.paymentpostby.is_empty() {
            None
        } else {
            Some(
                core::ops::Index::index(
                    self.backing_data.as_slice(),
                    self.paymentpostby.clone(),
                ),
            )
        }
    }
}
impl mmsdm_core::GetTable for BillingRuntrk5 {
    const VERSION: i32 = 5;
    const DATA_SET_NAME: &'static str = "BILLING";
    const TABLE_NAME: &'static str = "RUNTRK";
    const DEFAULT_FIELD_MAPPING: Self::FieldMapping = BillingRuntrk5Mapping([
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
    ]);
    const COLUMNS: &'static [&'static str] = &[
        "CONTRACTYEAR",
        "WEEKNO",
        "BILLRUNNO",
        "STATUS",
        "ADJ_CLEARED",
        "AUTHORISEDDATE",
        "AUTHORISEDBY",
        "POSTDATE",
        "POSTBY",
        "LASTCHANGED",
        "RECEIPTPOSTDATE",
        "RECEIPTPOSTBY",
        "PAYMENTPOSTDATE",
        "PAYMENTPOSTBY",
        "SHORTFALL",
        "MAKEUP",
    ];
    type Row<'row> = BillingRuntrk5Row<'row>;
    type FieldMapping = BillingRuntrk5Mapping;
    type PrimaryKey = BillingRuntrk5PrimaryKey;
    fn from_row<'data>(
        row: mmsdm_core::CsvRow<'data>,
        field_mapping: &Self::FieldMapping,
    ) -> mmsdm_core::Result<Self::Row<'data>> {
        Ok(BillingRuntrk5Row {
            contractyear: row
                .get_custom_parsed_at_idx(
                    "contractyear",
                    field_mapping.0[0],
                    mmsdm_core::mms_decimal::parse,
                )?,
            weekno: row
                .get_custom_parsed_at_idx(
                    "weekno",
                    field_mapping.0[1],
                    mmsdm_core::mms_decimal::parse,
                )?,
            billrunno: row
                .get_custom_parsed_at_idx(
                    "billrunno",
                    field_mapping.0[2],
                    mmsdm_core::mms_decimal::parse,
                )?,
            status: row.get_opt_range("status", field_mapping.0[3])?,
            adj_cleared: row.get_opt_range("adj_cleared", field_mapping.0[4])?,
            authoriseddate: row
                .get_opt_custom_parsed_at_idx(
                    "authoriseddate",
                    field_mapping.0[5],
                    mmsdm_core::mms_datetime::parse,
                )?,
            authorisedby: row.get_opt_range("authorisedby", field_mapping.0[6])?,
            postdate: row
                .get_opt_custom_parsed_at_idx(
                    "postdate",
                    field_mapping.0[7],
                    mmsdm_core::mms_datetime::parse,
                )?,
            postby: row.get_opt_range("postby", field_mapping.0[8])?,
            lastchanged: row
                .get_opt_custom_parsed_at_idx(
                    "lastchanged",
                    field_mapping.0[9],
                    mmsdm_core::mms_datetime::parse,
                )?,
            receiptpostdate: row
                .get_opt_custom_parsed_at_idx(
                    "receiptpostdate",
                    field_mapping.0[10],
                    mmsdm_core::mms_datetime::parse,
                )?,
            receiptpostby: row.get_opt_range("receiptpostby", field_mapping.0[11])?,
            paymentpostdate: row
                .get_opt_custom_parsed_at_idx(
                    "paymentpostdate",
                    field_mapping.0[12],
                    mmsdm_core::mms_datetime::parse,
                )?,
            paymentpostby: row.get_opt_range("paymentpostby", field_mapping.0[13])?,
            shortfall: row
                .get_opt_custom_parsed_at_idx(
                    "shortfall",
                    field_mapping.0[14],
                    mmsdm_core::mms_decimal::parse,
                )?,
            makeup: row
                .get_opt_custom_parsed_at_idx(
                    "makeup",
                    field_mapping.0[15],
                    mmsdm_core::mms_decimal::parse,
                )?,
            backing_data: row,
        })
    }
    fn field_mapping_from_row<'a>(
        mut row: mmsdm_core::CsvRow<'a>,
    ) -> mmsdm_core::Result<Self::FieldMapping> {
        if !row.is_heading() {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!("Expected an I row but got {row:?}"),
                ),
            );
        }
        let row_key = mmsdm_core::FileKey::from_row(row.borrow())?;
        if !Self::matches_file_key(&row_key, row_key.version) {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!(
                        "Expected a row matching {}.{}.v{} but got {row_key}",
                        Self::DATA_SET_NAME, Self::TABLE_NAME, Self::VERSION
                    ),
                ),
            );
        }
        let mut base_mapping = Self::DEFAULT_FIELD_MAPPING.0;
        for (field_index, field) in Self::COLUMNS.iter().enumerate() {
            base_mapping[field_index] = row
                .iter_fields()
                .position(|f| f == *field)
                .unwrap_or(usize::MAX);
        }
        Ok(BillingRuntrk5Mapping(base_mapping))
    }
    fn matches_file_key(key: &mmsdm_core::FileKey<'_>, version: i32) -> bool {
        version == key.version && Self::DATA_SET_NAME == key.data_set_name()
            && Self::TABLE_NAME == key.table_name()
    }
    fn primary_key(row: &Self::Row<'_>) -> BillingRuntrk5PrimaryKey {
        BillingRuntrk5PrimaryKey {
            billrunno: row.billrunno,
            contractyear: row.contractyear,
            weekno: row.weekno,
        }
    }
    fn partition_value(&self, row: &Self::Row<'_>) -> mmsdm_core::PartitionValue {
        (self.extract_row_partition)(row)
    }
    fn partition_name(&self, row: &Self::Row<'_>) -> alloc::string::String {
        alloc::format!("billing_runtrk_v5_{}", self.partition_value(row))
    }
    fn partition_key(&self) -> mmsdm_core::PartitionKey {
        self.row_partition_key
    }
    fn to_static<'a>(row: &Self::Row<'a>) -> Self::Row<'static> {
        BillingRuntrk5Row {
            contractyear: row.contractyear.clone(),
            weekno: row.weekno.clone(),
            billrunno: row.billrunno.clone(),
            status: row.status.clone(),
            adj_cleared: row.adj_cleared.clone(),
            authoriseddate: row.authoriseddate.clone(),
            authorisedby: row.authorisedby.clone(),
            postdate: row.postdate.clone(),
            postby: row.postby.clone(),
            lastchanged: row.lastchanged.clone(),
            receiptpostdate: row.receiptpostdate.clone(),
            receiptpostby: row.receiptpostby.clone(),
            paymentpostdate: row.paymentpostdate.clone(),
            paymentpostby: row.paymentpostby.clone(),
            shortfall: row.shortfall.clone(),
            makeup: row.makeup.clone(),
            backing_data: row.backing_data.to_owned(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct BillingRuntrk5PrimaryKey {
    pub billrunno: rust_decimal::Decimal,
    pub contractyear: rust_decimal::Decimal,
    pub weekno: rust_decimal::Decimal,
}
impl mmsdm_core::PrimaryKey for BillingRuntrk5PrimaryKey {}
impl<'data> mmsdm_core::CompareWithRow for BillingRuntrk5Row<'data> {
    type Row<'other> = BillingRuntrk5Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.weekno == row.weekno
    }
}
impl<'data> mmsdm_core::CompareWithPrimaryKey for BillingRuntrk5Row<'data> {
    type PrimaryKey = BillingRuntrk5PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.weekno == key.weekno
    }
}
impl<'data> mmsdm_core::CompareWithRow for BillingRuntrk5PrimaryKey {
    type Row<'other> = BillingRuntrk5Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.weekno == row.weekno
    }
}
impl mmsdm_core::CompareWithPrimaryKey for BillingRuntrk5PrimaryKey {
    type PrimaryKey = BillingRuntrk5PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.weekno == key.weekno
    }
}
#[cfg(feature = "arrow")]
impl mmsdm_core::ArrowSchema for BillingRuntrk5 {
    type Builder = BillingRuntrk5Builder;
    fn schema() -> arrow::datatypes::Schema {
        arrow::datatypes::Schema::new(
            alloc::vec::Vec::from([
                arrow::datatypes::Field::new(
                    "contractyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "weekno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "billrunno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "status",
                    arrow::datatypes::DataType::Utf8,
                    true,
                ),
                arrow::datatypes::Field::new(
                    "adj_cleared",
                    arrow::datatypes::DataType::Utf8,
                    true,
                ),
                arrow::datatypes::Field::new(
                    "authoriseddate",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "authorisedby",
                    arrow::datatypes::DataType::Utf8,
                    true,
                ),
                arrow::datatypes::Field::new(
                    "postdate",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "postby",
                    arrow::datatypes::DataType::Utf8,
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lastchanged",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "receiptpostdate",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "receiptpostby",
                    arrow::datatypes::DataType::Utf8,
                    true,
                ),
                arrow::datatypes::Field::new(
                    "paymentpostdate",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "paymentpostby",
                    arrow::datatypes::DataType::Utf8,
                    true,
                ),
                arrow::datatypes::Field::new(
                    "shortfall",
                    arrow::datatypes::DataType::Decimal128(16, 6),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "makeup",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
            ]),
        )
    }
    fn new_builder() -> Self::Builder {
        BillingRuntrk5Builder {
            contractyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            weekno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            billrunno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            status_array: arrow::array::builder::StringBuilder::new(),
            adj_cleared_array: arrow::array::builder::StringBuilder::new(),
            authoriseddate_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
            authorisedby_array: arrow::array::builder::StringBuilder::new(),
            postdate_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
            postby_array: arrow::array::builder::StringBuilder::new(),
            lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
            receiptpostdate_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
            receiptpostby_array: arrow::array::builder::StringBuilder::new(),
            paymentpostdate_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
            paymentpostby_array: arrow::array::builder::StringBuilder::new(),
            shortfall_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(16, 6)),
            makeup_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
        }
    }
    fn append_builder(builder: &mut Self::Builder, row: Self::Row<'_>) {
        builder
            .contractyear_array
            .append_value({
                let mut val = row.contractyear;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .weekno_array
            .append_value({
                let mut val = row.weekno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .billrunno_array
            .append_value({
                let mut val = row.billrunno;
                val.rescale(0);
                val.mantissa()
            });
        builder.status_array.append_option(row.status());
        builder.adj_cleared_array.append_option(row.adj_cleared());
        builder
            .authoriseddate_array
            .append_option(
                row.authoriseddate.map(|val| val.and_utc().timestamp_millis()),
            );
        builder.authorisedby_array.append_option(row.authorisedby());
        builder
            .postdate_array
            .append_option(row.postdate.map(|val| val.and_utc().timestamp_millis()));
        builder.postby_array.append_option(row.postby());
        builder
            .lastchanged_array
            .append_option(row.lastchanged.map(|val| val.and_utc().timestamp_millis()));
        builder
            .receiptpostdate_array
            .append_option(
                row.receiptpostdate.map(|val| val.and_utc().timestamp_millis()),
            );
        builder.receiptpostby_array.append_option(row.receiptpostby());
        builder
            .paymentpostdate_array
            .append_option(
                row.paymentpostdate.map(|val| val.and_utc().timestamp_millis()),
            );
        builder.paymentpostby_array.append_option(row.paymentpostby());
        builder
            .shortfall_array
            .append_option({
                row.shortfall
                    .map(|mut val| {
                        val.rescale(6);
                        val.mantissa()
                    })
            });
        builder
            .makeup_array
            .append_option({
                row.makeup
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
    }
    fn finalize_builder(
        builder: &mut Self::Builder,
    ) -> mmsdm_core::Result<arrow::array::RecordBatch> {
        arrow::array::RecordBatch::try_new(
                alloc::sync::Arc::new(<Self as mmsdm_core::ArrowSchema>::schema()),
                alloc::vec::Vec::from([
                    alloc::sync::Arc::new(builder.contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.status_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.adj_cleared_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.authoriseddate_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.authorisedby_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.postdate_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.postby_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lastchanged_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.receiptpostdate_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.receiptpostby_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.paymentpostdate_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.paymentpostby_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.shortfall_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.makeup_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                ]),
            )
            .map_err(Into::into)
    }
}
#[cfg(feature = "arrow")]
pub struct BillingRuntrk5Builder {
    contractyear_array: arrow::array::builder::Decimal128Builder,
    weekno_array: arrow::array::builder::Decimal128Builder,
    billrunno_array: arrow::array::builder::Decimal128Builder,
    status_array: arrow::array::builder::StringBuilder,
    adj_cleared_array: arrow::array::builder::StringBuilder,
    authoriseddate_array: arrow::array::builder::TimestampMillisecondBuilder,
    authorisedby_array: arrow::array::builder::StringBuilder,
    postdate_array: arrow::array::builder::TimestampMillisecondBuilder,
    postby_array: arrow::array::builder::StringBuilder,
    lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder,
    receiptpostdate_array: arrow::array::builder::TimestampMillisecondBuilder,
    receiptpostby_array: arrow::array::builder::StringBuilder,
    paymentpostdate_array: arrow::array::builder::TimestampMillisecondBuilder,
    paymentpostby_array: arrow::array::builder::StringBuilder,
    shortfall_array: arrow::array::builder::Decimal128Builder,
    makeup_array: arrow::array::builder::Decimal128Builder,
}
pub struct BillingApcCompensation2 {
    extract_row_partition: alloc::boxed::Box<
        dyn Fn(
            &BillingApcCompensation2Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    >,
    row_partition_key: mmsdm_core::PartitionKey,
}
impl BillingApcCompensation2 {
    pub fn new(
        row_partition_key: mmsdm_core::PartitionKey,
        func: impl Fn(
            &<Self as mmsdm_core::GetTable>::Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    ) -> Self {
        Self {
            extract_row_partition: alloc::boxed::Box::new(func),
            row_partition_key,
        }
    }
}
pub struct BillingApcCompensation2Mapping([usize; 10]);
/// # Summary
///
/// ## BILLING_APC_COMPENSATION
///  _Billing result table for APC compensation payments._
///
/// * Data Set Name: Billing
/// * File Name: Apc Compensation
/// * Data Version: 2
///
/// # Description
///  Updated with each billing run
///
///
///
/// # Primary Key Columns
///
/// * APEVENTID
/// * BILLRUNNO
/// * CLAIMID
/// * CONTRACTYEAR
/// * WEEKNO
#[derive(Debug, PartialEq, Eq)]
pub struct BillingApcCompensation2Row<'data> {
    /// Billing contract year
    pub contractyear: i64,
    /// Billing week number
    pub weekno: i64,
    /// Billing run number
    pub billrunno: i64,
    /// AP Event Id
    pub apeventid: i64,
    /// AP Event Claim Id
    pub claimid: i64,
    /// Participant identifier
    pub participantid: core::ops::Range<usize>,
    /// Payment amount to the participant
    pub compensation_amount: Option<rust_decimal::Decimal>,
    /// The Administered Price Event Type. Valid values: ENERGY, FCAS, BOTH
    pub event_type: core::ops::Range<usize>,
    /// The Type of Administered Price Compensation Claim. Valid values: DIRECT_COST, OTHER_COST
    pub compensation_type: core::ops::Range<usize>,
    /// The date and time of last changed record
    pub lastchanged: Option<chrono::NaiveDateTime>,
    backing_data: mmsdm_core::CsvRow<'data>,
}
impl<'data> BillingApcCompensation2Row<'data> {
    pub fn participantid(&self) -> Option<&str> {
        if self.participantid.is_empty() {
            None
        } else {
            Some(
                core::ops::Index::index(
                    self.backing_data.as_slice(),
                    self.participantid.clone(),
                ),
            )
        }
    }
    pub fn event_type(&self) -> Option<&str> {
        if self.event_type.is_empty() {
            None
        } else {
            Some(
                core::ops::Index::index(
                    self.backing_data.as_slice(),
                    self.event_type.clone(),
                ),
            )
        }
    }
    pub fn compensation_type(&self) -> Option<&str> {
        if self.compensation_type.is_empty() {
            None
        } else {
            Some(
                core::ops::Index::index(
                    self.backing_data.as_slice(),
                    self.compensation_type.clone(),
                ),
            )
        }
    }
}
impl mmsdm_core::GetTable for BillingApcCompensation2 {
    const VERSION: i32 = 2;
    const DATA_SET_NAME: &'static str = "BILLING";
    const TABLE_NAME: &'static str = "APC_COMPENSATION";
    const DEFAULT_FIELD_MAPPING: Self::FieldMapping = BillingApcCompensation2Mapping([
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
    ]);
    const COLUMNS: &'static [&'static str] = &[
        "CONTRACTYEAR",
        "WEEKNO",
        "BILLRUNNO",
        "APEVENTID",
        "CLAIMID",
        "PARTICIPANTID",
        "COMPENSATION_AMOUNT",
        "EVENT_TYPE",
        "COMPENSATION_TYPE",
        "LASTCHANGED",
    ];
    type Row<'row> = BillingApcCompensation2Row<'row>;
    type FieldMapping = BillingApcCompensation2Mapping;
    type PrimaryKey = BillingApcCompensation2PrimaryKey;
    fn from_row<'data>(
        row: mmsdm_core::CsvRow<'data>,
        field_mapping: &Self::FieldMapping,
    ) -> mmsdm_core::Result<Self::Row<'data>> {
        Ok(BillingApcCompensation2Row {
            contractyear: row.get_parsed_at_idx("contractyear", field_mapping.0[0])?,
            weekno: row.get_parsed_at_idx("weekno", field_mapping.0[1])?,
            billrunno: row.get_parsed_at_idx("billrunno", field_mapping.0[2])?,
            apeventid: row.get_parsed_at_idx("apeventid", field_mapping.0[3])?,
            claimid: row.get_parsed_at_idx("claimid", field_mapping.0[4])?,
            participantid: row.get_opt_range("participantid", field_mapping.0[5])?,
            compensation_amount: row
                .get_opt_custom_parsed_at_idx(
                    "compensation_amount",
                    field_mapping.0[6],
                    mmsdm_core::mms_decimal::parse,
                )?,
            event_type: row.get_opt_range("event_type", field_mapping.0[7])?,
            compensation_type: row
                .get_opt_range("compensation_type", field_mapping.0[8])?,
            lastchanged: row
                .get_opt_custom_parsed_at_idx(
                    "lastchanged",
                    field_mapping.0[9],
                    mmsdm_core::mms_datetime::parse,
                )?,
            backing_data: row,
        })
    }
    fn field_mapping_from_row<'a>(
        mut row: mmsdm_core::CsvRow<'a>,
    ) -> mmsdm_core::Result<Self::FieldMapping> {
        if !row.is_heading() {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!("Expected an I row but got {row:?}"),
                ),
            );
        }
        let row_key = mmsdm_core::FileKey::from_row(row.borrow())?;
        if !Self::matches_file_key(&row_key, row_key.version) {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!(
                        "Expected a row matching {}.{}.v{} but got {row_key}",
                        Self::DATA_SET_NAME, Self::TABLE_NAME, Self::VERSION
                    ),
                ),
            );
        }
        let mut base_mapping = Self::DEFAULT_FIELD_MAPPING.0;
        for (field_index, field) in Self::COLUMNS.iter().enumerate() {
            base_mapping[field_index] = row
                .iter_fields()
                .position(|f| f == *field)
                .unwrap_or(usize::MAX);
        }
        Ok(BillingApcCompensation2Mapping(base_mapping))
    }
    fn matches_file_key(key: &mmsdm_core::FileKey<'_>, version: i32) -> bool {
        version == key.version && Self::DATA_SET_NAME == key.data_set_name()
            && Self::TABLE_NAME == key.table_name()
    }
    fn primary_key(row: &Self::Row<'_>) -> BillingApcCompensation2PrimaryKey {
        BillingApcCompensation2PrimaryKey {
            apeventid: row.apeventid,
            billrunno: row.billrunno,
            claimid: row.claimid,
            contractyear: row.contractyear,
            weekno: row.weekno,
        }
    }
    fn partition_value(&self, row: &Self::Row<'_>) -> mmsdm_core::PartitionValue {
        (self.extract_row_partition)(row)
    }
    fn partition_name(&self, row: &Self::Row<'_>) -> alloc::string::String {
        alloc::format!("billing_apc_compensation_v2_{}", self.partition_value(row))
    }
    fn partition_key(&self) -> mmsdm_core::PartitionKey {
        self.row_partition_key
    }
    fn to_static<'a>(row: &Self::Row<'a>) -> Self::Row<'static> {
        BillingApcCompensation2Row {
            contractyear: row.contractyear.clone(),
            weekno: row.weekno.clone(),
            billrunno: row.billrunno.clone(),
            apeventid: row.apeventid.clone(),
            claimid: row.claimid.clone(),
            participantid: row.participantid.clone(),
            compensation_amount: row.compensation_amount.clone(),
            event_type: row.event_type.clone(),
            compensation_type: row.compensation_type.clone(),
            lastchanged: row.lastchanged.clone(),
            backing_data: row.backing_data.to_owned(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct BillingApcCompensation2PrimaryKey {
    pub apeventid: i64,
    pub billrunno: i64,
    pub claimid: i64,
    pub contractyear: i64,
    pub weekno: i64,
}
impl mmsdm_core::PrimaryKey for BillingApcCompensation2PrimaryKey {}
impl<'data> mmsdm_core::CompareWithRow for BillingApcCompensation2Row<'data> {
    type Row<'other> = BillingApcCompensation2Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.apeventid == row.apeventid && self.billrunno == row.billrunno
            && self.claimid == row.claimid && self.contractyear == row.contractyear
            && self.weekno == row.weekno
    }
}
impl<'data> mmsdm_core::CompareWithPrimaryKey for BillingApcCompensation2Row<'data> {
    type PrimaryKey = BillingApcCompensation2PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.apeventid == key.apeventid && self.billrunno == key.billrunno
            && self.claimid == key.claimid && self.contractyear == key.contractyear
            && self.weekno == key.weekno
    }
}
impl<'data> mmsdm_core::CompareWithRow for BillingApcCompensation2PrimaryKey {
    type Row<'other> = BillingApcCompensation2Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.apeventid == row.apeventid && self.billrunno == row.billrunno
            && self.claimid == row.claimid && self.contractyear == row.contractyear
            && self.weekno == row.weekno
    }
}
impl mmsdm_core::CompareWithPrimaryKey for BillingApcCompensation2PrimaryKey {
    type PrimaryKey = BillingApcCompensation2PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.apeventid == key.apeventid && self.billrunno == key.billrunno
            && self.claimid == key.claimid && self.contractyear == key.contractyear
            && self.weekno == key.weekno
    }
}
#[cfg(feature = "arrow")]
impl mmsdm_core::ArrowSchema for BillingApcCompensation2 {
    type Builder = BillingApcCompensation2Builder;
    fn schema() -> arrow::datatypes::Schema {
        arrow::datatypes::Schema::new(
            alloc::vec::Vec::from([
                arrow::datatypes::Field::new(
                    "contractyear",
                    arrow::datatypes::DataType::Int64,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "weekno",
                    arrow::datatypes::DataType::Int64,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "billrunno",
                    arrow::datatypes::DataType::Int64,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "apeventid",
                    arrow::datatypes::DataType::Int64,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "claimid",
                    arrow::datatypes::DataType::Int64,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "participantid",
                    arrow::datatypes::DataType::Utf8,
                    true,
                ),
                arrow::datatypes::Field::new(
                    "compensation_amount",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "event_type",
                    arrow::datatypes::DataType::Utf8,
                    true,
                ),
                arrow::datatypes::Field::new(
                    "compensation_type",
                    arrow::datatypes::DataType::Utf8,
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lastchanged",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    true,
                ),
            ]),
        )
    }
    fn new_builder() -> Self::Builder {
        BillingApcCompensation2Builder {
            contractyear_array: arrow::array::builder::Int64Builder::new(),
            weekno_array: arrow::array::builder::Int64Builder::new(),
            billrunno_array: arrow::array::builder::Int64Builder::new(),
            apeventid_array: arrow::array::builder::Int64Builder::new(),
            claimid_array: arrow::array::builder::Int64Builder::new(),
            participantid_array: arrow::array::builder::StringBuilder::new(),
            compensation_amount_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            event_type_array: arrow::array::builder::StringBuilder::new(),
            compensation_type_array: arrow::array::builder::StringBuilder::new(),
            lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
        }
    }
    fn append_builder(builder: &mut Self::Builder, row: Self::Row<'_>) {
        builder.contractyear_array.append_value(row.contractyear);
        builder.weekno_array.append_value(row.weekno);
        builder.billrunno_array.append_value(row.billrunno);
        builder.apeventid_array.append_value(row.apeventid);
        builder.claimid_array.append_value(row.claimid);
        builder.participantid_array.append_option(row.participantid());
        builder
            .compensation_amount_array
            .append_option({
                row.compensation_amount
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder.event_type_array.append_option(row.event_type());
        builder.compensation_type_array.append_option(row.compensation_type());
        builder
            .lastchanged_array
            .append_option(row.lastchanged.map(|val| val.and_utc().timestamp_millis()));
    }
    fn finalize_builder(
        builder: &mut Self::Builder,
    ) -> mmsdm_core::Result<arrow::array::RecordBatch> {
        arrow::array::RecordBatch::try_new(
                alloc::sync::Arc::new(<Self as mmsdm_core::ArrowSchema>::schema()),
                alloc::vec::Vec::from([
                    alloc::sync::Arc::new(builder.contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.apeventid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.claimid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.participantid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.compensation_amount_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.event_type_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.compensation_type_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lastchanged_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                ]),
            )
            .map_err(Into::into)
    }
}
#[cfg(feature = "arrow")]
pub struct BillingApcCompensation2Builder {
    contractyear_array: arrow::array::builder::Int64Builder,
    weekno_array: arrow::array::builder::Int64Builder,
    billrunno_array: arrow::array::builder::Int64Builder,
    apeventid_array: arrow::array::builder::Int64Builder,
    claimid_array: arrow::array::builder::Int64Builder,
    participantid_array: arrow::array::builder::StringBuilder,
    compensation_amount_array: arrow::array::builder::Decimal128Builder,
    event_type_array: arrow::array::builder::StringBuilder,
    compensation_type_array: arrow::array::builder::StringBuilder,
    lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder,
}
pub struct BillingApcRecovery3 {
    extract_row_partition: alloc::boxed::Box<
        dyn Fn(
            &BillingApcRecovery3Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    >,
    row_partition_key: mmsdm_core::PartitionKey,
}
impl BillingApcRecovery3 {
    pub fn new(
        row_partition_key: mmsdm_core::PartitionKey,
        func: impl Fn(
            &<Self as mmsdm_core::GetTable>::Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    ) -> Self {
        Self {
            extract_row_partition: alloc::boxed::Box::new(func),
            row_partition_key,
        }
    }
}
pub struct BillingApcRecovery3Mapping([usize; 15]);
/// # Summary
///
/// ## BILLING_APC_RECOVERY
///  _Billing result table for recovery of APC compensation payments_
///
/// * Data Set Name: Billing
/// * File Name: Apc Recovery
/// * Data Version: 3
///
/// # Description
///  Updated with each billing run
///
///
///
/// # Primary Key Columns
///
/// * APEVENTID
/// * BILLRUNNO
/// * CLAIMID
/// * CONTRACTYEAR
/// * PARTICIPANTID
/// * REGIONID
/// * WEEKNO
#[derive(Debug, PartialEq, Eq)]
pub struct BillingApcRecovery3Row<'data> {
    /// Billing contract year
    pub contractyear: i64,
    /// Billing week number
    pub weekno: i64,
    /// Billing run number
    pub billrunno: i64,
    /// AP Event Id
    pub apeventid: i64,
    /// AP Event Claim Id
    pub claimid: i64,
    /// Participant identifier
    pub participantid: core::ops::Range<usize>,
    /// Region Identifier
    pub regionid: core::ops::Range<usize>,
    /// Recovery amount attributable to the participant in that region
    pub recovery_amount: Option<rust_decimal::Decimal>,
    /// The starting half hourly interval for the eligibility period for recovery of APC Payment
    pub eligibility_start_interval: Option<chrono::NaiveDateTime>,
    /// The ending half hourly interval for the eligibility period for recovery of APC Payment
    pub eligibility_end_interval: Option<chrono::NaiveDateTime>,
    /// The participant demand in the cost recovery region
    pub participant_demand: Option<rust_decimal::Decimal>,
    /// The sum of demand of all participants in the cost recovery region (Region Sum)
    pub region_demand: Option<rust_decimal::Decimal>,
    /// The date and time of last changed record
    pub lastchanged: Option<chrono::NaiveDateTime>,
    /// The ACE MWh value of the participant from the Eligibility Interval used for the APC Recovery Calculation. If the Billing Week is prior to the IESS rule effective date, then value is Null.
    pub participant_ace_mwh: Option<rust_decimal::Decimal>,
    /// The ACE MWh value of the Region from the Eligibility Interval used for the APC Recovery Calculation. This is the sum of the ACE MWh of all the participants in that recovery. If the Billing Week is prior to the IESS rule effective date, then value is Null.
    pub region_ace_mwh: Option<rust_decimal::Decimal>,
    backing_data: mmsdm_core::CsvRow<'data>,
}
impl<'data> BillingApcRecovery3Row<'data> {
    pub fn participantid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.participantid.clone())
    }
    pub fn regionid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.regionid.clone())
    }
}
impl mmsdm_core::GetTable for BillingApcRecovery3 {
    const VERSION: i32 = 3;
    const DATA_SET_NAME: &'static str = "BILLING";
    const TABLE_NAME: &'static str = "APC_RECOVERY";
    const DEFAULT_FIELD_MAPPING: Self::FieldMapping = BillingApcRecovery3Mapping([
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
    ]);
    const COLUMNS: &'static [&'static str] = &[
        "CONTRACTYEAR",
        "WEEKNO",
        "BILLRUNNO",
        "APEVENTID",
        "CLAIMID",
        "PARTICIPANTID",
        "REGIONID",
        "RECOVERY_AMOUNT",
        "ELIGIBILITY_START_INTERVAL",
        "ELIGIBILITY_END_INTERVAL",
        "PARTICIPANT_DEMAND",
        "REGION_DEMAND",
        "LASTCHANGED",
        "PARTICIPANT_ACE_MWH",
        "REGION_ACE_MWH",
    ];
    type Row<'row> = BillingApcRecovery3Row<'row>;
    type FieldMapping = BillingApcRecovery3Mapping;
    type PrimaryKey = BillingApcRecovery3PrimaryKey;
    fn from_row<'data>(
        row: mmsdm_core::CsvRow<'data>,
        field_mapping: &Self::FieldMapping,
    ) -> mmsdm_core::Result<Self::Row<'data>> {
        Ok(BillingApcRecovery3Row {
            contractyear: row.get_parsed_at_idx("contractyear", field_mapping.0[0])?,
            weekno: row.get_parsed_at_idx("weekno", field_mapping.0[1])?,
            billrunno: row.get_parsed_at_idx("billrunno", field_mapping.0[2])?,
            apeventid: row.get_parsed_at_idx("apeventid", field_mapping.0[3])?,
            claimid: row.get_parsed_at_idx("claimid", field_mapping.0[4])?,
            participantid: row.get_range("participantid", field_mapping.0[5])?,
            regionid: row.get_range("regionid", field_mapping.0[6])?,
            recovery_amount: row
                .get_opt_custom_parsed_at_idx(
                    "recovery_amount",
                    field_mapping.0[7],
                    mmsdm_core::mms_decimal::parse,
                )?,
            eligibility_start_interval: row
                .get_opt_custom_parsed_at_idx(
                    "eligibility_start_interval",
                    field_mapping.0[8],
                    mmsdm_core::mms_datetime::parse,
                )?,
            eligibility_end_interval: row
                .get_opt_custom_parsed_at_idx(
                    "eligibility_end_interval",
                    field_mapping.0[9],
                    mmsdm_core::mms_datetime::parse,
                )?,
            participant_demand: row
                .get_opt_custom_parsed_at_idx(
                    "participant_demand",
                    field_mapping.0[10],
                    mmsdm_core::mms_decimal::parse,
                )?,
            region_demand: row
                .get_opt_custom_parsed_at_idx(
                    "region_demand",
                    field_mapping.0[11],
                    mmsdm_core::mms_decimal::parse,
                )?,
            lastchanged: row
                .get_opt_custom_parsed_at_idx(
                    "lastchanged",
                    field_mapping.0[12],
                    mmsdm_core::mms_datetime::parse,
                )?,
            participant_ace_mwh: row
                .get_opt_custom_parsed_at_idx(
                    "participant_ace_mwh",
                    field_mapping.0[13],
                    mmsdm_core::mms_decimal::parse,
                )?,
            region_ace_mwh: row
                .get_opt_custom_parsed_at_idx(
                    "region_ace_mwh",
                    field_mapping.0[14],
                    mmsdm_core::mms_decimal::parse,
                )?,
            backing_data: row,
        })
    }
    fn field_mapping_from_row<'a>(
        mut row: mmsdm_core::CsvRow<'a>,
    ) -> mmsdm_core::Result<Self::FieldMapping> {
        if !row.is_heading() {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!("Expected an I row but got {row:?}"),
                ),
            );
        }
        let row_key = mmsdm_core::FileKey::from_row(row.borrow())?;
        if !Self::matches_file_key(&row_key, row_key.version) {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!(
                        "Expected a row matching {}.{}.v{} but got {row_key}",
                        Self::DATA_SET_NAME, Self::TABLE_NAME, Self::VERSION
                    ),
                ),
            );
        }
        let mut base_mapping = Self::DEFAULT_FIELD_MAPPING.0;
        for (field_index, field) in Self::COLUMNS.iter().enumerate() {
            base_mapping[field_index] = row
                .iter_fields()
                .position(|f| f == *field)
                .unwrap_or(usize::MAX);
        }
        Ok(BillingApcRecovery3Mapping(base_mapping))
    }
    fn matches_file_key(key: &mmsdm_core::FileKey<'_>, version: i32) -> bool {
        version == key.version && Self::DATA_SET_NAME == key.data_set_name()
            && Self::TABLE_NAME == key.table_name()
    }
    fn primary_key(row: &Self::Row<'_>) -> BillingApcRecovery3PrimaryKey {
        BillingApcRecovery3PrimaryKey {
            apeventid: row.apeventid,
            billrunno: row.billrunno,
            claimid: row.claimid,
            contractyear: row.contractyear,
            participantid: row.participantid().to_string(),
            regionid: row.regionid().to_string(),
            weekno: row.weekno,
        }
    }
    fn partition_value(&self, row: &Self::Row<'_>) -> mmsdm_core::PartitionValue {
        (self.extract_row_partition)(row)
    }
    fn partition_name(&self, row: &Self::Row<'_>) -> alloc::string::String {
        alloc::format!("billing_apc_recovery_v3_{}", self.partition_value(row))
    }
    fn partition_key(&self) -> mmsdm_core::PartitionKey {
        self.row_partition_key
    }
    fn to_static<'a>(row: &Self::Row<'a>) -> Self::Row<'static> {
        BillingApcRecovery3Row {
            contractyear: row.contractyear.clone(),
            weekno: row.weekno.clone(),
            billrunno: row.billrunno.clone(),
            apeventid: row.apeventid.clone(),
            claimid: row.claimid.clone(),
            participantid: row.participantid.clone(),
            regionid: row.regionid.clone(),
            recovery_amount: row.recovery_amount.clone(),
            eligibility_start_interval: row.eligibility_start_interval.clone(),
            eligibility_end_interval: row.eligibility_end_interval.clone(),
            participant_demand: row.participant_demand.clone(),
            region_demand: row.region_demand.clone(),
            lastchanged: row.lastchanged.clone(),
            participant_ace_mwh: row.participant_ace_mwh.clone(),
            region_ace_mwh: row.region_ace_mwh.clone(),
            backing_data: row.backing_data.to_owned(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct BillingApcRecovery3PrimaryKey {
    pub apeventid: i64,
    pub billrunno: i64,
    pub claimid: i64,
    pub contractyear: i64,
    pub participantid: alloc::string::String,
    pub regionid: alloc::string::String,
    pub weekno: i64,
}
impl mmsdm_core::PrimaryKey for BillingApcRecovery3PrimaryKey {}
impl<'data> mmsdm_core::CompareWithRow for BillingApcRecovery3Row<'data> {
    type Row<'other> = BillingApcRecovery3Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.apeventid == row.apeventid && self.billrunno == row.billrunno
            && self.claimid == row.claimid && self.contractyear == row.contractyear
            && self.participantid() == row.participantid()
            && self.regionid() == row.regionid() && self.weekno == row.weekno
    }
}
impl<'data> mmsdm_core::CompareWithPrimaryKey for BillingApcRecovery3Row<'data> {
    type PrimaryKey = BillingApcRecovery3PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.apeventid == key.apeventid && self.billrunno == key.billrunno
            && self.claimid == key.claimid && self.contractyear == key.contractyear
            && self.participantid() == key.participantid
            && self.regionid() == key.regionid && self.weekno == key.weekno
    }
}
impl<'data> mmsdm_core::CompareWithRow for BillingApcRecovery3PrimaryKey {
    type Row<'other> = BillingApcRecovery3Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.apeventid == row.apeventid && self.billrunno == row.billrunno
            && self.claimid == row.claimid && self.contractyear == row.contractyear
            && self.participantid == row.participantid()
            && self.regionid == row.regionid() && self.weekno == row.weekno
    }
}
impl mmsdm_core::CompareWithPrimaryKey for BillingApcRecovery3PrimaryKey {
    type PrimaryKey = BillingApcRecovery3PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.apeventid == key.apeventid && self.billrunno == key.billrunno
            && self.claimid == key.claimid && self.contractyear == key.contractyear
            && self.participantid == key.participantid && self.regionid == key.regionid
            && self.weekno == key.weekno
    }
}
#[cfg(feature = "arrow")]
impl mmsdm_core::ArrowSchema for BillingApcRecovery3 {
    type Builder = BillingApcRecovery3Builder;
    fn schema() -> arrow::datatypes::Schema {
        arrow::datatypes::Schema::new(
            alloc::vec::Vec::from([
                arrow::datatypes::Field::new(
                    "contractyear",
                    arrow::datatypes::DataType::Int64,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "weekno",
                    arrow::datatypes::DataType::Int64,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "billrunno",
                    arrow::datatypes::DataType::Int64,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "apeventid",
                    arrow::datatypes::DataType::Int64,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "claimid",
                    arrow::datatypes::DataType::Int64,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "participantid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "regionid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "recovery_amount",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "eligibility_start_interval",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "eligibility_end_interval",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "participant_demand",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "region_demand",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lastchanged",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "participant_ace_mwh",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "region_ace_mwh",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
            ]),
        )
    }
    fn new_builder() -> Self::Builder {
        BillingApcRecovery3Builder {
            contractyear_array: arrow::array::builder::Int64Builder::new(),
            weekno_array: arrow::array::builder::Int64Builder::new(),
            billrunno_array: arrow::array::builder::Int64Builder::new(),
            apeventid_array: arrow::array::builder::Int64Builder::new(),
            claimid_array: arrow::array::builder::Int64Builder::new(),
            participantid_array: arrow::array::builder::StringBuilder::new(),
            regionid_array: arrow::array::builder::StringBuilder::new(),
            recovery_amount_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            eligibility_start_interval_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
            eligibility_end_interval_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
            participant_demand_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            region_demand_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
            participant_ace_mwh_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            region_ace_mwh_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
        }
    }
    fn append_builder(builder: &mut Self::Builder, row: Self::Row<'_>) {
        builder.contractyear_array.append_value(row.contractyear);
        builder.weekno_array.append_value(row.weekno);
        builder.billrunno_array.append_value(row.billrunno);
        builder.apeventid_array.append_value(row.apeventid);
        builder.claimid_array.append_value(row.claimid);
        builder.participantid_array.append_value(row.participantid());
        builder.regionid_array.append_value(row.regionid());
        builder
            .recovery_amount_array
            .append_option({
                row.recovery_amount
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .eligibility_start_interval_array
            .append_option(
                row
                    .eligibility_start_interval
                    .map(|val| val.and_utc().timestamp_millis()),
            );
        builder
            .eligibility_end_interval_array
            .append_option(
                row.eligibility_end_interval.map(|val| val.and_utc().timestamp_millis()),
            );
        builder
            .participant_demand_array
            .append_option({
                row.participant_demand
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .region_demand_array
            .append_option({
                row.region_demand
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .lastchanged_array
            .append_option(row.lastchanged.map(|val| val.and_utc().timestamp_millis()));
        builder
            .participant_ace_mwh_array
            .append_option({
                row.participant_ace_mwh
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .region_ace_mwh_array
            .append_option({
                row.region_ace_mwh
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
    }
    fn finalize_builder(
        builder: &mut Self::Builder,
    ) -> mmsdm_core::Result<arrow::array::RecordBatch> {
        arrow::array::RecordBatch::try_new(
                alloc::sync::Arc::new(<Self as mmsdm_core::ArrowSchema>::schema()),
                alloc::vec::Vec::from([
                    alloc::sync::Arc::new(builder.contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.apeventid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.claimid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.participantid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.regionid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.recovery_amount_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(
                        builder.eligibility_start_interval_array.finish(),
                    ) as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(
                        builder.eligibility_end_interval_array.finish(),
                    ) as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.participant_demand_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.region_demand_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lastchanged_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.participant_ace_mwh_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.region_ace_mwh_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                ]),
            )
            .map_err(Into::into)
    }
}
#[cfg(feature = "arrow")]
pub struct BillingApcRecovery3Builder {
    contractyear_array: arrow::array::builder::Int64Builder,
    weekno_array: arrow::array::builder::Int64Builder,
    billrunno_array: arrow::array::builder::Int64Builder,
    apeventid_array: arrow::array::builder::Int64Builder,
    claimid_array: arrow::array::builder::Int64Builder,
    participantid_array: arrow::array::builder::StringBuilder,
    regionid_array: arrow::array::builder::StringBuilder,
    recovery_amount_array: arrow::array::builder::Decimal128Builder,
    eligibility_start_interval_array: arrow::array::builder::TimestampMillisecondBuilder,
    eligibility_end_interval_array: arrow::array::builder::TimestampMillisecondBuilder,
    participant_demand_array: arrow::array::builder::Decimal128Builder,
    region_demand_array: arrow::array::builder::Decimal128Builder,
    lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder,
    participant_ace_mwh_array: arrow::array::builder::Decimal128Builder,
    region_ace_mwh_array: arrow::array::builder::Decimal128Builder,
}
pub struct BillingBillingCo2ePublication1 {
    extract_row_partition: alloc::boxed::Box<
        dyn Fn(
            &BillingBillingCo2ePublication1Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    >,
    row_partition_key: mmsdm_core::PartitionKey,
}
impl BillingBillingCo2ePublication1 {
    pub fn new(
        row_partition_key: mmsdm_core::PartitionKey,
        func: impl Fn(
            &<Self as mmsdm_core::GetTable>::Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    ) -> Self {
        Self {
            extract_row_partition: alloc::boxed::Box::new(func),
            row_partition_key,
        }
    }
}
pub struct BillingBillingCo2ePublication1Mapping([usize; 8]);
/// # Summary
///
/// ## BILLING_CO2E_PUBLICATION
///  _Carbon Dioxide Intensity Index publication table_
///
/// * Data Set Name: Billing
/// * File Name: Billing Co2e Publication
/// * Data Version: 1
///
///
///
///
///
/// # Primary Key Columns
///
/// * CONTRACTYEAR
/// * REGIONID
/// * SETTLEMENTDATE
/// * WEEKNO
#[derive(Debug, PartialEq, Eq)]
pub struct BillingBillingCo2ePublication1Row<'data> {
    /// Billing contract year
    pub contractyear: i64,
    /// Billing week no
    pub weekno: i64,
    /// Billing run no
    pub billrunno: i64,
    /// Settlement Date (Calendar)
    pub settlementdate: chrono::NaiveDateTime,
    /// Region identifier
    pub regionid: core::ops::Range<usize>,
    /// Total sent out energy for region (MWh)
    pub sentoutenergy: Option<rust_decimal::Decimal>,
    /// Total generator emissions for region (Co2-e)
    pub generatoremissions: Option<rust_decimal::Decimal>,
    /// Carbon Dioxide Intensity index for region (CO2-e/MWh)
    pub intensityindex: Option<rust_decimal::Decimal>,
    backing_data: mmsdm_core::CsvRow<'data>,
}
impl<'data> BillingBillingCo2ePublication1Row<'data> {
    pub fn regionid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.regionid.clone())
    }
}
impl mmsdm_core::GetTable for BillingBillingCo2ePublication1 {
    const VERSION: i32 = 1;
    const DATA_SET_NAME: &'static str = "BILLING";
    const TABLE_NAME: &'static str = "BILLING_CO2E_PUBLICATION";
    const DEFAULT_FIELD_MAPPING: Self::FieldMapping = BillingBillingCo2ePublication1Mapping([
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
    ]);
    const COLUMNS: &'static [&'static str] = &[
        "CONTRACTYEAR",
        "WEEKNO",
        "BILLRUNNO",
        "SETTLEMENTDATE",
        "REGIONID",
        "SENTOUTENERGY",
        "GENERATOREMISSIONS",
        "INTENSITYINDEX",
    ];
    type Row<'row> = BillingBillingCo2ePublication1Row<'row>;
    type FieldMapping = BillingBillingCo2ePublication1Mapping;
    type PrimaryKey = BillingBillingCo2ePublication1PrimaryKey;
    fn from_row<'data>(
        row: mmsdm_core::CsvRow<'data>,
        field_mapping: &Self::FieldMapping,
    ) -> mmsdm_core::Result<Self::Row<'data>> {
        Ok(BillingBillingCo2ePublication1Row {
            contractyear: row.get_parsed_at_idx("contractyear", field_mapping.0[0])?,
            weekno: row.get_parsed_at_idx("weekno", field_mapping.0[1])?,
            billrunno: row.get_parsed_at_idx("billrunno", field_mapping.0[2])?,
            settlementdate: row
                .get_custom_parsed_at_idx(
                    "settlementdate",
                    field_mapping.0[3],
                    mmsdm_core::mms_datetime::parse,
                )?,
            regionid: row.get_range("regionid", field_mapping.0[4])?,
            sentoutenergy: row
                .get_opt_custom_parsed_at_idx(
                    "sentoutenergy",
                    field_mapping.0[5],
                    mmsdm_core::mms_decimal::parse,
                )?,
            generatoremissions: row
                .get_opt_custom_parsed_at_idx(
                    "generatoremissions",
                    field_mapping.0[6],
                    mmsdm_core::mms_decimal::parse,
                )?,
            intensityindex: row
                .get_opt_custom_parsed_at_idx(
                    "intensityindex",
                    field_mapping.0[7],
                    mmsdm_core::mms_decimal::parse,
                )?,
            backing_data: row,
        })
    }
    fn field_mapping_from_row<'a>(
        mut row: mmsdm_core::CsvRow<'a>,
    ) -> mmsdm_core::Result<Self::FieldMapping> {
        if !row.is_heading() {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!("Expected an I row but got {row:?}"),
                ),
            );
        }
        let row_key = mmsdm_core::FileKey::from_row(row.borrow())?;
        if !Self::matches_file_key(&row_key, row_key.version) {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!(
                        "Expected a row matching {}.{}.v{} but got {row_key}",
                        Self::DATA_SET_NAME, Self::TABLE_NAME, Self::VERSION
                    ),
                ),
            );
        }
        let mut base_mapping = Self::DEFAULT_FIELD_MAPPING.0;
        for (field_index, field) in Self::COLUMNS.iter().enumerate() {
            base_mapping[field_index] = row
                .iter_fields()
                .position(|f| f == *field)
                .unwrap_or(usize::MAX);
        }
        Ok(BillingBillingCo2ePublication1Mapping(base_mapping))
    }
    fn matches_file_key(key: &mmsdm_core::FileKey<'_>, version: i32) -> bool {
        version == key.version && Self::DATA_SET_NAME == key.data_set_name()
            && Self::TABLE_NAME == key.table_name()
    }
    fn primary_key(row: &Self::Row<'_>) -> BillingBillingCo2ePublication1PrimaryKey {
        BillingBillingCo2ePublication1PrimaryKey {
            contractyear: row.contractyear,
            regionid: row.regionid().to_string(),
            settlementdate: row.settlementdate,
            weekno: row.weekno,
        }
    }
    fn partition_value(&self, row: &Self::Row<'_>) -> mmsdm_core::PartitionValue {
        (self.extract_row_partition)(row)
    }
    fn partition_name(&self, row: &Self::Row<'_>) -> alloc::string::String {
        alloc::format!(
            "billing_billing_co2e_publication_v1_{}", self.partition_value(row)
        )
    }
    fn partition_key(&self) -> mmsdm_core::PartitionKey {
        self.row_partition_key
    }
    fn to_static<'a>(row: &Self::Row<'a>) -> Self::Row<'static> {
        BillingBillingCo2ePublication1Row {
            contractyear: row.contractyear.clone(),
            weekno: row.weekno.clone(),
            billrunno: row.billrunno.clone(),
            settlementdate: row.settlementdate.clone(),
            regionid: row.regionid.clone(),
            sentoutenergy: row.sentoutenergy.clone(),
            generatoremissions: row.generatoremissions.clone(),
            intensityindex: row.intensityindex.clone(),
            backing_data: row.backing_data.to_owned(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct BillingBillingCo2ePublication1PrimaryKey {
    pub contractyear: i64,
    pub regionid: alloc::string::String,
    pub settlementdate: chrono::NaiveDateTime,
    pub weekno: i64,
}
impl mmsdm_core::PrimaryKey for BillingBillingCo2ePublication1PrimaryKey {}
impl<'data> mmsdm_core::CompareWithRow for BillingBillingCo2ePublication1Row<'data> {
    type Row<'other> = BillingBillingCo2ePublication1Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.contractyear == row.contractyear && self.regionid() == row.regionid()
            && self.settlementdate == row.settlementdate && self.weekno == row.weekno
    }
}
impl<'data> mmsdm_core::CompareWithPrimaryKey
for BillingBillingCo2ePublication1Row<'data> {
    type PrimaryKey = BillingBillingCo2ePublication1PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.contractyear == key.contractyear && self.regionid() == key.regionid
            && self.settlementdate == key.settlementdate && self.weekno == key.weekno
    }
}
impl<'data> mmsdm_core::CompareWithRow for BillingBillingCo2ePublication1PrimaryKey {
    type Row<'other> = BillingBillingCo2ePublication1Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.contractyear == row.contractyear && self.regionid == row.regionid()
            && self.settlementdate == row.settlementdate && self.weekno == row.weekno
    }
}
impl mmsdm_core::CompareWithPrimaryKey for BillingBillingCo2ePublication1PrimaryKey {
    type PrimaryKey = BillingBillingCo2ePublication1PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.contractyear == key.contractyear && self.regionid == key.regionid
            && self.settlementdate == key.settlementdate && self.weekno == key.weekno
    }
}
#[cfg(feature = "arrow")]
impl mmsdm_core::ArrowSchema for BillingBillingCo2ePublication1 {
    type Builder = BillingBillingCo2ePublication1Builder;
    fn schema() -> arrow::datatypes::Schema {
        arrow::datatypes::Schema::new(
            alloc::vec::Vec::from([
                arrow::datatypes::Field::new(
                    "contractyear",
                    arrow::datatypes::DataType::Int64,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "weekno",
                    arrow::datatypes::DataType::Int64,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "billrunno",
                    arrow::datatypes::DataType::Int64,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "settlementdate",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "regionid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "sentoutenergy",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "generatoremissions",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "intensityindex",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
            ]),
        )
    }
    fn new_builder() -> Self::Builder {
        BillingBillingCo2ePublication1Builder {
            contractyear_array: arrow::array::builder::Int64Builder::new(),
            weekno_array: arrow::array::builder::Int64Builder::new(),
            billrunno_array: arrow::array::builder::Int64Builder::new(),
            settlementdate_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
            regionid_array: arrow::array::builder::StringBuilder::new(),
            sentoutenergy_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            generatoremissions_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            intensityindex_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
        }
    }
    fn append_builder(builder: &mut Self::Builder, row: Self::Row<'_>) {
        builder.contractyear_array.append_value(row.contractyear);
        builder.weekno_array.append_value(row.weekno);
        builder.billrunno_array.append_value(row.billrunno);
        builder
            .settlementdate_array
            .append_value(row.settlementdate.and_utc().timestamp_millis());
        builder.regionid_array.append_value(row.regionid());
        builder
            .sentoutenergy_array
            .append_option({
                row.sentoutenergy
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .generatoremissions_array
            .append_option({
                row.generatoremissions
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .intensityindex_array
            .append_option({
                row.intensityindex
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
    }
    fn finalize_builder(
        builder: &mut Self::Builder,
    ) -> mmsdm_core::Result<arrow::array::RecordBatch> {
        arrow::array::RecordBatch::try_new(
                alloc::sync::Arc::new(<Self as mmsdm_core::ArrowSchema>::schema()),
                alloc::vec::Vec::from([
                    alloc::sync::Arc::new(builder.contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.settlementdate_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.regionid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.sentoutenergy_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.generatoremissions_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.intensityindex_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                ]),
            )
            .map_err(Into::into)
    }
}
#[cfg(feature = "arrow")]
pub struct BillingBillingCo2ePublication1Builder {
    contractyear_array: arrow::array::builder::Int64Builder,
    weekno_array: arrow::array::builder::Int64Builder,
    billrunno_array: arrow::array::builder::Int64Builder,
    settlementdate_array: arrow::array::builder::TimestampMillisecondBuilder,
    regionid_array: arrow::array::builder::StringBuilder,
    sentoutenergy_array: arrow::array::builder::Decimal128Builder,
    generatoremissions_array: arrow::array::builder::Decimal128Builder,
    intensityindex_array: arrow::array::builder::Decimal128Builder,
}
pub struct BillingBillingCo2ePublicationTrk1 {
    extract_row_partition: alloc::boxed::Box<
        dyn Fn(
            &BillingBillingCo2ePublicationTrk1Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    >,
    row_partition_key: mmsdm_core::PartitionKey,
}
impl BillingBillingCo2ePublicationTrk1 {
    pub fn new(
        row_partition_key: mmsdm_core::PartitionKey,
        func: impl Fn(
            &<Self as mmsdm_core::GetTable>::Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    ) -> Self {
        Self {
            extract_row_partition: alloc::boxed::Box::new(func),
            row_partition_key,
        }
    }
}
pub struct BillingBillingCo2ePublicationTrk1Mapping([usize; 4]);
/// # Summary
///
/// ## BILLING_CO2E_PUBLICATION_TRK
///  _Carbon Dioxide Intensity Index publication tracking table_
///
/// * Data Set Name: Billing
/// * File Name: Billing Co2e Publication Trk
/// * Data Version: 1
///
///
///
///
///
/// # Primary Key Columns
///
/// * CONTRACTYEAR
/// * WEEKNO
#[derive(Debug, PartialEq, Eq)]
pub struct BillingBillingCo2ePublicationTrk1Row<'data> {
    /// Billing contract year
    pub contractyear: i64,
    /// Billing week no
    pub weekno: i64,
    /// Billing run no
    pub billrunno: Option<i64>,
    /// Last changed date time
    pub lastchanged: Option<chrono::NaiveDateTime>,
    backing_data: core::marker::PhantomData<&'data ()>,
}
impl<'data> BillingBillingCo2ePublicationTrk1Row<'data> {}
impl mmsdm_core::GetTable for BillingBillingCo2ePublicationTrk1 {
    const VERSION: i32 = 1;
    const DATA_SET_NAME: &'static str = "BILLING";
    const TABLE_NAME: &'static str = "BILLING_CO2E_PUBLICATION_TRK";
    const DEFAULT_FIELD_MAPPING: Self::FieldMapping = BillingBillingCo2ePublicationTrk1Mapping([
        4,
        5,
        6,
        7,
    ]);
    const COLUMNS: &'static [&'static str] = &[
        "CONTRACTYEAR",
        "WEEKNO",
        "BILLRUNNO",
        "LASTCHANGED",
    ];
    type Row<'row> = BillingBillingCo2ePublicationTrk1Row<'row>;
    type FieldMapping = BillingBillingCo2ePublicationTrk1Mapping;
    type PrimaryKey = BillingBillingCo2ePublicationTrk1PrimaryKey;
    fn from_row<'data>(
        row: mmsdm_core::CsvRow<'data>,
        field_mapping: &Self::FieldMapping,
    ) -> mmsdm_core::Result<Self::Row<'data>> {
        Ok(BillingBillingCo2ePublicationTrk1Row {
            contractyear: row.get_parsed_at_idx("contractyear", field_mapping.0[0])?,
            weekno: row.get_parsed_at_idx("weekno", field_mapping.0[1])?,
            billrunno: row.get_opt_parsed_at_idx("billrunno", field_mapping.0[2])?,
            lastchanged: row
                .get_opt_custom_parsed_at_idx(
                    "lastchanged",
                    field_mapping.0[3],
                    mmsdm_core::mms_datetime::parse,
                )?,
            backing_data: core::marker::PhantomData,
        })
    }
    fn field_mapping_from_row<'a>(
        mut row: mmsdm_core::CsvRow<'a>,
    ) -> mmsdm_core::Result<Self::FieldMapping> {
        if !row.is_heading() {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!("Expected an I row but got {row:?}"),
                ),
            );
        }
        let row_key = mmsdm_core::FileKey::from_row(row.borrow())?;
        if !Self::matches_file_key(&row_key, row_key.version) {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!(
                        "Expected a row matching {}.{}.v{} but got {row_key}",
                        Self::DATA_SET_NAME, Self::TABLE_NAME, Self::VERSION
                    ),
                ),
            );
        }
        let mut base_mapping = Self::DEFAULT_FIELD_MAPPING.0;
        for (field_index, field) in Self::COLUMNS.iter().enumerate() {
            base_mapping[field_index] = row
                .iter_fields()
                .position(|f| f == *field)
                .unwrap_or(usize::MAX);
        }
        Ok(BillingBillingCo2ePublicationTrk1Mapping(base_mapping))
    }
    fn matches_file_key(key: &mmsdm_core::FileKey<'_>, version: i32) -> bool {
        version == key.version && Self::DATA_SET_NAME == key.data_set_name()
            && Self::TABLE_NAME == key.table_name()
    }
    fn primary_key(row: &Self::Row<'_>) -> BillingBillingCo2ePublicationTrk1PrimaryKey {
        BillingBillingCo2ePublicationTrk1PrimaryKey {
            contractyear: row.contractyear,
            weekno: row.weekno,
        }
    }
    fn partition_value(&self, row: &Self::Row<'_>) -> mmsdm_core::PartitionValue {
        (self.extract_row_partition)(row)
    }
    fn partition_name(&self, row: &Self::Row<'_>) -> alloc::string::String {
        alloc::format!(
            "billing_billing_co2e_publication_trk_v1_{}", self.partition_value(row)
        )
    }
    fn partition_key(&self) -> mmsdm_core::PartitionKey {
        self.row_partition_key
    }
    fn to_static<'a>(row: &Self::Row<'a>) -> Self::Row<'static> {
        BillingBillingCo2ePublicationTrk1Row {
            contractyear: row.contractyear.clone(),
            weekno: row.weekno.clone(),
            billrunno: row.billrunno.clone(),
            lastchanged: row.lastchanged.clone(),
            backing_data: core::marker::PhantomData,
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct BillingBillingCo2ePublicationTrk1PrimaryKey {
    pub contractyear: i64,
    pub weekno: i64,
}
impl mmsdm_core::PrimaryKey for BillingBillingCo2ePublicationTrk1PrimaryKey {}
impl<'data> mmsdm_core::CompareWithRow for BillingBillingCo2ePublicationTrk1Row<'data> {
    type Row<'other> = BillingBillingCo2ePublicationTrk1Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.contractyear == row.contractyear && self.weekno == row.weekno
    }
}
impl<'data> mmsdm_core::CompareWithPrimaryKey
for BillingBillingCo2ePublicationTrk1Row<'data> {
    type PrimaryKey = BillingBillingCo2ePublicationTrk1PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.contractyear == key.contractyear && self.weekno == key.weekno
    }
}
impl<'data> mmsdm_core::CompareWithRow for BillingBillingCo2ePublicationTrk1PrimaryKey {
    type Row<'other> = BillingBillingCo2ePublicationTrk1Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.contractyear == row.contractyear && self.weekno == row.weekno
    }
}
impl mmsdm_core::CompareWithPrimaryKey for BillingBillingCo2ePublicationTrk1PrimaryKey {
    type PrimaryKey = BillingBillingCo2ePublicationTrk1PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.contractyear == key.contractyear && self.weekno == key.weekno
    }
}
#[cfg(feature = "arrow")]
impl mmsdm_core::ArrowSchema for BillingBillingCo2ePublicationTrk1 {
    type Builder = BillingBillingCo2ePublicationTrk1Builder;
    fn schema() -> arrow::datatypes::Schema {
        arrow::datatypes::Schema::new(
            alloc::vec::Vec::from([
                arrow::datatypes::Field::new(
                    "contractyear",
                    arrow::datatypes::DataType::Int64,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "weekno",
                    arrow::datatypes::DataType::Int64,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "billrunno",
                    arrow::datatypes::DataType::Int64,
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lastchanged",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    true,
                ),
            ]),
        )
    }
    fn new_builder() -> Self::Builder {
        BillingBillingCo2ePublicationTrk1Builder {
            contractyear_array: arrow::array::builder::Int64Builder::new(),
            weekno_array: arrow::array::builder::Int64Builder::new(),
            billrunno_array: arrow::array::builder::Int64Builder::new(),
            lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
        }
    }
    fn append_builder(builder: &mut Self::Builder, row: Self::Row<'_>) {
        builder.contractyear_array.append_value(row.contractyear);
        builder.weekno_array.append_value(row.weekno);
        builder.billrunno_array.append_option(row.billrunno);
        builder
            .lastchanged_array
            .append_option(row.lastchanged.map(|val| val.and_utc().timestamp_millis()));
    }
    fn finalize_builder(
        builder: &mut Self::Builder,
    ) -> mmsdm_core::Result<arrow::array::RecordBatch> {
        arrow::array::RecordBatch::try_new(
                alloc::sync::Arc::new(<Self as mmsdm_core::ArrowSchema>::schema()),
                alloc::vec::Vec::from([
                    alloc::sync::Arc::new(builder.contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lastchanged_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                ]),
            )
            .map_err(Into::into)
    }
}
#[cfg(feature = "arrow")]
pub struct BillingBillingCo2ePublicationTrk1Builder {
    contractyear_array: arrow::array::builder::Int64Builder,
    weekno_array: arrow::array::builder::Int64Builder,
    billrunno_array: arrow::array::builder::Int64Builder,
    lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder,
}
pub struct BillingDailyEnergySummary2 {
    extract_row_partition: alloc::boxed::Box<
        dyn Fn(
            &BillingDailyEnergySummary2Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    >,
    row_partition_key: mmsdm_core::PartitionKey,
}
impl BillingDailyEnergySummary2 {
    pub fn new(
        row_partition_key: mmsdm_core::PartitionKey,
        func: impl Fn(
            &<Self as mmsdm_core::GetTable>::Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    ) -> Self {
        Self {
            extract_row_partition: alloc::boxed::Box::new(func),
            row_partition_key,
        }
    }
}
pub struct BillingDailyEnergySummary2Mapping([usize; 17]);
/// # Summary
///
/// ## BILLING_DAILY_ENERGY_SUMMARY
///  _Billing result table containing daily summary data for customer and generator energy amounts_
///
/// * Data Set Name: Billing
/// * File Name: Daily Energy Summary
/// * Data Version: 2
///
/// # Description
///  BILLING_DAILY_ENERGY_SUMMARY data is confidential  to the relevant participant. Source Populated by the posting of a billing run. Volume Approximately 20 records per billrunno.
///
///
///
/// # Primary Key Columns
///
/// * BILLRUNNO
/// * CONTRACTYEAR
/// * PARTICIPANTID
/// * REGIONID
/// * SETTLEMENTDATE
/// * WEEKNO
#[derive(Debug, PartialEq, Eq)]
pub struct BillingDailyEnergySummary2Row<'data> {
    /// Billing Contract Year
    pub contractyear: rust_decimal::Decimal,
    /// Billing Week number
    pub weekno: rust_decimal::Decimal,
    /// Billing Run number
    pub billrunno: rust_decimal::Decimal,
    /// settlement date
    pub settlementdate: chrono::NaiveDateTime,
    /// participant identifier
    pub participantid: core::ops::Range<usize>,
    /// Unique Region Identifier
    pub regionid: core::ops::Range<usize>,
    /// Customer energy amount purchased on this settlement day by the participant in the region. NULL for Billing Week post the IESS rule effective date.
    pub customer_energy_purchased: Option<rust_decimal::Decimal>,
    /// Generator energy amount sold on this settlement day by the participant in the region. NULL for Billing Week post the IESS rule effective date.
    pub generator_energy_sold: Option<rust_decimal::Decimal>,
    /// Generator energy amount purchased on this settlement day by the participant in the region. NULL for Billing Week post the IESS rule effective date.
    pub generator_energy_purchased: Option<rust_decimal::Decimal>,
    /// The Sum of ACE MWh value for the Participant and region for the Settlement Date. NULL for Billing Week prior to the IESS rule effective date
    pub ace_mwh: Option<rust_decimal::Decimal>,
    /// The Sum of ASOE MWh value for the Participant and region for the Settlement Date. NULL for Billing Week prior to the IESS rule effective date
    pub asoe_mwh: Option<rust_decimal::Decimal>,
    /// The Sum of ACE Amount for the Participant and region for the Settlement Date. NULL for Billing Week prior to the IESS rule effective date
    pub ace_amount: Option<rust_decimal::Decimal>,
    /// The Sum of ASOE Amount for the Participant and region for the Settlement Date. NULL for Billing Week prior to the IESS rule effective date
    pub asoe_amount: Option<rust_decimal::Decimal>,
    /// The Sum of CE MWh value for the Participant and region for the Settlement Date. NULL for Billing Week prior to the IESS rule effective date
    pub ce_mwh: Option<rust_decimal::Decimal>,
    /// The Sum of UFEA MWh value for the Participant and region for the Settlement Date. NULL for Billing Week prior to the IESS rule effective date
    pub ufea_mwh: Option<rust_decimal::Decimal>,
    /// The Sum of Total MWh value for the Participant and region for the Settlement Date. NULL for Billing Week prior to the IESS rule effective date
    pub total_mwh: Option<rust_decimal::Decimal>,
    /// The Sum of Total Amount for the Participant and region for the Settlement Date. NULL for Billing Week prior to the IESS rule effective date
    pub total_amount: Option<rust_decimal::Decimal>,
    backing_data: mmsdm_core::CsvRow<'data>,
}
impl<'data> BillingDailyEnergySummary2Row<'data> {
    pub fn participantid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.participantid.clone())
    }
    pub fn regionid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.regionid.clone())
    }
}
impl mmsdm_core::GetTable for BillingDailyEnergySummary2 {
    const VERSION: i32 = 2;
    const DATA_SET_NAME: &'static str = "BILLING";
    const TABLE_NAME: &'static str = "DAILY_ENERGY_SUMMARY";
    const DEFAULT_FIELD_MAPPING: Self::FieldMapping = BillingDailyEnergySummary2Mapping([
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
    ]);
    const COLUMNS: &'static [&'static str] = &[
        "CONTRACTYEAR",
        "WEEKNO",
        "BILLRUNNO",
        "SETTLEMENTDATE",
        "PARTICIPANTID",
        "REGIONID",
        "CUSTOMER_ENERGY_PURCHASED",
        "GENERATOR_ENERGY_SOLD",
        "GENERATOR_ENERGY_PURCHASED",
        "ACE_MWH",
        "ASOE_MWH",
        "ACE_AMOUNT",
        "ASOE_AMOUNT",
        "CE_MWH",
        "UFEA_MWH",
        "TOTAL_MWH",
        "TOTAL_AMOUNT",
    ];
    type Row<'row> = BillingDailyEnergySummary2Row<'row>;
    type FieldMapping = BillingDailyEnergySummary2Mapping;
    type PrimaryKey = BillingDailyEnergySummary2PrimaryKey;
    fn from_row<'data>(
        row: mmsdm_core::CsvRow<'data>,
        field_mapping: &Self::FieldMapping,
    ) -> mmsdm_core::Result<Self::Row<'data>> {
        Ok(BillingDailyEnergySummary2Row {
            contractyear: row
                .get_custom_parsed_at_idx(
                    "contractyear",
                    field_mapping.0[0],
                    mmsdm_core::mms_decimal::parse,
                )?,
            weekno: row
                .get_custom_parsed_at_idx(
                    "weekno",
                    field_mapping.0[1],
                    mmsdm_core::mms_decimal::parse,
                )?,
            billrunno: row
                .get_custom_parsed_at_idx(
                    "billrunno",
                    field_mapping.0[2],
                    mmsdm_core::mms_decimal::parse,
                )?,
            settlementdate: row
                .get_custom_parsed_at_idx(
                    "settlementdate",
                    field_mapping.0[3],
                    mmsdm_core::mms_datetime::parse,
                )?,
            participantid: row.get_range("participantid", field_mapping.0[4])?,
            regionid: row.get_range("regionid", field_mapping.0[5])?,
            customer_energy_purchased: row
                .get_opt_custom_parsed_at_idx(
                    "customer_energy_purchased",
                    field_mapping.0[6],
                    mmsdm_core::mms_decimal::parse,
                )?,
            generator_energy_sold: row
                .get_opt_custom_parsed_at_idx(
                    "generator_energy_sold",
                    field_mapping.0[7],
                    mmsdm_core::mms_decimal::parse,
                )?,
            generator_energy_purchased: row
                .get_opt_custom_parsed_at_idx(
                    "generator_energy_purchased",
                    field_mapping.0[8],
                    mmsdm_core::mms_decimal::parse,
                )?,
            ace_mwh: row
                .get_opt_custom_parsed_at_idx(
                    "ace_mwh",
                    field_mapping.0[9],
                    mmsdm_core::mms_decimal::parse,
                )?,
            asoe_mwh: row
                .get_opt_custom_parsed_at_idx(
                    "asoe_mwh",
                    field_mapping.0[10],
                    mmsdm_core::mms_decimal::parse,
                )?,
            ace_amount: row
                .get_opt_custom_parsed_at_idx(
                    "ace_amount",
                    field_mapping.0[11],
                    mmsdm_core::mms_decimal::parse,
                )?,
            asoe_amount: row
                .get_opt_custom_parsed_at_idx(
                    "asoe_amount",
                    field_mapping.0[12],
                    mmsdm_core::mms_decimal::parse,
                )?,
            ce_mwh: row
                .get_opt_custom_parsed_at_idx(
                    "ce_mwh",
                    field_mapping.0[13],
                    mmsdm_core::mms_decimal::parse,
                )?,
            ufea_mwh: row
                .get_opt_custom_parsed_at_idx(
                    "ufea_mwh",
                    field_mapping.0[14],
                    mmsdm_core::mms_decimal::parse,
                )?,
            total_mwh: row
                .get_opt_custom_parsed_at_idx(
                    "total_mwh",
                    field_mapping.0[15],
                    mmsdm_core::mms_decimal::parse,
                )?,
            total_amount: row
                .get_opt_custom_parsed_at_idx(
                    "total_amount",
                    field_mapping.0[16],
                    mmsdm_core::mms_decimal::parse,
                )?,
            backing_data: row,
        })
    }
    fn field_mapping_from_row<'a>(
        mut row: mmsdm_core::CsvRow<'a>,
    ) -> mmsdm_core::Result<Self::FieldMapping> {
        if !row.is_heading() {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!("Expected an I row but got {row:?}"),
                ),
            );
        }
        let row_key = mmsdm_core::FileKey::from_row(row.borrow())?;
        if !Self::matches_file_key(&row_key, row_key.version) {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!(
                        "Expected a row matching {}.{}.v{} but got {row_key}",
                        Self::DATA_SET_NAME, Self::TABLE_NAME, Self::VERSION
                    ),
                ),
            );
        }
        let mut base_mapping = Self::DEFAULT_FIELD_MAPPING.0;
        for (field_index, field) in Self::COLUMNS.iter().enumerate() {
            base_mapping[field_index] = row
                .iter_fields()
                .position(|f| f == *field)
                .unwrap_or(usize::MAX);
        }
        Ok(BillingDailyEnergySummary2Mapping(base_mapping))
    }
    fn matches_file_key(key: &mmsdm_core::FileKey<'_>, version: i32) -> bool {
        version == key.version && Self::DATA_SET_NAME == key.data_set_name()
            && Self::TABLE_NAME == key.table_name()
    }
    fn primary_key(row: &Self::Row<'_>) -> BillingDailyEnergySummary2PrimaryKey {
        BillingDailyEnergySummary2PrimaryKey {
            billrunno: row.billrunno,
            contractyear: row.contractyear,
            participantid: row.participantid().to_string(),
            regionid: row.regionid().to_string(),
            settlementdate: row.settlementdate,
            weekno: row.weekno,
        }
    }
    fn partition_value(&self, row: &Self::Row<'_>) -> mmsdm_core::PartitionValue {
        (self.extract_row_partition)(row)
    }
    fn partition_name(&self, row: &Self::Row<'_>) -> alloc::string::String {
        alloc::format!("billing_daily_energy_summary_v2_{}", self.partition_value(row))
    }
    fn partition_key(&self) -> mmsdm_core::PartitionKey {
        self.row_partition_key
    }
    fn to_static<'a>(row: &Self::Row<'a>) -> Self::Row<'static> {
        BillingDailyEnergySummary2Row {
            contractyear: row.contractyear.clone(),
            weekno: row.weekno.clone(),
            billrunno: row.billrunno.clone(),
            settlementdate: row.settlementdate.clone(),
            participantid: row.participantid.clone(),
            regionid: row.regionid.clone(),
            customer_energy_purchased: row.customer_energy_purchased.clone(),
            generator_energy_sold: row.generator_energy_sold.clone(),
            generator_energy_purchased: row.generator_energy_purchased.clone(),
            ace_mwh: row.ace_mwh.clone(),
            asoe_mwh: row.asoe_mwh.clone(),
            ace_amount: row.ace_amount.clone(),
            asoe_amount: row.asoe_amount.clone(),
            ce_mwh: row.ce_mwh.clone(),
            ufea_mwh: row.ufea_mwh.clone(),
            total_mwh: row.total_mwh.clone(),
            total_amount: row.total_amount.clone(),
            backing_data: row.backing_data.to_owned(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct BillingDailyEnergySummary2PrimaryKey {
    pub billrunno: rust_decimal::Decimal,
    pub contractyear: rust_decimal::Decimal,
    pub participantid: alloc::string::String,
    pub regionid: alloc::string::String,
    pub settlementdate: chrono::NaiveDateTime,
    pub weekno: rust_decimal::Decimal,
}
impl mmsdm_core::PrimaryKey for BillingDailyEnergySummary2PrimaryKey {}
impl<'data> mmsdm_core::CompareWithRow for BillingDailyEnergySummary2Row<'data> {
    type Row<'other> = BillingDailyEnergySummary2Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.participantid() == row.participantid()
            && self.regionid() == row.regionid()
            && self.settlementdate == row.settlementdate && self.weekno == row.weekno
    }
}
impl<'data> mmsdm_core::CompareWithPrimaryKey for BillingDailyEnergySummary2Row<'data> {
    type PrimaryKey = BillingDailyEnergySummary2PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.participantid() == key.participantid
            && self.regionid() == key.regionid
            && self.settlementdate == key.settlementdate && self.weekno == key.weekno
    }
}
impl<'data> mmsdm_core::CompareWithRow for BillingDailyEnergySummary2PrimaryKey {
    type Row<'other> = BillingDailyEnergySummary2Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.participantid == row.participantid()
            && self.regionid == row.regionid()
            && self.settlementdate == row.settlementdate && self.weekno == row.weekno
    }
}
impl mmsdm_core::CompareWithPrimaryKey for BillingDailyEnergySummary2PrimaryKey {
    type PrimaryKey = BillingDailyEnergySummary2PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.participantid == key.participantid && self.regionid == key.regionid
            && self.settlementdate == key.settlementdate && self.weekno == key.weekno
    }
}
#[cfg(feature = "arrow")]
impl mmsdm_core::ArrowSchema for BillingDailyEnergySummary2 {
    type Builder = BillingDailyEnergySummary2Builder;
    fn schema() -> arrow::datatypes::Schema {
        arrow::datatypes::Schema::new(
            alloc::vec::Vec::from([
                arrow::datatypes::Field::new(
                    "contractyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "weekno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "billrunno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "settlementdate",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "participantid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "regionid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "customer_energy_purchased",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "generator_energy_sold",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "generator_energy_purchased",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "ace_mwh",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "asoe_mwh",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "ace_amount",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "asoe_amount",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "ce_mwh",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "ufea_mwh",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "total_mwh",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "total_amount",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
            ]),
        )
    }
    fn new_builder() -> Self::Builder {
        BillingDailyEnergySummary2Builder {
            contractyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            weekno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            billrunno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            settlementdate_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
            participantid_array: arrow::array::builder::StringBuilder::new(),
            regionid_array: arrow::array::builder::StringBuilder::new(),
            customer_energy_purchased_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            generator_energy_sold_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            generator_energy_purchased_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            ace_mwh_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            asoe_mwh_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            ace_amount_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            asoe_amount_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            ce_mwh_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            ufea_mwh_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            total_mwh_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            total_amount_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
        }
    }
    fn append_builder(builder: &mut Self::Builder, row: Self::Row<'_>) {
        builder
            .contractyear_array
            .append_value({
                let mut val = row.contractyear;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .weekno_array
            .append_value({
                let mut val = row.weekno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .billrunno_array
            .append_value({
                let mut val = row.billrunno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .settlementdate_array
            .append_value(row.settlementdate.and_utc().timestamp_millis());
        builder.participantid_array.append_value(row.participantid());
        builder.regionid_array.append_value(row.regionid());
        builder
            .customer_energy_purchased_array
            .append_option({
                row.customer_energy_purchased
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .generator_energy_sold_array
            .append_option({
                row.generator_energy_sold
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .generator_energy_purchased_array
            .append_option({
                row.generator_energy_purchased
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .ace_mwh_array
            .append_option({
                row.ace_mwh
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .asoe_mwh_array
            .append_option({
                row.asoe_mwh
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .ace_amount_array
            .append_option({
                row.ace_amount
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .asoe_amount_array
            .append_option({
                row.asoe_amount
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .ce_mwh_array
            .append_option({
                row.ce_mwh
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .ufea_mwh_array
            .append_option({
                row.ufea_mwh
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .total_mwh_array
            .append_option({
                row.total_mwh
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .total_amount_array
            .append_option({
                row.total_amount
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
    }
    fn finalize_builder(
        builder: &mut Self::Builder,
    ) -> mmsdm_core::Result<arrow::array::RecordBatch> {
        arrow::array::RecordBatch::try_new(
                alloc::sync::Arc::new(<Self as mmsdm_core::ArrowSchema>::schema()),
                alloc::vec::Vec::from([
                    alloc::sync::Arc::new(builder.contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.settlementdate_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.participantid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.regionid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(
                        builder.customer_energy_purchased_array.finish(),
                    ) as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.generator_energy_sold_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(
                        builder.generator_energy_purchased_array.finish(),
                    ) as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.ace_mwh_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.asoe_mwh_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.ace_amount_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.asoe_amount_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.ce_mwh_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.ufea_mwh_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.total_mwh_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.total_amount_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                ]),
            )
            .map_err(Into::into)
    }
}
#[cfg(feature = "arrow")]
pub struct BillingDailyEnergySummary2Builder {
    contractyear_array: arrow::array::builder::Decimal128Builder,
    weekno_array: arrow::array::builder::Decimal128Builder,
    billrunno_array: arrow::array::builder::Decimal128Builder,
    settlementdate_array: arrow::array::builder::TimestampMillisecondBuilder,
    participantid_array: arrow::array::builder::StringBuilder,
    regionid_array: arrow::array::builder::StringBuilder,
    customer_energy_purchased_array: arrow::array::builder::Decimal128Builder,
    generator_energy_sold_array: arrow::array::builder::Decimal128Builder,
    generator_energy_purchased_array: arrow::array::builder::Decimal128Builder,
    ace_mwh_array: arrow::array::builder::Decimal128Builder,
    asoe_mwh_array: arrow::array::builder::Decimal128Builder,
    ace_amount_array: arrow::array::builder::Decimal128Builder,
    asoe_amount_array: arrow::array::builder::Decimal128Builder,
    ce_mwh_array: arrow::array::builder::Decimal128Builder,
    ufea_mwh_array: arrow::array::builder::Decimal128Builder,
    total_mwh_array: arrow::array::builder::Decimal128Builder,
    total_amount_array: arrow::array::builder::Decimal128Builder,
}
pub struct BillingBillingDirectionReconOther2 {
    extract_row_partition: alloc::boxed::Box<
        dyn Fn(
            &BillingBillingDirectionReconOther2Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    >,
    row_partition_key: mmsdm_core::PartitionKey,
}
impl BillingBillingDirectionReconOther2 {
    pub fn new(
        row_partition_key: mmsdm_core::PartitionKey,
        func: impl Fn(
            &<Self as mmsdm_core::GetTable>::Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    ) -> Self {
        Self {
            extract_row_partition: alloc::boxed::Box::new(func),
            row_partition_key,
        }
    }
}
pub struct BillingBillingDirectionReconOther2Mapping([usize; 21]);
/// # Summary
///
/// ## BILLING_DIRECTION_RECON_OTHER
///  _Billing reconciliation result table for both provisional and final directions_
///
/// * Data Set Name: Billing
/// * File Name: Billing Direction Recon Other
/// * Data Version: 2
///
///
///
///
///
/// # Primary Key Columns
///
/// * BILLRUNNO
/// * CONTRACTYEAR
/// * DIRECTION_ID
/// * REGIONID
/// * WEEKNO
#[derive(Debug, PartialEq, Eq)]
pub struct BillingBillingDirectionReconOther2Row<'data> {
    /// Billing contract year
    pub contractyear: i64,
    /// Billing week no
    pub weekno: i64,
    /// Billing run no
    pub billrunno: i64,
    /// Direction identifier
    pub direction_id: core::ops::Range<usize>,
    /// Region Identifier
    pub regionid: core::ops::Range<usize>,
    /// Direction description
    pub direction_desc: core::ops::Range<usize>,
    /// The service for which the direction occurred (ENERGY, ANCILLARY, NON_ENERGY_NON_AS, etc)
    pub direction_type_id: core::ops::Range<usize>,
    /// Settlement day on which the direction starts
    pub direction_start_date: Option<chrono::NaiveDateTime>,
    /// Settlement day on which the direction ends.  The same value for all regions
    pub direction_end_date: Option<chrono::NaiveDateTime>,
    /// Dispatch interval in which the direction starts.  The same value for all regions
    pub direction_start_interval: Option<chrono::NaiveDateTime>,
    /// Dispatch interval in which the direction ends.  The same value for all regions
    pub direction_end_interval: Option<chrono::NaiveDateTime>,
    /// The final compensation amount for the direction.  The same value for all regions
    pub compensation_amount: Option<rust_decimal::Decimal>,
    /// The interest amount calculated on the final compensation amount for the direction.  The same value for all regions
    pub interest_amount: Option<rust_decimal::Decimal>,
    /// The independent expert fee amount for the direction.  The same value for all regions
    pub independent_expert_fee: Option<rust_decimal::Decimal>,
    /// The total recovery amount for the direction.  The same value for all regions
    pub cra: Option<rust_decimal::Decimal>,
    /// The total customer energy for this region, over the duration of the direction. NULL for Billing Week post the IESS rule effective date.
    pub regional_customer_energy: Option<rust_decimal::Decimal>,
    /// The total generator energy for this region, over the duration of the direction. NULL for Billing Week post the IESS rule effective date.
    pub regional_generator_energy: Option<rust_decimal::Decimal>,
    /// The regional benefit factor allocated to this region for the direction
    pub regional_benefit_factor: Option<rust_decimal::Decimal>,
    /// The Sum of ACE MWh value for the Region over the duration of the direction. NULL for Billing Week prior to the IESS rule effective date
    pub region_ace_mwh: Option<rust_decimal::Decimal>,
    /// The Sum of ASOE MWh value for the Region over the duration of the direction. NULL for Billing Week prior to the IESS rule effective date
    pub region_asoe_mwh: Option<rust_decimal::Decimal>,
    /// The Direction Service ID associated with the Direction Type ID. Eg For FCAS Direction Type, Direction Service could be any contingency service.
    pub direction_service_id: core::ops::Range<usize>,
    backing_data: mmsdm_core::CsvRow<'data>,
}
impl<'data> BillingBillingDirectionReconOther2Row<'data> {
    pub fn direction_id(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.direction_id.clone())
    }
    pub fn regionid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.regionid.clone())
    }
    pub fn direction_desc(&self) -> Option<&str> {
        if self.direction_desc.is_empty() {
            None
        } else {
            Some(
                core::ops::Index::index(
                    self.backing_data.as_slice(),
                    self.direction_desc.clone(),
                ),
            )
        }
    }
    pub fn direction_type_id(&self) -> Option<&str> {
        if self.direction_type_id.is_empty() {
            None
        } else {
            Some(
                core::ops::Index::index(
                    self.backing_data.as_slice(),
                    self.direction_type_id.clone(),
                ),
            )
        }
    }
    pub fn direction_service_id(&self) -> Option<&str> {
        if self.direction_service_id.is_empty() {
            None
        } else {
            Some(
                core::ops::Index::index(
                    self.backing_data.as_slice(),
                    self.direction_service_id.clone(),
                ),
            )
        }
    }
}
impl mmsdm_core::GetTable for BillingBillingDirectionReconOther2 {
    const VERSION: i32 = 2;
    const DATA_SET_NAME: &'static str = "BILLING";
    const TABLE_NAME: &'static str = "BILLING_DIRECTION_RECON_OTHER";
    const DEFAULT_FIELD_MAPPING: Self::FieldMapping = BillingBillingDirectionReconOther2Mapping([
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
    ]);
    const COLUMNS: &'static [&'static str] = &[
        "CONTRACTYEAR",
        "WEEKNO",
        "BILLRUNNO",
        "DIRECTION_ID",
        "REGIONID",
        "DIRECTION_DESC",
        "DIRECTION_TYPE_ID",
        "DIRECTION_START_DATE",
        "DIRECTION_END_DATE",
        "DIRECTION_START_INTERVAL",
        "DIRECTION_END_INTERVAL",
        "COMPENSATION_AMOUNT",
        "INTEREST_AMOUNT",
        "INDEPENDENT_EXPERT_FEE",
        "CRA",
        "REGIONAL_CUSTOMER_ENERGY",
        "REGIONAL_GENERATOR_ENERGY",
        "REGIONAL_BENEFIT_FACTOR",
        "REGION_ACE_MWH",
        "REGION_ASOE_MWH",
        "DIRECTION_SERVICE_ID",
    ];
    type Row<'row> = BillingBillingDirectionReconOther2Row<'row>;
    type FieldMapping = BillingBillingDirectionReconOther2Mapping;
    type PrimaryKey = BillingBillingDirectionReconOther2PrimaryKey;
    fn from_row<'data>(
        row: mmsdm_core::CsvRow<'data>,
        field_mapping: &Self::FieldMapping,
    ) -> mmsdm_core::Result<Self::Row<'data>> {
        Ok(BillingBillingDirectionReconOther2Row {
            contractyear: row.get_parsed_at_idx("contractyear", field_mapping.0[0])?,
            weekno: row.get_parsed_at_idx("weekno", field_mapping.0[1])?,
            billrunno: row.get_parsed_at_idx("billrunno", field_mapping.0[2])?,
            direction_id: row.get_range("direction_id", field_mapping.0[3])?,
            regionid: row.get_range("regionid", field_mapping.0[4])?,
            direction_desc: row.get_opt_range("direction_desc", field_mapping.0[5])?,
            direction_type_id: row
                .get_opt_range("direction_type_id", field_mapping.0[6])?,
            direction_start_date: row
                .get_opt_custom_parsed_at_idx(
                    "direction_start_date",
                    field_mapping.0[7],
                    mmsdm_core::mms_datetime::parse,
                )?,
            direction_end_date: row
                .get_opt_custom_parsed_at_idx(
                    "direction_end_date",
                    field_mapping.0[8],
                    mmsdm_core::mms_datetime::parse,
                )?,
            direction_start_interval: row
                .get_opt_custom_parsed_at_idx(
                    "direction_start_interval",
                    field_mapping.0[9],
                    mmsdm_core::mms_datetime::parse,
                )?,
            direction_end_interval: row
                .get_opt_custom_parsed_at_idx(
                    "direction_end_interval",
                    field_mapping.0[10],
                    mmsdm_core::mms_datetime::parse,
                )?,
            compensation_amount: row
                .get_opt_custom_parsed_at_idx(
                    "compensation_amount",
                    field_mapping.0[11],
                    mmsdm_core::mms_decimal::parse,
                )?,
            interest_amount: row
                .get_opt_custom_parsed_at_idx(
                    "interest_amount",
                    field_mapping.0[12],
                    mmsdm_core::mms_decimal::parse,
                )?,
            independent_expert_fee: row
                .get_opt_custom_parsed_at_idx(
                    "independent_expert_fee",
                    field_mapping.0[13],
                    mmsdm_core::mms_decimal::parse,
                )?,
            cra: row
                .get_opt_custom_parsed_at_idx(
                    "cra",
                    field_mapping.0[14],
                    mmsdm_core::mms_decimal::parse,
                )?,
            regional_customer_energy: row
                .get_opt_custom_parsed_at_idx(
                    "regional_customer_energy",
                    field_mapping.0[15],
                    mmsdm_core::mms_decimal::parse,
                )?,
            regional_generator_energy: row
                .get_opt_custom_parsed_at_idx(
                    "regional_generator_energy",
                    field_mapping.0[16],
                    mmsdm_core::mms_decimal::parse,
                )?,
            regional_benefit_factor: row
                .get_opt_custom_parsed_at_idx(
                    "regional_benefit_factor",
                    field_mapping.0[17],
                    mmsdm_core::mms_decimal::parse,
                )?,
            region_ace_mwh: row
                .get_opt_custom_parsed_at_idx(
                    "region_ace_mwh",
                    field_mapping.0[18],
                    mmsdm_core::mms_decimal::parse,
                )?,
            region_asoe_mwh: row
                .get_opt_custom_parsed_at_idx(
                    "region_asoe_mwh",
                    field_mapping.0[19],
                    mmsdm_core::mms_decimal::parse,
                )?,
            direction_service_id: row
                .get_opt_range("direction_service_id", field_mapping.0[20])?,
            backing_data: row,
        })
    }
    fn field_mapping_from_row<'a>(
        mut row: mmsdm_core::CsvRow<'a>,
    ) -> mmsdm_core::Result<Self::FieldMapping> {
        if !row.is_heading() {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!("Expected an I row but got {row:?}"),
                ),
            );
        }
        let row_key = mmsdm_core::FileKey::from_row(row.borrow())?;
        if !Self::matches_file_key(&row_key, row_key.version) {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!(
                        "Expected a row matching {}.{}.v{} but got {row_key}",
                        Self::DATA_SET_NAME, Self::TABLE_NAME, Self::VERSION
                    ),
                ),
            );
        }
        let mut base_mapping = Self::DEFAULT_FIELD_MAPPING.0;
        for (field_index, field) in Self::COLUMNS.iter().enumerate() {
            base_mapping[field_index] = row
                .iter_fields()
                .position(|f| f == *field)
                .unwrap_or(usize::MAX);
        }
        Ok(BillingBillingDirectionReconOther2Mapping(base_mapping))
    }
    fn matches_file_key(key: &mmsdm_core::FileKey<'_>, version: i32) -> bool {
        version == key.version && Self::DATA_SET_NAME == key.data_set_name()
            && Self::TABLE_NAME == key.table_name()
    }
    fn primary_key(row: &Self::Row<'_>) -> BillingBillingDirectionReconOther2PrimaryKey {
        BillingBillingDirectionReconOther2PrimaryKey {
            billrunno: row.billrunno,
            contractyear: row.contractyear,
            direction_id: row.direction_id().to_string(),
            regionid: row.regionid().to_string(),
            weekno: row.weekno,
        }
    }
    fn partition_value(&self, row: &Self::Row<'_>) -> mmsdm_core::PartitionValue {
        (self.extract_row_partition)(row)
    }
    fn partition_name(&self, row: &Self::Row<'_>) -> alloc::string::String {
        alloc::format!(
            "billing_billing_direction_recon_other_v2_{}", self.partition_value(row)
        )
    }
    fn partition_key(&self) -> mmsdm_core::PartitionKey {
        self.row_partition_key
    }
    fn to_static<'a>(row: &Self::Row<'a>) -> Self::Row<'static> {
        BillingBillingDirectionReconOther2Row {
            contractyear: row.contractyear.clone(),
            weekno: row.weekno.clone(),
            billrunno: row.billrunno.clone(),
            direction_id: row.direction_id.clone(),
            regionid: row.regionid.clone(),
            direction_desc: row.direction_desc.clone(),
            direction_type_id: row.direction_type_id.clone(),
            direction_start_date: row.direction_start_date.clone(),
            direction_end_date: row.direction_end_date.clone(),
            direction_start_interval: row.direction_start_interval.clone(),
            direction_end_interval: row.direction_end_interval.clone(),
            compensation_amount: row.compensation_amount.clone(),
            interest_amount: row.interest_amount.clone(),
            independent_expert_fee: row.independent_expert_fee.clone(),
            cra: row.cra.clone(),
            regional_customer_energy: row.regional_customer_energy.clone(),
            regional_generator_energy: row.regional_generator_energy.clone(),
            regional_benefit_factor: row.regional_benefit_factor.clone(),
            region_ace_mwh: row.region_ace_mwh.clone(),
            region_asoe_mwh: row.region_asoe_mwh.clone(),
            direction_service_id: row.direction_service_id.clone(),
            backing_data: row.backing_data.to_owned(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct BillingBillingDirectionReconOther2PrimaryKey {
    pub billrunno: i64,
    pub contractyear: i64,
    pub direction_id: alloc::string::String,
    pub regionid: alloc::string::String,
    pub weekno: i64,
}
impl mmsdm_core::PrimaryKey for BillingBillingDirectionReconOther2PrimaryKey {}
impl<'data> mmsdm_core::CompareWithRow for BillingBillingDirectionReconOther2Row<'data> {
    type Row<'other> = BillingBillingDirectionReconOther2Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.direction_id() == row.direction_id()
            && self.regionid() == row.regionid() && self.weekno == row.weekno
    }
}
impl<'data> mmsdm_core::CompareWithPrimaryKey
for BillingBillingDirectionReconOther2Row<'data> {
    type PrimaryKey = BillingBillingDirectionReconOther2PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.direction_id() == key.direction_id && self.regionid() == key.regionid
            && self.weekno == key.weekno
    }
}
impl<'data> mmsdm_core::CompareWithRow for BillingBillingDirectionReconOther2PrimaryKey {
    type Row<'other> = BillingBillingDirectionReconOther2Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.direction_id == row.direction_id() && self.regionid == row.regionid()
            && self.weekno == row.weekno
    }
}
impl mmsdm_core::CompareWithPrimaryKey for BillingBillingDirectionReconOther2PrimaryKey {
    type PrimaryKey = BillingBillingDirectionReconOther2PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.direction_id == key.direction_id && self.regionid == key.regionid
            && self.weekno == key.weekno
    }
}
#[cfg(feature = "arrow")]
impl mmsdm_core::ArrowSchema for BillingBillingDirectionReconOther2 {
    type Builder = BillingBillingDirectionReconOther2Builder;
    fn schema() -> arrow::datatypes::Schema {
        arrow::datatypes::Schema::new(
            alloc::vec::Vec::from([
                arrow::datatypes::Field::new(
                    "contractyear",
                    arrow::datatypes::DataType::Int64,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "weekno",
                    arrow::datatypes::DataType::Int64,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "billrunno",
                    arrow::datatypes::DataType::Int64,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "direction_id",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "regionid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "direction_desc",
                    arrow::datatypes::DataType::Utf8,
                    true,
                ),
                arrow::datatypes::Field::new(
                    "direction_type_id",
                    arrow::datatypes::DataType::Utf8,
                    true,
                ),
                arrow::datatypes::Field::new(
                    "direction_start_date",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "direction_end_date",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "direction_start_interval",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "direction_end_interval",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "compensation_amount",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "interest_amount",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "independent_expert_fee",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "cra",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "regional_customer_energy",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "regional_generator_energy",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "regional_benefit_factor",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "region_ace_mwh",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "region_asoe_mwh",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "direction_service_id",
                    arrow::datatypes::DataType::Utf8,
                    true,
                ),
            ]),
        )
    }
    fn new_builder() -> Self::Builder {
        BillingBillingDirectionReconOther2Builder {
            contractyear_array: arrow::array::builder::Int64Builder::new(),
            weekno_array: arrow::array::builder::Int64Builder::new(),
            billrunno_array: arrow::array::builder::Int64Builder::new(),
            direction_id_array: arrow::array::builder::StringBuilder::new(),
            regionid_array: arrow::array::builder::StringBuilder::new(),
            direction_desc_array: arrow::array::builder::StringBuilder::new(),
            direction_type_id_array: arrow::array::builder::StringBuilder::new(),
            direction_start_date_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
            direction_end_date_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
            direction_start_interval_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
            direction_end_interval_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
            compensation_amount_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            interest_amount_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            independent_expert_fee_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            cra_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            regional_customer_energy_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            regional_generator_energy_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            regional_benefit_factor_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            region_ace_mwh_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            region_asoe_mwh_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            direction_service_id_array: arrow::array::builder::StringBuilder::new(),
        }
    }
    fn append_builder(builder: &mut Self::Builder, row: Self::Row<'_>) {
        builder.contractyear_array.append_value(row.contractyear);
        builder.weekno_array.append_value(row.weekno);
        builder.billrunno_array.append_value(row.billrunno);
        builder.direction_id_array.append_value(row.direction_id());
        builder.regionid_array.append_value(row.regionid());
        builder.direction_desc_array.append_option(row.direction_desc());
        builder.direction_type_id_array.append_option(row.direction_type_id());
        builder
            .direction_start_date_array
            .append_option(
                row.direction_start_date.map(|val| val.and_utc().timestamp_millis()),
            );
        builder
            .direction_end_date_array
            .append_option(
                row.direction_end_date.map(|val| val.and_utc().timestamp_millis()),
            );
        builder
            .direction_start_interval_array
            .append_option(
                row.direction_start_interval.map(|val| val.and_utc().timestamp_millis()),
            );
        builder
            .direction_end_interval_array
            .append_option(
                row.direction_end_interval.map(|val| val.and_utc().timestamp_millis()),
            );
        builder
            .compensation_amount_array
            .append_option({
                row.compensation_amount
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .interest_amount_array
            .append_option({
                row.interest_amount
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .independent_expert_fee_array
            .append_option({
                row.independent_expert_fee
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .cra_array
            .append_option({
                row.cra
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .regional_customer_energy_array
            .append_option({
                row.regional_customer_energy
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .regional_generator_energy_array
            .append_option({
                row.regional_generator_energy
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .regional_benefit_factor_array
            .append_option({
                row.regional_benefit_factor
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .region_ace_mwh_array
            .append_option({
                row.region_ace_mwh
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .region_asoe_mwh_array
            .append_option({
                row.region_asoe_mwh
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder.direction_service_id_array.append_option(row.direction_service_id());
    }
    fn finalize_builder(
        builder: &mut Self::Builder,
    ) -> mmsdm_core::Result<arrow::array::RecordBatch> {
        arrow::array::RecordBatch::try_new(
                alloc::sync::Arc::new(<Self as mmsdm_core::ArrowSchema>::schema()),
                alloc::vec::Vec::from([
                    alloc::sync::Arc::new(builder.contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.direction_id_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.regionid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.direction_desc_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.direction_type_id_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.direction_start_date_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.direction_end_date_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(
                        builder.direction_start_interval_array.finish(),
                    ) as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.direction_end_interval_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.compensation_amount_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.interest_amount_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.independent_expert_fee_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.cra_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(
                        builder.regional_customer_energy_array.finish(),
                    ) as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(
                        builder.regional_generator_energy_array.finish(),
                    ) as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.regional_benefit_factor_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.region_ace_mwh_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.region_asoe_mwh_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.direction_service_id_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                ]),
            )
            .map_err(Into::into)
    }
}
#[cfg(feature = "arrow")]
pub struct BillingBillingDirectionReconOther2Builder {
    contractyear_array: arrow::array::builder::Int64Builder,
    weekno_array: arrow::array::builder::Int64Builder,
    billrunno_array: arrow::array::builder::Int64Builder,
    direction_id_array: arrow::array::builder::StringBuilder,
    regionid_array: arrow::array::builder::StringBuilder,
    direction_desc_array: arrow::array::builder::StringBuilder,
    direction_type_id_array: arrow::array::builder::StringBuilder,
    direction_start_date_array: arrow::array::builder::TimestampMillisecondBuilder,
    direction_end_date_array: arrow::array::builder::TimestampMillisecondBuilder,
    direction_start_interval_array: arrow::array::builder::TimestampMillisecondBuilder,
    direction_end_interval_array: arrow::array::builder::TimestampMillisecondBuilder,
    compensation_amount_array: arrow::array::builder::Decimal128Builder,
    interest_amount_array: arrow::array::builder::Decimal128Builder,
    independent_expert_fee_array: arrow::array::builder::Decimal128Builder,
    cra_array: arrow::array::builder::Decimal128Builder,
    regional_customer_energy_array: arrow::array::builder::Decimal128Builder,
    regional_generator_energy_array: arrow::array::builder::Decimal128Builder,
    regional_benefit_factor_array: arrow::array::builder::Decimal128Builder,
    region_ace_mwh_array: arrow::array::builder::Decimal128Builder,
    region_asoe_mwh_array: arrow::array::builder::Decimal128Builder,
    direction_service_id_array: arrow::array::builder::StringBuilder,
}
pub struct BillingDirFinalAmount1 {
    extract_row_partition: alloc::boxed::Box<
        dyn Fn(
            &BillingDirFinalAmount1Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    >,
    row_partition_key: mmsdm_core::PartitionKey,
}
impl BillingDirFinalAmount1 {
    pub fn new(
        row_partition_key: mmsdm_core::PartitionKey,
        func: impl Fn(
            &<Self as mmsdm_core::GetTable>::Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    ) -> Self {
        Self {
            extract_row_partition: alloc::boxed::Box::new(func),
            row_partition_key,
        }
    }
}
pub struct BillingDirFinalAmount1Mapping([usize; 9]);
/// # Summary
///
/// ## BILLING_DIR_FINAL_AMOUNT
///  _The Billing Final Directions Payment Amount for Directed/Affected/Eligible participants_
///
/// * Data Set Name: Billing
/// * File Name: Dir Final Amount
/// * Data Version: 1
///
///
///
///
///
/// # Primary Key Columns
///
/// * BILLRUNNO
/// * COMPENSATION_TYPE
/// * CONTRACTYEAR
/// * DIRECTION_ID
/// * PARTICIPANTID
/// * WEEKNO
#[derive(Debug, PartialEq, Eq)]
pub struct BillingDirFinalAmount1Row<'data> {
    /// The Billing Contract Year
    pub contractyear: rust_decimal::Decimal,
    /// The Billing WeekNo
    pub weekno: rust_decimal::Decimal,
    /// The Billing RunNo
    pub billrunno: rust_decimal::Decimal,
    /// The Direction Unique Identifier
    pub direction_id: core::ops::Range<usize>,
    /// The Direction Payment Participant ID
    pub participantid: core::ops::Range<usize>,
    /// The Direction Payment Type, Directed_Comp, Affected_Comp, Eligible_Comp.
    pub compensation_type: core::ops::Range<usize>,
    /// The Direction Provisional Payment Amount
    pub provisional_amount: Option<rust_decimal::Decimal>,
    /// The Direction Final Payment Amount
    pub final_amount: Option<rust_decimal::Decimal>,
    /// The Last datetime record is updated
    pub lastchanged: Option<chrono::NaiveDateTime>,
    backing_data: mmsdm_core::CsvRow<'data>,
}
impl<'data> BillingDirFinalAmount1Row<'data> {
    pub fn direction_id(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.direction_id.clone())
    }
    pub fn participantid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.participantid.clone())
    }
    pub fn compensation_type(&self) -> &str {
        core::ops::Index::index(
            self.backing_data.as_slice(),
            self.compensation_type.clone(),
        )
    }
}
impl mmsdm_core::GetTable for BillingDirFinalAmount1 {
    const VERSION: i32 = 1;
    const DATA_SET_NAME: &'static str = "BILLING";
    const TABLE_NAME: &'static str = "DIR_FINAL_AMOUNT";
    const DEFAULT_FIELD_MAPPING: Self::FieldMapping = BillingDirFinalAmount1Mapping([
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
    ]);
    const COLUMNS: &'static [&'static str] = &[
        "CONTRACTYEAR",
        "WEEKNO",
        "BILLRUNNO",
        "DIRECTION_ID",
        "PARTICIPANTID",
        "COMPENSATION_TYPE",
        "PROVISIONAL_AMOUNT",
        "FINAL_AMOUNT",
        "LASTCHANGED",
    ];
    type Row<'row> = BillingDirFinalAmount1Row<'row>;
    type FieldMapping = BillingDirFinalAmount1Mapping;
    type PrimaryKey = BillingDirFinalAmount1PrimaryKey;
    fn from_row<'data>(
        row: mmsdm_core::CsvRow<'data>,
        field_mapping: &Self::FieldMapping,
    ) -> mmsdm_core::Result<Self::Row<'data>> {
        Ok(BillingDirFinalAmount1Row {
            contractyear: row
                .get_custom_parsed_at_idx(
                    "contractyear",
                    field_mapping.0[0],
                    mmsdm_core::mms_decimal::parse,
                )?,
            weekno: row
                .get_custom_parsed_at_idx(
                    "weekno",
                    field_mapping.0[1],
                    mmsdm_core::mms_decimal::parse,
                )?,
            billrunno: row
                .get_custom_parsed_at_idx(
                    "billrunno",
                    field_mapping.0[2],
                    mmsdm_core::mms_decimal::parse,
                )?,
            direction_id: row.get_range("direction_id", field_mapping.0[3])?,
            participantid: row.get_range("participantid", field_mapping.0[4])?,
            compensation_type: row.get_range("compensation_type", field_mapping.0[5])?,
            provisional_amount: row
                .get_opt_custom_parsed_at_idx(
                    "provisional_amount",
                    field_mapping.0[6],
                    mmsdm_core::mms_decimal::parse,
                )?,
            final_amount: row
                .get_opt_custom_parsed_at_idx(
                    "final_amount",
                    field_mapping.0[7],
                    mmsdm_core::mms_decimal::parse,
                )?,
            lastchanged: row
                .get_opt_custom_parsed_at_idx(
                    "lastchanged",
                    field_mapping.0[8],
                    mmsdm_core::mms_datetime::parse,
                )?,
            backing_data: row,
        })
    }
    fn field_mapping_from_row<'a>(
        mut row: mmsdm_core::CsvRow<'a>,
    ) -> mmsdm_core::Result<Self::FieldMapping> {
        if !row.is_heading() {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!("Expected an I row but got {row:?}"),
                ),
            );
        }
        let row_key = mmsdm_core::FileKey::from_row(row.borrow())?;
        if !Self::matches_file_key(&row_key, row_key.version) {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!(
                        "Expected a row matching {}.{}.v{} but got {row_key}",
                        Self::DATA_SET_NAME, Self::TABLE_NAME, Self::VERSION
                    ),
                ),
            );
        }
        let mut base_mapping = Self::DEFAULT_FIELD_MAPPING.0;
        for (field_index, field) in Self::COLUMNS.iter().enumerate() {
            base_mapping[field_index] = row
                .iter_fields()
                .position(|f| f == *field)
                .unwrap_or(usize::MAX);
        }
        Ok(BillingDirFinalAmount1Mapping(base_mapping))
    }
    fn matches_file_key(key: &mmsdm_core::FileKey<'_>, version: i32) -> bool {
        version == key.version && Self::DATA_SET_NAME == key.data_set_name()
            && Self::TABLE_NAME == key.table_name()
    }
    fn primary_key(row: &Self::Row<'_>) -> BillingDirFinalAmount1PrimaryKey {
        BillingDirFinalAmount1PrimaryKey {
            billrunno: row.billrunno,
            compensation_type: row.compensation_type().to_string(),
            contractyear: row.contractyear,
            direction_id: row.direction_id().to_string(),
            participantid: row.participantid().to_string(),
            weekno: row.weekno,
        }
    }
    fn partition_value(&self, row: &Self::Row<'_>) -> mmsdm_core::PartitionValue {
        (self.extract_row_partition)(row)
    }
    fn partition_name(&self, row: &Self::Row<'_>) -> alloc::string::String {
        alloc::format!("billing_dir_final_amount_v1_{}", self.partition_value(row))
    }
    fn partition_key(&self) -> mmsdm_core::PartitionKey {
        self.row_partition_key
    }
    fn to_static<'a>(row: &Self::Row<'a>) -> Self::Row<'static> {
        BillingDirFinalAmount1Row {
            contractyear: row.contractyear.clone(),
            weekno: row.weekno.clone(),
            billrunno: row.billrunno.clone(),
            direction_id: row.direction_id.clone(),
            participantid: row.participantid.clone(),
            compensation_type: row.compensation_type.clone(),
            provisional_amount: row.provisional_amount.clone(),
            final_amount: row.final_amount.clone(),
            lastchanged: row.lastchanged.clone(),
            backing_data: row.backing_data.to_owned(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct BillingDirFinalAmount1PrimaryKey {
    pub billrunno: rust_decimal::Decimal,
    pub compensation_type: alloc::string::String,
    pub contractyear: rust_decimal::Decimal,
    pub direction_id: alloc::string::String,
    pub participantid: alloc::string::String,
    pub weekno: rust_decimal::Decimal,
}
impl mmsdm_core::PrimaryKey for BillingDirFinalAmount1PrimaryKey {}
impl<'data> mmsdm_core::CompareWithRow for BillingDirFinalAmount1Row<'data> {
    type Row<'other> = BillingDirFinalAmount1Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno
            && self.compensation_type() == row.compensation_type()
            && self.contractyear == row.contractyear
            && self.direction_id() == row.direction_id()
            && self.participantid() == row.participantid() && self.weekno == row.weekno
    }
}
impl<'data> mmsdm_core::CompareWithPrimaryKey for BillingDirFinalAmount1Row<'data> {
    type PrimaryKey = BillingDirFinalAmount1PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno
            && self.compensation_type() == key.compensation_type
            && self.contractyear == key.contractyear
            && self.direction_id() == key.direction_id
            && self.participantid() == key.participantid && self.weekno == key.weekno
    }
}
impl<'data> mmsdm_core::CompareWithRow for BillingDirFinalAmount1PrimaryKey {
    type Row<'other> = BillingDirFinalAmount1Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno
            && self.compensation_type == row.compensation_type()
            && self.contractyear == row.contractyear
            && self.direction_id == row.direction_id()
            && self.participantid == row.participantid() && self.weekno == row.weekno
    }
}
impl mmsdm_core::CompareWithPrimaryKey for BillingDirFinalAmount1PrimaryKey {
    type PrimaryKey = BillingDirFinalAmount1PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno
            && self.compensation_type == key.compensation_type
            && self.contractyear == key.contractyear
            && self.direction_id == key.direction_id
            && self.participantid == key.participantid && self.weekno == key.weekno
    }
}
#[cfg(feature = "arrow")]
impl mmsdm_core::ArrowSchema for BillingDirFinalAmount1 {
    type Builder = BillingDirFinalAmount1Builder;
    fn schema() -> arrow::datatypes::Schema {
        arrow::datatypes::Schema::new(
            alloc::vec::Vec::from([
                arrow::datatypes::Field::new(
                    "contractyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "weekno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "billrunno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "direction_id",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "participantid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "compensation_type",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "provisional_amount",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "final_amount",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lastchanged",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    true,
                ),
            ]),
        )
    }
    fn new_builder() -> Self::Builder {
        BillingDirFinalAmount1Builder {
            contractyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            weekno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            billrunno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            direction_id_array: arrow::array::builder::StringBuilder::new(),
            participantid_array: arrow::array::builder::StringBuilder::new(),
            compensation_type_array: arrow::array::builder::StringBuilder::new(),
            provisional_amount_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            final_amount_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
        }
    }
    fn append_builder(builder: &mut Self::Builder, row: Self::Row<'_>) {
        builder
            .contractyear_array
            .append_value({
                let mut val = row.contractyear;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .weekno_array
            .append_value({
                let mut val = row.weekno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .billrunno_array
            .append_value({
                let mut val = row.billrunno;
                val.rescale(0);
                val.mantissa()
            });
        builder.direction_id_array.append_value(row.direction_id());
        builder.participantid_array.append_value(row.participantid());
        builder.compensation_type_array.append_value(row.compensation_type());
        builder
            .provisional_amount_array
            .append_option({
                row.provisional_amount
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .final_amount_array
            .append_option({
                row.final_amount
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .lastchanged_array
            .append_option(row.lastchanged.map(|val| val.and_utc().timestamp_millis()));
    }
    fn finalize_builder(
        builder: &mut Self::Builder,
    ) -> mmsdm_core::Result<arrow::array::RecordBatch> {
        arrow::array::RecordBatch::try_new(
                alloc::sync::Arc::new(<Self as mmsdm_core::ArrowSchema>::schema()),
                alloc::vec::Vec::from([
                    alloc::sync::Arc::new(builder.contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.direction_id_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.participantid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.compensation_type_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.provisional_amount_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.final_amount_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lastchanged_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                ]),
            )
            .map_err(Into::into)
    }
}
#[cfg(feature = "arrow")]
pub struct BillingDirFinalAmount1Builder {
    contractyear_array: arrow::array::builder::Decimal128Builder,
    weekno_array: arrow::array::builder::Decimal128Builder,
    billrunno_array: arrow::array::builder::Decimal128Builder,
    direction_id_array: arrow::array::builder::StringBuilder,
    participantid_array: arrow::array::builder::StringBuilder,
    compensation_type_array: arrow::array::builder::StringBuilder,
    provisional_amount_array: arrow::array::builder::Decimal128Builder,
    final_amount_array: arrow::array::builder::Decimal128Builder,
    lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder,
}
pub struct BillingDirFinalRecovery1 {
    extract_row_partition: alloc::boxed::Box<
        dyn Fn(
            &BillingDirFinalRecovery1Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    >,
    row_partition_key: mmsdm_core::PartitionKey,
}
impl BillingDirFinalRecovery1 {
    pub fn new(
        row_partition_key: mmsdm_core::PartitionKey,
        func: impl Fn(
            &<Self as mmsdm_core::GetTable>::Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    ) -> Self {
        Self {
            extract_row_partition: alloc::boxed::Box::new(func),
            row_partition_key,
        }
    }
}
pub struct BillingDirFinalRecovery1Mapping([usize; 9]);
/// # Summary
///
/// ## BILLING_DIR_FINAL_RECOVERY
///  _The Billing Final Directions Recovery Amount for the participants_
///
/// * Data Set Name: Billing
/// * File Name: Dir Final Recovery
/// * Data Version: 1
///
///
///
///
///
/// # Primary Key Columns
///
/// * BILLRUNNO
/// * CONTRACTYEAR
/// * DIRECTION_ID
/// * PARTICIPANTID
/// * WEEKNO
#[derive(Debug, PartialEq, Eq)]
pub struct BillingDirFinalRecovery1Row<'data> {
    /// The Billing Contract Year
    pub contractyear: rust_decimal::Decimal,
    /// The Billing WeekNo
    pub weekno: rust_decimal::Decimal,
    /// The Billing RunNo
    pub billrunno: rust_decimal::Decimal,
    /// The Direction Unique Identifier
    pub direction_id: core::ops::Range<usize>,
    /// The Direction Payment Participant ID
    pub participantid: core::ops::Range<usize>,
    /// The Direction Compensation Recovery Amount
    pub cra_amount: Option<rust_decimal::Decimal>,
    /// The Provisional Recovery Amount
    pub provisional_amount: Option<rust_decimal::Decimal>,
    /// The Final Recovery Amount
    pub final_amount: Option<rust_decimal::Decimal>,
    /// The Last datetime record is updated
    pub lastchanged: Option<chrono::NaiveDateTime>,
    backing_data: mmsdm_core::CsvRow<'data>,
}
impl<'data> BillingDirFinalRecovery1Row<'data> {
    pub fn direction_id(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.direction_id.clone())
    }
    pub fn participantid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.participantid.clone())
    }
}
impl mmsdm_core::GetTable for BillingDirFinalRecovery1 {
    const VERSION: i32 = 1;
    const DATA_SET_NAME: &'static str = "BILLING";
    const TABLE_NAME: &'static str = "DIR_FINAL_RECOVERY";
    const DEFAULT_FIELD_MAPPING: Self::FieldMapping = BillingDirFinalRecovery1Mapping([
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
    ]);
    const COLUMNS: &'static [&'static str] = &[
        "CONTRACTYEAR",
        "WEEKNO",
        "BILLRUNNO",
        "DIRECTION_ID",
        "PARTICIPANTID",
        "CRA_AMOUNT",
        "PROVISIONAL_AMOUNT",
        "FINAL_AMOUNT",
        "LASTCHANGED",
    ];
    type Row<'row> = BillingDirFinalRecovery1Row<'row>;
    type FieldMapping = BillingDirFinalRecovery1Mapping;
    type PrimaryKey = BillingDirFinalRecovery1PrimaryKey;
    fn from_row<'data>(
        row: mmsdm_core::CsvRow<'data>,
        field_mapping: &Self::FieldMapping,
    ) -> mmsdm_core::Result<Self::Row<'data>> {
        Ok(BillingDirFinalRecovery1Row {
            contractyear: row
                .get_custom_parsed_at_idx(
                    "contractyear",
                    field_mapping.0[0],
                    mmsdm_core::mms_decimal::parse,
                )?,
            weekno: row
                .get_custom_parsed_at_idx(
                    "weekno",
                    field_mapping.0[1],
                    mmsdm_core::mms_decimal::parse,
                )?,
            billrunno: row
                .get_custom_parsed_at_idx(
                    "billrunno",
                    field_mapping.0[2],
                    mmsdm_core::mms_decimal::parse,
                )?,
            direction_id: row.get_range("direction_id", field_mapping.0[3])?,
            participantid: row.get_range("participantid", field_mapping.0[4])?,
            cra_amount: row
                .get_opt_custom_parsed_at_idx(
                    "cra_amount",
                    field_mapping.0[5],
                    mmsdm_core::mms_decimal::parse,
                )?,
            provisional_amount: row
                .get_opt_custom_parsed_at_idx(
                    "provisional_amount",
                    field_mapping.0[6],
                    mmsdm_core::mms_decimal::parse,
                )?,
            final_amount: row
                .get_opt_custom_parsed_at_idx(
                    "final_amount",
                    field_mapping.0[7],
                    mmsdm_core::mms_decimal::parse,
                )?,
            lastchanged: row
                .get_opt_custom_parsed_at_idx(
                    "lastchanged",
                    field_mapping.0[8],
                    mmsdm_core::mms_datetime::parse,
                )?,
            backing_data: row,
        })
    }
    fn field_mapping_from_row<'a>(
        mut row: mmsdm_core::CsvRow<'a>,
    ) -> mmsdm_core::Result<Self::FieldMapping> {
        if !row.is_heading() {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!("Expected an I row but got {row:?}"),
                ),
            );
        }
        let row_key = mmsdm_core::FileKey::from_row(row.borrow())?;
        if !Self::matches_file_key(&row_key, row_key.version) {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!(
                        "Expected a row matching {}.{}.v{} but got {row_key}",
                        Self::DATA_SET_NAME, Self::TABLE_NAME, Self::VERSION
                    ),
                ),
            );
        }
        let mut base_mapping = Self::DEFAULT_FIELD_MAPPING.0;
        for (field_index, field) in Self::COLUMNS.iter().enumerate() {
            base_mapping[field_index] = row
                .iter_fields()
                .position(|f| f == *field)
                .unwrap_or(usize::MAX);
        }
        Ok(BillingDirFinalRecovery1Mapping(base_mapping))
    }
    fn matches_file_key(key: &mmsdm_core::FileKey<'_>, version: i32) -> bool {
        version == key.version && Self::DATA_SET_NAME == key.data_set_name()
            && Self::TABLE_NAME == key.table_name()
    }
    fn primary_key(row: &Self::Row<'_>) -> BillingDirFinalRecovery1PrimaryKey {
        BillingDirFinalRecovery1PrimaryKey {
            billrunno: row.billrunno,
            contractyear: row.contractyear,
            direction_id: row.direction_id().to_string(),
            participantid: row.participantid().to_string(),
            weekno: row.weekno,
        }
    }
    fn partition_value(&self, row: &Self::Row<'_>) -> mmsdm_core::PartitionValue {
        (self.extract_row_partition)(row)
    }
    fn partition_name(&self, row: &Self::Row<'_>) -> alloc::string::String {
        alloc::format!("billing_dir_final_recovery_v1_{}", self.partition_value(row))
    }
    fn partition_key(&self) -> mmsdm_core::PartitionKey {
        self.row_partition_key
    }
    fn to_static<'a>(row: &Self::Row<'a>) -> Self::Row<'static> {
        BillingDirFinalRecovery1Row {
            contractyear: row.contractyear.clone(),
            weekno: row.weekno.clone(),
            billrunno: row.billrunno.clone(),
            direction_id: row.direction_id.clone(),
            participantid: row.participantid.clone(),
            cra_amount: row.cra_amount.clone(),
            provisional_amount: row.provisional_amount.clone(),
            final_amount: row.final_amount.clone(),
            lastchanged: row.lastchanged.clone(),
            backing_data: row.backing_data.to_owned(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct BillingDirFinalRecovery1PrimaryKey {
    pub billrunno: rust_decimal::Decimal,
    pub contractyear: rust_decimal::Decimal,
    pub direction_id: alloc::string::String,
    pub participantid: alloc::string::String,
    pub weekno: rust_decimal::Decimal,
}
impl mmsdm_core::PrimaryKey for BillingDirFinalRecovery1PrimaryKey {}
impl<'data> mmsdm_core::CompareWithRow for BillingDirFinalRecovery1Row<'data> {
    type Row<'other> = BillingDirFinalRecovery1Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.direction_id() == row.direction_id()
            && self.participantid() == row.participantid() && self.weekno == row.weekno
    }
}
impl<'data> mmsdm_core::CompareWithPrimaryKey for BillingDirFinalRecovery1Row<'data> {
    type PrimaryKey = BillingDirFinalRecovery1PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.direction_id() == key.direction_id
            && self.participantid() == key.participantid && self.weekno == key.weekno
    }
}
impl<'data> mmsdm_core::CompareWithRow for BillingDirFinalRecovery1PrimaryKey {
    type Row<'other> = BillingDirFinalRecovery1Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.direction_id == row.direction_id()
            && self.participantid == row.participantid() && self.weekno == row.weekno
    }
}
impl mmsdm_core::CompareWithPrimaryKey for BillingDirFinalRecovery1PrimaryKey {
    type PrimaryKey = BillingDirFinalRecovery1PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.direction_id == key.direction_id
            && self.participantid == key.participantid && self.weekno == key.weekno
    }
}
#[cfg(feature = "arrow")]
impl mmsdm_core::ArrowSchema for BillingDirFinalRecovery1 {
    type Builder = BillingDirFinalRecovery1Builder;
    fn schema() -> arrow::datatypes::Schema {
        arrow::datatypes::Schema::new(
            alloc::vec::Vec::from([
                arrow::datatypes::Field::new(
                    "contractyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "weekno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "billrunno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "direction_id",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "participantid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "cra_amount",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "provisional_amount",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "final_amount",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lastchanged",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    true,
                ),
            ]),
        )
    }
    fn new_builder() -> Self::Builder {
        BillingDirFinalRecovery1Builder {
            contractyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            weekno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            billrunno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            direction_id_array: arrow::array::builder::StringBuilder::new(),
            participantid_array: arrow::array::builder::StringBuilder::new(),
            cra_amount_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            provisional_amount_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            final_amount_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
        }
    }
    fn append_builder(builder: &mut Self::Builder, row: Self::Row<'_>) {
        builder
            .contractyear_array
            .append_value({
                let mut val = row.contractyear;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .weekno_array
            .append_value({
                let mut val = row.weekno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .billrunno_array
            .append_value({
                let mut val = row.billrunno;
                val.rescale(0);
                val.mantissa()
            });
        builder.direction_id_array.append_value(row.direction_id());
        builder.participantid_array.append_value(row.participantid());
        builder
            .cra_amount_array
            .append_option({
                row.cra_amount
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .provisional_amount_array
            .append_option({
                row.provisional_amount
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .final_amount_array
            .append_option({
                row.final_amount
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .lastchanged_array
            .append_option(row.lastchanged.map(|val| val.and_utc().timestamp_millis()));
    }
    fn finalize_builder(
        builder: &mut Self::Builder,
    ) -> mmsdm_core::Result<arrow::array::RecordBatch> {
        arrow::array::RecordBatch::try_new(
                alloc::sync::Arc::new(<Self as mmsdm_core::ArrowSchema>::schema()),
                alloc::vec::Vec::from([
                    alloc::sync::Arc::new(builder.contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.direction_id_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.participantid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.cra_amount_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.provisional_amount_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.final_amount_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lastchanged_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                ]),
            )
            .map_err(Into::into)
    }
}
#[cfg(feature = "arrow")]
pub struct BillingDirFinalRecovery1Builder {
    contractyear_array: arrow::array::builder::Decimal128Builder,
    weekno_array: arrow::array::builder::Decimal128Builder,
    billrunno_array: arrow::array::builder::Decimal128Builder,
    direction_id_array: arrow::array::builder::StringBuilder,
    participantid_array: arrow::array::builder::StringBuilder,
    cra_amount_array: arrow::array::builder::Decimal128Builder,
    provisional_amount_array: arrow::array::builder::Decimal128Builder,
    final_amount_array: arrow::array::builder::Decimal128Builder,
    lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder,
}
pub struct BillingDirProvAmount1 {
    extract_row_partition: alloc::boxed::Box<
        dyn Fn(
            &BillingDirProvAmount1Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    >,
    row_partition_key: mmsdm_core::PartitionKey,
}
impl BillingDirProvAmount1 {
    pub fn new(
        row_partition_key: mmsdm_core::PartitionKey,
        func: impl Fn(
            &<Self as mmsdm_core::GetTable>::Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    ) -> Self {
        Self {
            extract_row_partition: alloc::boxed::Box::new(func),
            row_partition_key,
        }
    }
}
pub struct BillingDirProvAmount1Mapping([usize; 8]);
/// # Summary
///
/// ## BILLING_DIR_PROV_AMOUNT
///  _The Billing Provisional Directions Payment Amount for Directed/Affected/Eligible participants_
///
/// * Data Set Name: Billing
/// * File Name: Dir Prov Amount
/// * Data Version: 1
///
///
///
///
///
/// # Primary Key Columns
///
/// * BILLRUNNO
/// * COMPENSATION_TYPE
/// * CONTRACTYEAR
/// * DIRECTION_ID
/// * PARTICIPANTID
/// * WEEKNO
#[derive(Debug, PartialEq, Eq)]
pub struct BillingDirProvAmount1Row<'data> {
    /// The Billing Contract Year
    pub contractyear: rust_decimal::Decimal,
    /// The Billing WeekNo
    pub weekno: rust_decimal::Decimal,
    /// The Billing RunNo
    pub billrunno: rust_decimal::Decimal,
    /// The Direction Unique Identifier
    pub direction_id: core::ops::Range<usize>,
    /// The Direction Payment Participant ID
    pub participantid: core::ops::Range<usize>,
    /// The Direction Payment Type, Directed_Comp, Affected_Comp, Eligible_Comp
    pub compensation_type: core::ops::Range<usize>,
    /// The Direction Payment Amount
    pub compensation_amount: Option<rust_decimal::Decimal>,
    /// The Last datetime record is updated
    pub lastchanged: Option<chrono::NaiveDateTime>,
    backing_data: mmsdm_core::CsvRow<'data>,
}
impl<'data> BillingDirProvAmount1Row<'data> {
    pub fn direction_id(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.direction_id.clone())
    }
    pub fn participantid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.participantid.clone())
    }
    pub fn compensation_type(&self) -> &str {
        core::ops::Index::index(
            self.backing_data.as_slice(),
            self.compensation_type.clone(),
        )
    }
}
impl mmsdm_core::GetTable for BillingDirProvAmount1 {
    const VERSION: i32 = 1;
    const DATA_SET_NAME: &'static str = "BILLING";
    const TABLE_NAME: &'static str = "DIR_PROV_AMOUNT";
    const DEFAULT_FIELD_MAPPING: Self::FieldMapping = BillingDirProvAmount1Mapping([
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
    ]);
    const COLUMNS: &'static [&'static str] = &[
        "CONTRACTYEAR",
        "WEEKNO",
        "BILLRUNNO",
        "DIRECTION_ID",
        "PARTICIPANTID",
        "COMPENSATION_TYPE",
        "COMPENSATION_AMOUNT",
        "LASTCHANGED",
    ];
    type Row<'row> = BillingDirProvAmount1Row<'row>;
    type FieldMapping = BillingDirProvAmount1Mapping;
    type PrimaryKey = BillingDirProvAmount1PrimaryKey;
    fn from_row<'data>(
        row: mmsdm_core::CsvRow<'data>,
        field_mapping: &Self::FieldMapping,
    ) -> mmsdm_core::Result<Self::Row<'data>> {
        Ok(BillingDirProvAmount1Row {
            contractyear: row
                .get_custom_parsed_at_idx(
                    "contractyear",
                    field_mapping.0[0],
                    mmsdm_core::mms_decimal::parse,
                )?,
            weekno: row
                .get_custom_parsed_at_idx(
                    "weekno",
                    field_mapping.0[1],
                    mmsdm_core::mms_decimal::parse,
                )?,
            billrunno: row
                .get_custom_parsed_at_idx(
                    "billrunno",
                    field_mapping.0[2],
                    mmsdm_core::mms_decimal::parse,
                )?,
            direction_id: row.get_range("direction_id", field_mapping.0[3])?,
            participantid: row.get_range("participantid", field_mapping.0[4])?,
            compensation_type: row.get_range("compensation_type", field_mapping.0[5])?,
            compensation_amount: row
                .get_opt_custom_parsed_at_idx(
                    "compensation_amount",
                    field_mapping.0[6],
                    mmsdm_core::mms_decimal::parse,
                )?,
            lastchanged: row
                .get_opt_custom_parsed_at_idx(
                    "lastchanged",
                    field_mapping.0[7],
                    mmsdm_core::mms_datetime::parse,
                )?,
            backing_data: row,
        })
    }
    fn field_mapping_from_row<'a>(
        mut row: mmsdm_core::CsvRow<'a>,
    ) -> mmsdm_core::Result<Self::FieldMapping> {
        if !row.is_heading() {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!("Expected an I row but got {row:?}"),
                ),
            );
        }
        let row_key = mmsdm_core::FileKey::from_row(row.borrow())?;
        if !Self::matches_file_key(&row_key, row_key.version) {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!(
                        "Expected a row matching {}.{}.v{} but got {row_key}",
                        Self::DATA_SET_NAME, Self::TABLE_NAME, Self::VERSION
                    ),
                ),
            );
        }
        let mut base_mapping = Self::DEFAULT_FIELD_MAPPING.0;
        for (field_index, field) in Self::COLUMNS.iter().enumerate() {
            base_mapping[field_index] = row
                .iter_fields()
                .position(|f| f == *field)
                .unwrap_or(usize::MAX);
        }
        Ok(BillingDirProvAmount1Mapping(base_mapping))
    }
    fn matches_file_key(key: &mmsdm_core::FileKey<'_>, version: i32) -> bool {
        version == key.version && Self::DATA_SET_NAME == key.data_set_name()
            && Self::TABLE_NAME == key.table_name()
    }
    fn primary_key(row: &Self::Row<'_>) -> BillingDirProvAmount1PrimaryKey {
        BillingDirProvAmount1PrimaryKey {
            billrunno: row.billrunno,
            compensation_type: row.compensation_type().to_string(),
            contractyear: row.contractyear,
            direction_id: row.direction_id().to_string(),
            participantid: row.participantid().to_string(),
            weekno: row.weekno,
        }
    }
    fn partition_value(&self, row: &Self::Row<'_>) -> mmsdm_core::PartitionValue {
        (self.extract_row_partition)(row)
    }
    fn partition_name(&self, row: &Self::Row<'_>) -> alloc::string::String {
        alloc::format!("billing_dir_prov_amount_v1_{}", self.partition_value(row))
    }
    fn partition_key(&self) -> mmsdm_core::PartitionKey {
        self.row_partition_key
    }
    fn to_static<'a>(row: &Self::Row<'a>) -> Self::Row<'static> {
        BillingDirProvAmount1Row {
            contractyear: row.contractyear.clone(),
            weekno: row.weekno.clone(),
            billrunno: row.billrunno.clone(),
            direction_id: row.direction_id.clone(),
            participantid: row.participantid.clone(),
            compensation_type: row.compensation_type.clone(),
            compensation_amount: row.compensation_amount.clone(),
            lastchanged: row.lastchanged.clone(),
            backing_data: row.backing_data.to_owned(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct BillingDirProvAmount1PrimaryKey {
    pub billrunno: rust_decimal::Decimal,
    pub compensation_type: alloc::string::String,
    pub contractyear: rust_decimal::Decimal,
    pub direction_id: alloc::string::String,
    pub participantid: alloc::string::String,
    pub weekno: rust_decimal::Decimal,
}
impl mmsdm_core::PrimaryKey for BillingDirProvAmount1PrimaryKey {}
impl<'data> mmsdm_core::CompareWithRow for BillingDirProvAmount1Row<'data> {
    type Row<'other> = BillingDirProvAmount1Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno
            && self.compensation_type() == row.compensation_type()
            && self.contractyear == row.contractyear
            && self.direction_id() == row.direction_id()
            && self.participantid() == row.participantid() && self.weekno == row.weekno
    }
}
impl<'data> mmsdm_core::CompareWithPrimaryKey for BillingDirProvAmount1Row<'data> {
    type PrimaryKey = BillingDirProvAmount1PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno
            && self.compensation_type() == key.compensation_type
            && self.contractyear == key.contractyear
            && self.direction_id() == key.direction_id
            && self.participantid() == key.participantid && self.weekno == key.weekno
    }
}
impl<'data> mmsdm_core::CompareWithRow for BillingDirProvAmount1PrimaryKey {
    type Row<'other> = BillingDirProvAmount1Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno
            && self.compensation_type == row.compensation_type()
            && self.contractyear == row.contractyear
            && self.direction_id == row.direction_id()
            && self.participantid == row.participantid() && self.weekno == row.weekno
    }
}
impl mmsdm_core::CompareWithPrimaryKey for BillingDirProvAmount1PrimaryKey {
    type PrimaryKey = BillingDirProvAmount1PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno
            && self.compensation_type == key.compensation_type
            && self.contractyear == key.contractyear
            && self.direction_id == key.direction_id
            && self.participantid == key.participantid && self.weekno == key.weekno
    }
}
#[cfg(feature = "arrow")]
impl mmsdm_core::ArrowSchema for BillingDirProvAmount1 {
    type Builder = BillingDirProvAmount1Builder;
    fn schema() -> arrow::datatypes::Schema {
        arrow::datatypes::Schema::new(
            alloc::vec::Vec::from([
                arrow::datatypes::Field::new(
                    "contractyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "weekno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "billrunno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "direction_id",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "participantid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "compensation_type",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "compensation_amount",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lastchanged",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    true,
                ),
            ]),
        )
    }
    fn new_builder() -> Self::Builder {
        BillingDirProvAmount1Builder {
            contractyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            weekno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            billrunno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            direction_id_array: arrow::array::builder::StringBuilder::new(),
            participantid_array: arrow::array::builder::StringBuilder::new(),
            compensation_type_array: arrow::array::builder::StringBuilder::new(),
            compensation_amount_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
        }
    }
    fn append_builder(builder: &mut Self::Builder, row: Self::Row<'_>) {
        builder
            .contractyear_array
            .append_value({
                let mut val = row.contractyear;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .weekno_array
            .append_value({
                let mut val = row.weekno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .billrunno_array
            .append_value({
                let mut val = row.billrunno;
                val.rescale(0);
                val.mantissa()
            });
        builder.direction_id_array.append_value(row.direction_id());
        builder.participantid_array.append_value(row.participantid());
        builder.compensation_type_array.append_value(row.compensation_type());
        builder
            .compensation_amount_array
            .append_option({
                row.compensation_amount
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .lastchanged_array
            .append_option(row.lastchanged.map(|val| val.and_utc().timestamp_millis()));
    }
    fn finalize_builder(
        builder: &mut Self::Builder,
    ) -> mmsdm_core::Result<arrow::array::RecordBatch> {
        arrow::array::RecordBatch::try_new(
                alloc::sync::Arc::new(<Self as mmsdm_core::ArrowSchema>::schema()),
                alloc::vec::Vec::from([
                    alloc::sync::Arc::new(builder.contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.direction_id_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.participantid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.compensation_type_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.compensation_amount_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lastchanged_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                ]),
            )
            .map_err(Into::into)
    }
}
#[cfg(feature = "arrow")]
pub struct BillingDirProvAmount1Builder {
    contractyear_array: arrow::array::builder::Decimal128Builder,
    weekno_array: arrow::array::builder::Decimal128Builder,
    billrunno_array: arrow::array::builder::Decimal128Builder,
    direction_id_array: arrow::array::builder::StringBuilder,
    participantid_array: arrow::array::builder::StringBuilder,
    compensation_type_array: arrow::array::builder::StringBuilder,
    compensation_amount_array: arrow::array::builder::Decimal128Builder,
    lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder,
}
pub struct BillingDirProvRecovery1 {
    extract_row_partition: alloc::boxed::Box<
        dyn Fn(
            &BillingDirProvRecovery1Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    >,
    row_partition_key: mmsdm_core::PartitionKey,
}
impl BillingDirProvRecovery1 {
    pub fn new(
        row_partition_key: mmsdm_core::PartitionKey,
        func: impl Fn(
            &<Self as mmsdm_core::GetTable>::Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    ) -> Self {
        Self {
            extract_row_partition: alloc::boxed::Box::new(func),
            row_partition_key,
        }
    }
}
pub struct BillingDirProvRecovery1Mapping([usize; 8]);
/// # Summary
///
/// ## BILLING_DIR_PROV_RECOVERY
///  _The Billing Provisional Directions Recovery Amount for the participants_
///
/// * Data Set Name: Billing
/// * File Name: Dir Prov Recovery
/// * Data Version: 1
///
///
///
///
///
/// # Primary Key Columns
///
/// * BILLRUNNO
/// * CONTRACTYEAR
/// * DIRECTION_ID
/// * PARTICIPANTID
/// * WEEKNO
#[derive(Debug, PartialEq, Eq)]
pub struct BillingDirProvRecovery1Row<'data> {
    /// The Billing Contract Year
    pub contractyear: rust_decimal::Decimal,
    /// The Billing WeekNo
    pub weekno: rust_decimal::Decimal,
    /// The Billing RunNo
    pub billrunno: rust_decimal::Decimal,
    /// The Direction Unique Identifier
    pub direction_id: core::ops::Range<usize>,
    /// The Direction Payment Participant ID
    pub participantid: core::ops::Range<usize>,
    /// The Direction Compensation Recovery Amount
    pub cra_amount: Option<rust_decimal::Decimal>,
    /// The Direction Recovery Amount
    pub recovery_amount: Option<rust_decimal::Decimal>,
    /// The Last datetime record is updated
    pub lastchanged: Option<chrono::NaiveDateTime>,
    backing_data: mmsdm_core::CsvRow<'data>,
}
impl<'data> BillingDirProvRecovery1Row<'data> {
    pub fn direction_id(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.direction_id.clone())
    }
    pub fn participantid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.participantid.clone())
    }
}
impl mmsdm_core::GetTable for BillingDirProvRecovery1 {
    const VERSION: i32 = 1;
    const DATA_SET_NAME: &'static str = "BILLING";
    const TABLE_NAME: &'static str = "DIR_PROV_RECOVERY";
    const DEFAULT_FIELD_MAPPING: Self::FieldMapping = BillingDirProvRecovery1Mapping([
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
    ]);
    const COLUMNS: &'static [&'static str] = &[
        "CONTRACTYEAR",
        "WEEKNO",
        "BILLRUNNO",
        "DIRECTION_ID",
        "PARTICIPANTID",
        "CRA_AMOUNT",
        "RECOVERY_AMOUNT",
        "LASTCHANGED",
    ];
    type Row<'row> = BillingDirProvRecovery1Row<'row>;
    type FieldMapping = BillingDirProvRecovery1Mapping;
    type PrimaryKey = BillingDirProvRecovery1PrimaryKey;
    fn from_row<'data>(
        row: mmsdm_core::CsvRow<'data>,
        field_mapping: &Self::FieldMapping,
    ) -> mmsdm_core::Result<Self::Row<'data>> {
        Ok(BillingDirProvRecovery1Row {
            contractyear: row
                .get_custom_parsed_at_idx(
                    "contractyear",
                    field_mapping.0[0],
                    mmsdm_core::mms_decimal::parse,
                )?,
            weekno: row
                .get_custom_parsed_at_idx(
                    "weekno",
                    field_mapping.0[1],
                    mmsdm_core::mms_decimal::parse,
                )?,
            billrunno: row
                .get_custom_parsed_at_idx(
                    "billrunno",
                    field_mapping.0[2],
                    mmsdm_core::mms_decimal::parse,
                )?,
            direction_id: row.get_range("direction_id", field_mapping.0[3])?,
            participantid: row.get_range("participantid", field_mapping.0[4])?,
            cra_amount: row
                .get_opt_custom_parsed_at_idx(
                    "cra_amount",
                    field_mapping.0[5],
                    mmsdm_core::mms_decimal::parse,
                )?,
            recovery_amount: row
                .get_opt_custom_parsed_at_idx(
                    "recovery_amount",
                    field_mapping.0[6],
                    mmsdm_core::mms_decimal::parse,
                )?,
            lastchanged: row
                .get_opt_custom_parsed_at_idx(
                    "lastchanged",
                    field_mapping.0[7],
                    mmsdm_core::mms_datetime::parse,
                )?,
            backing_data: row,
        })
    }
    fn field_mapping_from_row<'a>(
        mut row: mmsdm_core::CsvRow<'a>,
    ) -> mmsdm_core::Result<Self::FieldMapping> {
        if !row.is_heading() {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!("Expected an I row but got {row:?}"),
                ),
            );
        }
        let row_key = mmsdm_core::FileKey::from_row(row.borrow())?;
        if !Self::matches_file_key(&row_key, row_key.version) {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!(
                        "Expected a row matching {}.{}.v{} but got {row_key}",
                        Self::DATA_SET_NAME, Self::TABLE_NAME, Self::VERSION
                    ),
                ),
            );
        }
        let mut base_mapping = Self::DEFAULT_FIELD_MAPPING.0;
        for (field_index, field) in Self::COLUMNS.iter().enumerate() {
            base_mapping[field_index] = row
                .iter_fields()
                .position(|f| f == *field)
                .unwrap_or(usize::MAX);
        }
        Ok(BillingDirProvRecovery1Mapping(base_mapping))
    }
    fn matches_file_key(key: &mmsdm_core::FileKey<'_>, version: i32) -> bool {
        version == key.version && Self::DATA_SET_NAME == key.data_set_name()
            && Self::TABLE_NAME == key.table_name()
    }
    fn primary_key(row: &Self::Row<'_>) -> BillingDirProvRecovery1PrimaryKey {
        BillingDirProvRecovery1PrimaryKey {
            billrunno: row.billrunno,
            contractyear: row.contractyear,
            direction_id: row.direction_id().to_string(),
            participantid: row.participantid().to_string(),
            weekno: row.weekno,
        }
    }
    fn partition_value(&self, row: &Self::Row<'_>) -> mmsdm_core::PartitionValue {
        (self.extract_row_partition)(row)
    }
    fn partition_name(&self, row: &Self::Row<'_>) -> alloc::string::String {
        alloc::format!("billing_dir_prov_recovery_v1_{}", self.partition_value(row))
    }
    fn partition_key(&self) -> mmsdm_core::PartitionKey {
        self.row_partition_key
    }
    fn to_static<'a>(row: &Self::Row<'a>) -> Self::Row<'static> {
        BillingDirProvRecovery1Row {
            contractyear: row.contractyear.clone(),
            weekno: row.weekno.clone(),
            billrunno: row.billrunno.clone(),
            direction_id: row.direction_id.clone(),
            participantid: row.participantid.clone(),
            cra_amount: row.cra_amount.clone(),
            recovery_amount: row.recovery_amount.clone(),
            lastchanged: row.lastchanged.clone(),
            backing_data: row.backing_data.to_owned(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct BillingDirProvRecovery1PrimaryKey {
    pub billrunno: rust_decimal::Decimal,
    pub contractyear: rust_decimal::Decimal,
    pub direction_id: alloc::string::String,
    pub participantid: alloc::string::String,
    pub weekno: rust_decimal::Decimal,
}
impl mmsdm_core::PrimaryKey for BillingDirProvRecovery1PrimaryKey {}
impl<'data> mmsdm_core::CompareWithRow for BillingDirProvRecovery1Row<'data> {
    type Row<'other> = BillingDirProvRecovery1Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.direction_id() == row.direction_id()
            && self.participantid() == row.participantid() && self.weekno == row.weekno
    }
}
impl<'data> mmsdm_core::CompareWithPrimaryKey for BillingDirProvRecovery1Row<'data> {
    type PrimaryKey = BillingDirProvRecovery1PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.direction_id() == key.direction_id
            && self.participantid() == key.participantid && self.weekno == key.weekno
    }
}
impl<'data> mmsdm_core::CompareWithRow for BillingDirProvRecovery1PrimaryKey {
    type Row<'other> = BillingDirProvRecovery1Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.direction_id == row.direction_id()
            && self.participantid == row.participantid() && self.weekno == row.weekno
    }
}
impl mmsdm_core::CompareWithPrimaryKey for BillingDirProvRecovery1PrimaryKey {
    type PrimaryKey = BillingDirProvRecovery1PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.direction_id == key.direction_id
            && self.participantid == key.participantid && self.weekno == key.weekno
    }
}
#[cfg(feature = "arrow")]
impl mmsdm_core::ArrowSchema for BillingDirProvRecovery1 {
    type Builder = BillingDirProvRecovery1Builder;
    fn schema() -> arrow::datatypes::Schema {
        arrow::datatypes::Schema::new(
            alloc::vec::Vec::from([
                arrow::datatypes::Field::new(
                    "contractyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "weekno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "billrunno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "direction_id",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "participantid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "cra_amount",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "recovery_amount",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lastchanged",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    true,
                ),
            ]),
        )
    }
    fn new_builder() -> Self::Builder {
        BillingDirProvRecovery1Builder {
            contractyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            weekno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            billrunno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            direction_id_array: arrow::array::builder::StringBuilder::new(),
            participantid_array: arrow::array::builder::StringBuilder::new(),
            cra_amount_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            recovery_amount_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
        }
    }
    fn append_builder(builder: &mut Self::Builder, row: Self::Row<'_>) {
        builder
            .contractyear_array
            .append_value({
                let mut val = row.contractyear;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .weekno_array
            .append_value({
                let mut val = row.weekno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .billrunno_array
            .append_value({
                let mut val = row.billrunno;
                val.rescale(0);
                val.mantissa()
            });
        builder.direction_id_array.append_value(row.direction_id());
        builder.participantid_array.append_value(row.participantid());
        builder
            .cra_amount_array
            .append_option({
                row.cra_amount
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .recovery_amount_array
            .append_option({
                row.recovery_amount
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .lastchanged_array
            .append_option(row.lastchanged.map(|val| val.and_utc().timestamp_millis()));
    }
    fn finalize_builder(
        builder: &mut Self::Builder,
    ) -> mmsdm_core::Result<arrow::array::RecordBatch> {
        arrow::array::RecordBatch::try_new(
                alloc::sync::Arc::new(<Self as mmsdm_core::ArrowSchema>::schema()),
                alloc::vec::Vec::from([
                    alloc::sync::Arc::new(builder.contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.direction_id_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.participantid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.cra_amount_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.recovery_amount_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lastchanged_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                ]),
            )
            .map_err(Into::into)
    }
}
#[cfg(feature = "arrow")]
pub struct BillingDirProvRecovery1Builder {
    contractyear_array: arrow::array::builder::Decimal128Builder,
    weekno_array: arrow::array::builder::Decimal128Builder,
    billrunno_array: arrow::array::builder::Decimal128Builder,
    direction_id_array: arrow::array::builder::StringBuilder,
    participantid_array: arrow::array::builder::StringBuilder,
    cra_amount_array: arrow::array::builder::Decimal128Builder,
    recovery_amount_array: arrow::array::builder::Decimal128Builder,
    lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder,
}
pub struct BillingDirRecoveryDetail1 {
    extract_row_partition: alloc::boxed::Box<
        dyn Fn(
            &BillingDirRecoveryDetail1Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    >,
    row_partition_key: mmsdm_core::PartitionKey,
}
impl BillingDirRecoveryDetail1 {
    pub fn new(
        row_partition_key: mmsdm_core::PartitionKey,
        func: impl Fn(
            &<Self as mmsdm_core::GetTable>::Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    ) -> Self {
        Self {
            extract_row_partition: alloc::boxed::Box::new(func),
            row_partition_key,
        }
    }
}
pub struct BillingDirRecoveryDetail1Mapping([usize; 12]);
/// # Summary
///
/// ## BILLING_DIR_RECOVERY_DETAIL
///  _The Billing Directions Recovery Details for the participants_
///
/// * Data Set Name: Billing
/// * File Name: Dir Recovery Detail
/// * Data Version: 1
///
///
///
///
///
/// # Primary Key Columns
///
/// * BILLRUNNO
/// * CONTRACTYEAR
/// * DIRECTION_ID
/// * PARTICIPANTCATEGORYID
/// * PARTICIPANTID
/// * REGIONID
/// * WEEKNO
#[derive(Debug, PartialEq, Eq)]
pub struct BillingDirRecoveryDetail1Row<'data> {
    /// The Billing Contract Year
    pub contractyear: rust_decimal::Decimal,
    /// The Billing WeekNo
    pub weekno: rust_decimal::Decimal,
    /// The Billing RunNo
    pub billrunno: rust_decimal::Decimal,
    /// The Direction Unique Identifier
    pub direction_id: core::ops::Range<usize>,
    /// The Direction Payment Participant ID
    pub participantid: core::ops::Range<usize>,
    /// The Participant Category for recovery Customer/Generator /SmallGen
    pub participantcategoryid: core::ops::Range<usize>,
    /// The Region ID for the recovery
    pub regionid: core::ops::Range<usize>,
    /// The Direction Recovery Amount
    pub recovery_amount: Option<rust_decimal::Decimal>,
    /// The Energy Value used for the Recovery
    pub recovery_energy: Option<rust_decimal::Decimal>,
    /// The total Energy at the Region ID
    pub region_energy: Option<rust_decimal::Decimal>,
    /// The Energy Value (Scheduled Loads) that is excluded
    pub excluded_energy: Option<rust_decimal::Decimal>,
    /// The Last datetime record is updated
    pub lastchanged: Option<chrono::NaiveDateTime>,
    backing_data: mmsdm_core::CsvRow<'data>,
}
impl<'data> BillingDirRecoveryDetail1Row<'data> {
    pub fn direction_id(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.direction_id.clone())
    }
    pub fn participantid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.participantid.clone())
    }
    pub fn participantcategoryid(&self) -> &str {
        core::ops::Index::index(
            self.backing_data.as_slice(),
            self.participantcategoryid.clone(),
        )
    }
    pub fn regionid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.regionid.clone())
    }
}
impl mmsdm_core::GetTable for BillingDirRecoveryDetail1 {
    const VERSION: i32 = 1;
    const DATA_SET_NAME: &'static str = "BILLING";
    const TABLE_NAME: &'static str = "DIR_RECOVERY_DETAIL";
    const DEFAULT_FIELD_MAPPING: Self::FieldMapping = BillingDirRecoveryDetail1Mapping([
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
    ]);
    const COLUMNS: &'static [&'static str] = &[
        "CONTRACTYEAR",
        "WEEKNO",
        "BILLRUNNO",
        "DIRECTION_ID",
        "PARTICIPANTID",
        "PARTICIPANTCATEGORYID",
        "REGIONID",
        "RECOVERY_AMOUNT",
        "RECOVERY_ENERGY",
        "REGION_ENERGY",
        "EXCLUDED_ENERGY",
        "LASTCHANGED",
    ];
    type Row<'row> = BillingDirRecoveryDetail1Row<'row>;
    type FieldMapping = BillingDirRecoveryDetail1Mapping;
    type PrimaryKey = BillingDirRecoveryDetail1PrimaryKey;
    fn from_row<'data>(
        row: mmsdm_core::CsvRow<'data>,
        field_mapping: &Self::FieldMapping,
    ) -> mmsdm_core::Result<Self::Row<'data>> {
        Ok(BillingDirRecoveryDetail1Row {
            contractyear: row
                .get_custom_parsed_at_idx(
                    "contractyear",
                    field_mapping.0[0],
                    mmsdm_core::mms_decimal::parse,
                )?,
            weekno: row
                .get_custom_parsed_at_idx(
                    "weekno",
                    field_mapping.0[1],
                    mmsdm_core::mms_decimal::parse,
                )?,
            billrunno: row
                .get_custom_parsed_at_idx(
                    "billrunno",
                    field_mapping.0[2],
                    mmsdm_core::mms_decimal::parse,
                )?,
            direction_id: row.get_range("direction_id", field_mapping.0[3])?,
            participantid: row.get_range("participantid", field_mapping.0[4])?,
            participantcategoryid: row
                .get_range("participantcategoryid", field_mapping.0[5])?,
            regionid: row.get_range("regionid", field_mapping.0[6])?,
            recovery_amount: row
                .get_opt_custom_parsed_at_idx(
                    "recovery_amount",
                    field_mapping.0[7],
                    mmsdm_core::mms_decimal::parse,
                )?,
            recovery_energy: row
                .get_opt_custom_parsed_at_idx(
                    "recovery_energy",
                    field_mapping.0[8],
                    mmsdm_core::mms_decimal::parse,
                )?,
            region_energy: row
                .get_opt_custom_parsed_at_idx(
                    "region_energy",
                    field_mapping.0[9],
                    mmsdm_core::mms_decimal::parse,
                )?,
            excluded_energy: row
                .get_opt_custom_parsed_at_idx(
                    "excluded_energy",
                    field_mapping.0[10],
                    mmsdm_core::mms_decimal::parse,
                )?,
            lastchanged: row
                .get_opt_custom_parsed_at_idx(
                    "lastchanged",
                    field_mapping.0[11],
                    mmsdm_core::mms_datetime::parse,
                )?,
            backing_data: row,
        })
    }
    fn field_mapping_from_row<'a>(
        mut row: mmsdm_core::CsvRow<'a>,
    ) -> mmsdm_core::Result<Self::FieldMapping> {
        if !row.is_heading() {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!("Expected an I row but got {row:?}"),
                ),
            );
        }
        let row_key = mmsdm_core::FileKey::from_row(row.borrow())?;
        if !Self::matches_file_key(&row_key, row_key.version) {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!(
                        "Expected a row matching {}.{}.v{} but got {row_key}",
                        Self::DATA_SET_NAME, Self::TABLE_NAME, Self::VERSION
                    ),
                ),
            );
        }
        let mut base_mapping = Self::DEFAULT_FIELD_MAPPING.0;
        for (field_index, field) in Self::COLUMNS.iter().enumerate() {
            base_mapping[field_index] = row
                .iter_fields()
                .position(|f| f == *field)
                .unwrap_or(usize::MAX);
        }
        Ok(BillingDirRecoveryDetail1Mapping(base_mapping))
    }
    fn matches_file_key(key: &mmsdm_core::FileKey<'_>, version: i32) -> bool {
        version == key.version && Self::DATA_SET_NAME == key.data_set_name()
            && Self::TABLE_NAME == key.table_name()
    }
    fn primary_key(row: &Self::Row<'_>) -> BillingDirRecoveryDetail1PrimaryKey {
        BillingDirRecoveryDetail1PrimaryKey {
            billrunno: row.billrunno,
            contractyear: row.contractyear,
            direction_id: row.direction_id().to_string(),
            participantcategoryid: row.participantcategoryid().to_string(),
            participantid: row.participantid().to_string(),
            regionid: row.regionid().to_string(),
            weekno: row.weekno,
        }
    }
    fn partition_value(&self, row: &Self::Row<'_>) -> mmsdm_core::PartitionValue {
        (self.extract_row_partition)(row)
    }
    fn partition_name(&self, row: &Self::Row<'_>) -> alloc::string::String {
        alloc::format!("billing_dir_recovery_detail_v1_{}", self.partition_value(row))
    }
    fn partition_key(&self) -> mmsdm_core::PartitionKey {
        self.row_partition_key
    }
    fn to_static<'a>(row: &Self::Row<'a>) -> Self::Row<'static> {
        BillingDirRecoveryDetail1Row {
            contractyear: row.contractyear.clone(),
            weekno: row.weekno.clone(),
            billrunno: row.billrunno.clone(),
            direction_id: row.direction_id.clone(),
            participantid: row.participantid.clone(),
            participantcategoryid: row.participantcategoryid.clone(),
            regionid: row.regionid.clone(),
            recovery_amount: row.recovery_amount.clone(),
            recovery_energy: row.recovery_energy.clone(),
            region_energy: row.region_energy.clone(),
            excluded_energy: row.excluded_energy.clone(),
            lastchanged: row.lastchanged.clone(),
            backing_data: row.backing_data.to_owned(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct BillingDirRecoveryDetail1PrimaryKey {
    pub billrunno: rust_decimal::Decimal,
    pub contractyear: rust_decimal::Decimal,
    pub direction_id: alloc::string::String,
    pub participantcategoryid: alloc::string::String,
    pub participantid: alloc::string::String,
    pub regionid: alloc::string::String,
    pub weekno: rust_decimal::Decimal,
}
impl mmsdm_core::PrimaryKey for BillingDirRecoveryDetail1PrimaryKey {}
impl<'data> mmsdm_core::CompareWithRow for BillingDirRecoveryDetail1Row<'data> {
    type Row<'other> = BillingDirRecoveryDetail1Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.direction_id() == row.direction_id()
            && self.participantcategoryid() == row.participantcategoryid()
            && self.participantid() == row.participantid()
            && self.regionid() == row.regionid() && self.weekno == row.weekno
    }
}
impl<'data> mmsdm_core::CompareWithPrimaryKey for BillingDirRecoveryDetail1Row<'data> {
    type PrimaryKey = BillingDirRecoveryDetail1PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.direction_id() == key.direction_id
            && self.participantcategoryid() == key.participantcategoryid
            && self.participantid() == key.participantid
            && self.regionid() == key.regionid && self.weekno == key.weekno
    }
}
impl<'data> mmsdm_core::CompareWithRow for BillingDirRecoveryDetail1PrimaryKey {
    type Row<'other> = BillingDirRecoveryDetail1Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.direction_id == row.direction_id()
            && self.participantcategoryid == row.participantcategoryid()
            && self.participantid == row.participantid()
            && self.regionid == row.regionid() && self.weekno == row.weekno
    }
}
impl mmsdm_core::CompareWithPrimaryKey for BillingDirRecoveryDetail1PrimaryKey {
    type PrimaryKey = BillingDirRecoveryDetail1PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.direction_id == key.direction_id
            && self.participantcategoryid == key.participantcategoryid
            && self.participantid == key.participantid && self.regionid == key.regionid
            && self.weekno == key.weekno
    }
}
#[cfg(feature = "arrow")]
impl mmsdm_core::ArrowSchema for BillingDirRecoveryDetail1 {
    type Builder = BillingDirRecoveryDetail1Builder;
    fn schema() -> arrow::datatypes::Schema {
        arrow::datatypes::Schema::new(
            alloc::vec::Vec::from([
                arrow::datatypes::Field::new(
                    "contractyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "weekno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "billrunno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "direction_id",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "participantid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "participantcategoryid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "regionid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "recovery_amount",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "recovery_energy",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "region_energy",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "excluded_energy",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lastchanged",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    true,
                ),
            ]),
        )
    }
    fn new_builder() -> Self::Builder {
        BillingDirRecoveryDetail1Builder {
            contractyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            weekno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            billrunno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            direction_id_array: arrow::array::builder::StringBuilder::new(),
            participantid_array: arrow::array::builder::StringBuilder::new(),
            participantcategoryid_array: arrow::array::builder::StringBuilder::new(),
            regionid_array: arrow::array::builder::StringBuilder::new(),
            recovery_amount_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            recovery_energy_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            region_energy_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            excluded_energy_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
        }
    }
    fn append_builder(builder: &mut Self::Builder, row: Self::Row<'_>) {
        builder
            .contractyear_array
            .append_value({
                let mut val = row.contractyear;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .weekno_array
            .append_value({
                let mut val = row.weekno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .billrunno_array
            .append_value({
                let mut val = row.billrunno;
                val.rescale(0);
                val.mantissa()
            });
        builder.direction_id_array.append_value(row.direction_id());
        builder.participantid_array.append_value(row.participantid());
        builder.participantcategoryid_array.append_value(row.participantcategoryid());
        builder.regionid_array.append_value(row.regionid());
        builder
            .recovery_amount_array
            .append_option({
                row.recovery_amount
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .recovery_energy_array
            .append_option({
                row.recovery_energy
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .region_energy_array
            .append_option({
                row.region_energy
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .excluded_energy_array
            .append_option({
                row.excluded_energy
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .lastchanged_array
            .append_option(row.lastchanged.map(|val| val.and_utc().timestamp_millis()));
    }
    fn finalize_builder(
        builder: &mut Self::Builder,
    ) -> mmsdm_core::Result<arrow::array::RecordBatch> {
        arrow::array::RecordBatch::try_new(
                alloc::sync::Arc::new(<Self as mmsdm_core::ArrowSchema>::schema()),
                alloc::vec::Vec::from([
                    alloc::sync::Arc::new(builder.contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.direction_id_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.participantid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.participantcategoryid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.regionid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.recovery_amount_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.recovery_energy_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.region_energy_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.excluded_energy_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lastchanged_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                ]),
            )
            .map_err(Into::into)
    }
}
#[cfg(feature = "arrow")]
pub struct BillingDirRecoveryDetail1Builder {
    contractyear_array: arrow::array::builder::Decimal128Builder,
    weekno_array: arrow::array::builder::Decimal128Builder,
    billrunno_array: arrow::array::builder::Decimal128Builder,
    direction_id_array: arrow::array::builder::StringBuilder,
    participantid_array: arrow::array::builder::StringBuilder,
    participantcategoryid_array: arrow::array::builder::StringBuilder,
    regionid_array: arrow::array::builder::StringBuilder,
    recovery_amount_array: arrow::array::builder::Decimal128Builder,
    recovery_energy_array: arrow::array::builder::Decimal128Builder,
    region_energy_array: arrow::array::builder::Decimal128Builder,
    excluded_energy_array: arrow::array::builder::Decimal128Builder,
    lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder,
}
pub struct BillingEftshortfallAmount1 {
    extract_row_partition: alloc::boxed::Box<
        dyn Fn(
            &BillingEftshortfallAmount1Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    >,
    row_partition_key: mmsdm_core::PartitionKey,
}
impl BillingEftshortfallAmount1 {
    pub fn new(
        row_partition_key: mmsdm_core::PartitionKey,
        func: impl Fn(
            &<Self as mmsdm_core::GetTable>::Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    ) -> Self {
        Self {
            extract_row_partition: alloc::boxed::Box::new(func),
            row_partition_key,
        }
    }
}
pub struct BillingEftshortfallAmount1Mapping([usize; 10]);
/// # Summary
///
/// ## BILLING_EFTSHORTFALL_AMOUNT
///  _The billing shortfall run amounts_
///
/// * Data Set Name: Billing
/// * File Name: Eftshortfall Amount
/// * Data Version: 1
///
/// # Description
///  BILLING_EFTSHORTFALL_AMOUNT data is confidential, and is available only to the relevant participant.
///
///
///
/// # Primary Key Columns
///
/// * BILLRUNNO
/// * CONTRACTYEAR
/// * PARTICIPANTID
/// * WEEKNO
#[derive(Debug, PartialEq, Eq)]
pub struct BillingEftshortfallAmount1Row<'data> {
    /// The shortfall affected billing contract year
    pub contractyear: rust_decimal::Decimal,
    /// The shortfall affected billing week no
    pub weekno: rust_decimal::Decimal,
    /// The shortfall affected billing week run no
    pub billrunno: rust_decimal::Decimal,
    /// The participant affected by the shortfall calculation
    pub participantid: core::ops::Range<usize>,
    /// The Participant shortfall amount
    pub shortfall_amount: Option<rust_decimal::Decimal>,
    /// The market shortfall amount
    pub shortfall: Option<rust_decimal::Decimal>,
    /// The Company ID associated with the Participant ID used in the shortfall calculation
    pub shortfall_company_id: core::ops::Range<usize>,
    /// The shortfall amount for the Company ID associated with the Participant ID used in the shortfall calculation
    pub company_shortfall_amount: Option<rust_decimal::Decimal>,
    /// The participant NET energy used in shortfall calculation
    pub participant_net_energy: Option<rust_decimal::Decimal>,
    /// The NET energy for the Company ID associated with the Participant ID used in the shortfall calculation
    pub company_net_energy: Option<rust_decimal::Decimal>,
    backing_data: mmsdm_core::CsvRow<'data>,
}
impl<'data> BillingEftshortfallAmount1Row<'data> {
    pub fn participantid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.participantid.clone())
    }
    pub fn shortfall_company_id(&self) -> Option<&str> {
        if self.shortfall_company_id.is_empty() {
            None
        } else {
            Some(
                core::ops::Index::index(
                    self.backing_data.as_slice(),
                    self.shortfall_company_id.clone(),
                ),
            )
        }
    }
}
impl mmsdm_core::GetTable for BillingEftshortfallAmount1 {
    const VERSION: i32 = 1;
    const DATA_SET_NAME: &'static str = "BILLING";
    const TABLE_NAME: &'static str = "EFTSHORTFALL_AMOUNT";
    const DEFAULT_FIELD_MAPPING: Self::FieldMapping = BillingEftshortfallAmount1Mapping([
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
    ]);
    const COLUMNS: &'static [&'static str] = &[
        "CONTRACTYEAR",
        "WEEKNO",
        "BILLRUNNO",
        "PARTICIPANTID",
        "SHORTFALL_AMOUNT",
        "SHORTFALL",
        "SHORTFALL_COMPANY_ID",
        "COMPANY_SHORTFALL_AMOUNT",
        "PARTICIPANT_NET_ENERGY",
        "COMPANY_NET_ENERGY",
    ];
    type Row<'row> = BillingEftshortfallAmount1Row<'row>;
    type FieldMapping = BillingEftshortfallAmount1Mapping;
    type PrimaryKey = BillingEftshortfallAmount1PrimaryKey;
    fn from_row<'data>(
        row: mmsdm_core::CsvRow<'data>,
        field_mapping: &Self::FieldMapping,
    ) -> mmsdm_core::Result<Self::Row<'data>> {
        Ok(BillingEftshortfallAmount1Row {
            contractyear: row
                .get_custom_parsed_at_idx(
                    "contractyear",
                    field_mapping.0[0],
                    mmsdm_core::mms_decimal::parse,
                )?,
            weekno: row
                .get_custom_parsed_at_idx(
                    "weekno",
                    field_mapping.0[1],
                    mmsdm_core::mms_decimal::parse,
                )?,
            billrunno: row
                .get_custom_parsed_at_idx(
                    "billrunno",
                    field_mapping.0[2],
                    mmsdm_core::mms_decimal::parse,
                )?,
            participantid: row.get_range("participantid", field_mapping.0[3])?,
            shortfall_amount: row
                .get_opt_custom_parsed_at_idx(
                    "shortfall_amount",
                    field_mapping.0[4],
                    mmsdm_core::mms_decimal::parse,
                )?,
            shortfall: row
                .get_opt_custom_parsed_at_idx(
                    "shortfall",
                    field_mapping.0[5],
                    mmsdm_core::mms_decimal::parse,
                )?,
            shortfall_company_id: row
                .get_opt_range("shortfall_company_id", field_mapping.0[6])?,
            company_shortfall_amount: row
                .get_opt_custom_parsed_at_idx(
                    "company_shortfall_amount",
                    field_mapping.0[7],
                    mmsdm_core::mms_decimal::parse,
                )?,
            participant_net_energy: row
                .get_opt_custom_parsed_at_idx(
                    "participant_net_energy",
                    field_mapping.0[8],
                    mmsdm_core::mms_decimal::parse,
                )?,
            company_net_energy: row
                .get_opt_custom_parsed_at_idx(
                    "company_net_energy",
                    field_mapping.0[9],
                    mmsdm_core::mms_decimal::parse,
                )?,
            backing_data: row,
        })
    }
    fn field_mapping_from_row<'a>(
        mut row: mmsdm_core::CsvRow<'a>,
    ) -> mmsdm_core::Result<Self::FieldMapping> {
        if !row.is_heading() {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!("Expected an I row but got {row:?}"),
                ),
            );
        }
        let row_key = mmsdm_core::FileKey::from_row(row.borrow())?;
        if !Self::matches_file_key(&row_key, row_key.version) {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!(
                        "Expected a row matching {}.{}.v{} but got {row_key}",
                        Self::DATA_SET_NAME, Self::TABLE_NAME, Self::VERSION
                    ),
                ),
            );
        }
        let mut base_mapping = Self::DEFAULT_FIELD_MAPPING.0;
        for (field_index, field) in Self::COLUMNS.iter().enumerate() {
            base_mapping[field_index] = row
                .iter_fields()
                .position(|f| f == *field)
                .unwrap_or(usize::MAX);
        }
        Ok(BillingEftshortfallAmount1Mapping(base_mapping))
    }
    fn matches_file_key(key: &mmsdm_core::FileKey<'_>, version: i32) -> bool {
        version == key.version && Self::DATA_SET_NAME == key.data_set_name()
            && Self::TABLE_NAME == key.table_name()
    }
    fn primary_key(row: &Self::Row<'_>) -> BillingEftshortfallAmount1PrimaryKey {
        BillingEftshortfallAmount1PrimaryKey {
            billrunno: row.billrunno,
            contractyear: row.contractyear,
            participantid: row.participantid().to_string(),
            weekno: row.weekno,
        }
    }
    fn partition_value(&self, row: &Self::Row<'_>) -> mmsdm_core::PartitionValue {
        (self.extract_row_partition)(row)
    }
    fn partition_name(&self, row: &Self::Row<'_>) -> alloc::string::String {
        alloc::format!("billing_eftshortfall_amount_v1_{}", self.partition_value(row))
    }
    fn partition_key(&self) -> mmsdm_core::PartitionKey {
        self.row_partition_key
    }
    fn to_static<'a>(row: &Self::Row<'a>) -> Self::Row<'static> {
        BillingEftshortfallAmount1Row {
            contractyear: row.contractyear.clone(),
            weekno: row.weekno.clone(),
            billrunno: row.billrunno.clone(),
            participantid: row.participantid.clone(),
            shortfall_amount: row.shortfall_amount.clone(),
            shortfall: row.shortfall.clone(),
            shortfall_company_id: row.shortfall_company_id.clone(),
            company_shortfall_amount: row.company_shortfall_amount.clone(),
            participant_net_energy: row.participant_net_energy.clone(),
            company_net_energy: row.company_net_energy.clone(),
            backing_data: row.backing_data.to_owned(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct BillingEftshortfallAmount1PrimaryKey {
    pub billrunno: rust_decimal::Decimal,
    pub contractyear: rust_decimal::Decimal,
    pub participantid: alloc::string::String,
    pub weekno: rust_decimal::Decimal,
}
impl mmsdm_core::PrimaryKey for BillingEftshortfallAmount1PrimaryKey {}
impl<'data> mmsdm_core::CompareWithRow for BillingEftshortfallAmount1Row<'data> {
    type Row<'other> = BillingEftshortfallAmount1Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.participantid() == row.participantid() && self.weekno == row.weekno
    }
}
impl<'data> mmsdm_core::CompareWithPrimaryKey for BillingEftshortfallAmount1Row<'data> {
    type PrimaryKey = BillingEftshortfallAmount1PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.participantid() == key.participantid && self.weekno == key.weekno
    }
}
impl<'data> mmsdm_core::CompareWithRow for BillingEftshortfallAmount1PrimaryKey {
    type Row<'other> = BillingEftshortfallAmount1Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.participantid == row.participantid() && self.weekno == row.weekno
    }
}
impl mmsdm_core::CompareWithPrimaryKey for BillingEftshortfallAmount1PrimaryKey {
    type PrimaryKey = BillingEftshortfallAmount1PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.participantid == key.participantid && self.weekno == key.weekno
    }
}
#[cfg(feature = "arrow")]
impl mmsdm_core::ArrowSchema for BillingEftshortfallAmount1 {
    type Builder = BillingEftshortfallAmount1Builder;
    fn schema() -> arrow::datatypes::Schema {
        arrow::datatypes::Schema::new(
            alloc::vec::Vec::from([
                arrow::datatypes::Field::new(
                    "contractyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "weekno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "billrunno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "participantid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "shortfall_amount",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "shortfall",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "shortfall_company_id",
                    arrow::datatypes::DataType::Utf8,
                    true,
                ),
                arrow::datatypes::Field::new(
                    "company_shortfall_amount",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "participant_net_energy",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "company_net_energy",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
            ]),
        )
    }
    fn new_builder() -> Self::Builder {
        BillingEftshortfallAmount1Builder {
            contractyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            weekno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            billrunno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            participantid_array: arrow::array::builder::StringBuilder::new(),
            shortfall_amount_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            shortfall_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            shortfall_company_id_array: arrow::array::builder::StringBuilder::new(),
            company_shortfall_amount_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            participant_net_energy_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            company_net_energy_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
        }
    }
    fn append_builder(builder: &mut Self::Builder, row: Self::Row<'_>) {
        builder
            .contractyear_array
            .append_value({
                let mut val = row.contractyear;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .weekno_array
            .append_value({
                let mut val = row.weekno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .billrunno_array
            .append_value({
                let mut val = row.billrunno;
                val.rescale(0);
                val.mantissa()
            });
        builder.participantid_array.append_value(row.participantid());
        builder
            .shortfall_amount_array
            .append_option({
                row.shortfall_amount
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .shortfall_array
            .append_option({
                row.shortfall
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder.shortfall_company_id_array.append_option(row.shortfall_company_id());
        builder
            .company_shortfall_amount_array
            .append_option({
                row.company_shortfall_amount
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .participant_net_energy_array
            .append_option({
                row.participant_net_energy
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .company_net_energy_array
            .append_option({
                row.company_net_energy
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
    }
    fn finalize_builder(
        builder: &mut Self::Builder,
    ) -> mmsdm_core::Result<arrow::array::RecordBatch> {
        arrow::array::RecordBatch::try_new(
                alloc::sync::Arc::new(<Self as mmsdm_core::ArrowSchema>::schema()),
                alloc::vec::Vec::from([
                    alloc::sync::Arc::new(builder.contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.participantid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.shortfall_amount_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.shortfall_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.shortfall_company_id_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(
                        builder.company_shortfall_amount_array.finish(),
                    ) as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.participant_net_energy_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.company_net_energy_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                ]),
            )
            .map_err(Into::into)
    }
}
#[cfg(feature = "arrow")]
pub struct BillingEftshortfallAmount1Builder {
    contractyear_array: arrow::array::builder::Decimal128Builder,
    weekno_array: arrow::array::builder::Decimal128Builder,
    billrunno_array: arrow::array::builder::Decimal128Builder,
    participantid_array: arrow::array::builder::StringBuilder,
    shortfall_amount_array: arrow::array::builder::Decimal128Builder,
    shortfall_array: arrow::array::builder::Decimal128Builder,
    shortfall_company_id_array: arrow::array::builder::StringBuilder,
    company_shortfall_amount_array: arrow::array::builder::Decimal128Builder,
    participant_net_energy_array: arrow::array::builder::Decimal128Builder,
    company_net_energy_array: arrow::array::builder::Decimal128Builder,
}
pub struct BillingEftshortfallDetail1 {
    extract_row_partition: alloc::boxed::Box<
        dyn Fn(
            &BillingEftshortfallDetail1Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    >,
    row_partition_key: mmsdm_core::PartitionKey,
}
impl BillingEftshortfallDetail1 {
    pub fn new(
        row_partition_key: mmsdm_core::PartitionKey,
        func: impl Fn(
            &<Self as mmsdm_core::GetTable>::Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    ) -> Self {
        Self {
            extract_row_partition: alloc::boxed::Box::new(func),
            row_partition_key,
        }
    }
}
pub struct BillingEftshortfallDetail1Mapping([usize; 6]);
/// # Summary
///
/// ## BILLING_EFTSHORTFALL_DETAIL
///  _The Billing Shortfall Run Amount details_
///
/// * Data Set Name: Billing
/// * File Name: Eftshortfall Detail
/// * Data Version: 1
///
/// # Description
///  BILLING_EFTSHORTFALL_DETAIL data is confidential, and is available only to the relevant participant.
///
///
///
/// # Primary Key Columns
///
/// * BILLRUNNO
/// * CONTRACTYEAR
/// * PARTICIPANTID
/// * TRANSACTION_TYPE
/// * WEEKNO
#[derive(Debug, PartialEq, Eq)]
pub struct BillingEftshortfallDetail1Row<'data> {
    /// The shortfall affected billing contract year
    pub contractyear: rust_decimal::Decimal,
    /// The shortfall affected billing week no
    pub weekno: rust_decimal::Decimal,
    /// The shortfall affected billing week run no
    pub billrunno: rust_decimal::Decimal,
    /// The participant affected by the shortfall calculation
    pub participantid: core::ops::Range<usize>,
    /// The transaction type details associated with the shortfall calculation
    pub transaction_type: core::ops::Range<usize>,
    /// The amount for each transaction type
    pub amount: Option<rust_decimal::Decimal>,
    backing_data: mmsdm_core::CsvRow<'data>,
}
impl<'data> BillingEftshortfallDetail1Row<'data> {
    pub fn participantid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.participantid.clone())
    }
    pub fn transaction_type(&self) -> &str {
        core::ops::Index::index(
            self.backing_data.as_slice(),
            self.transaction_type.clone(),
        )
    }
}
impl mmsdm_core::GetTable for BillingEftshortfallDetail1 {
    const VERSION: i32 = 1;
    const DATA_SET_NAME: &'static str = "BILLING";
    const TABLE_NAME: &'static str = "EFTSHORTFALL_DETAIL";
    const DEFAULT_FIELD_MAPPING: Self::FieldMapping = BillingEftshortfallDetail1Mapping([
        4,
        5,
        6,
        7,
        8,
        9,
    ]);
    const COLUMNS: &'static [&'static str] = &[
        "CONTRACTYEAR",
        "WEEKNO",
        "BILLRUNNO",
        "PARTICIPANTID",
        "TRANSACTION_TYPE",
        "AMOUNT",
    ];
    type Row<'row> = BillingEftshortfallDetail1Row<'row>;
    type FieldMapping = BillingEftshortfallDetail1Mapping;
    type PrimaryKey = BillingEftshortfallDetail1PrimaryKey;
    fn from_row<'data>(
        row: mmsdm_core::CsvRow<'data>,
        field_mapping: &Self::FieldMapping,
    ) -> mmsdm_core::Result<Self::Row<'data>> {
        Ok(BillingEftshortfallDetail1Row {
            contractyear: row
                .get_custom_parsed_at_idx(
                    "contractyear",
                    field_mapping.0[0],
                    mmsdm_core::mms_decimal::parse,
                )?,
            weekno: row
                .get_custom_parsed_at_idx(
                    "weekno",
                    field_mapping.0[1],
                    mmsdm_core::mms_decimal::parse,
                )?,
            billrunno: row
                .get_custom_parsed_at_idx(
                    "billrunno",
                    field_mapping.0[2],
                    mmsdm_core::mms_decimal::parse,
                )?,
            participantid: row.get_range("participantid", field_mapping.0[3])?,
            transaction_type: row.get_range("transaction_type", field_mapping.0[4])?,
            amount: row
                .get_opt_custom_parsed_at_idx(
                    "amount",
                    field_mapping.0[5],
                    mmsdm_core::mms_decimal::parse,
                )?,
            backing_data: row,
        })
    }
    fn field_mapping_from_row<'a>(
        mut row: mmsdm_core::CsvRow<'a>,
    ) -> mmsdm_core::Result<Self::FieldMapping> {
        if !row.is_heading() {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!("Expected an I row but got {row:?}"),
                ),
            );
        }
        let row_key = mmsdm_core::FileKey::from_row(row.borrow())?;
        if !Self::matches_file_key(&row_key, row_key.version) {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!(
                        "Expected a row matching {}.{}.v{} but got {row_key}",
                        Self::DATA_SET_NAME, Self::TABLE_NAME, Self::VERSION
                    ),
                ),
            );
        }
        let mut base_mapping = Self::DEFAULT_FIELD_MAPPING.0;
        for (field_index, field) in Self::COLUMNS.iter().enumerate() {
            base_mapping[field_index] = row
                .iter_fields()
                .position(|f| f == *field)
                .unwrap_or(usize::MAX);
        }
        Ok(BillingEftshortfallDetail1Mapping(base_mapping))
    }
    fn matches_file_key(key: &mmsdm_core::FileKey<'_>, version: i32) -> bool {
        version == key.version && Self::DATA_SET_NAME == key.data_set_name()
            && Self::TABLE_NAME == key.table_name()
    }
    fn primary_key(row: &Self::Row<'_>) -> BillingEftshortfallDetail1PrimaryKey {
        BillingEftshortfallDetail1PrimaryKey {
            billrunno: row.billrunno,
            contractyear: row.contractyear,
            participantid: row.participantid().to_string(),
            transaction_type: row.transaction_type().to_string(),
            weekno: row.weekno,
        }
    }
    fn partition_value(&self, row: &Self::Row<'_>) -> mmsdm_core::PartitionValue {
        (self.extract_row_partition)(row)
    }
    fn partition_name(&self, row: &Self::Row<'_>) -> alloc::string::String {
        alloc::format!("billing_eftshortfall_detail_v1_{}", self.partition_value(row))
    }
    fn partition_key(&self) -> mmsdm_core::PartitionKey {
        self.row_partition_key
    }
    fn to_static<'a>(row: &Self::Row<'a>) -> Self::Row<'static> {
        BillingEftshortfallDetail1Row {
            contractyear: row.contractyear.clone(),
            weekno: row.weekno.clone(),
            billrunno: row.billrunno.clone(),
            participantid: row.participantid.clone(),
            transaction_type: row.transaction_type.clone(),
            amount: row.amount.clone(),
            backing_data: row.backing_data.to_owned(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct BillingEftshortfallDetail1PrimaryKey {
    pub billrunno: rust_decimal::Decimal,
    pub contractyear: rust_decimal::Decimal,
    pub participantid: alloc::string::String,
    pub transaction_type: alloc::string::String,
    pub weekno: rust_decimal::Decimal,
}
impl mmsdm_core::PrimaryKey for BillingEftshortfallDetail1PrimaryKey {}
impl<'data> mmsdm_core::CompareWithRow for BillingEftshortfallDetail1Row<'data> {
    type Row<'other> = BillingEftshortfallDetail1Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.participantid() == row.participantid()
            && self.transaction_type() == row.transaction_type()
            && self.weekno == row.weekno
    }
}
impl<'data> mmsdm_core::CompareWithPrimaryKey for BillingEftshortfallDetail1Row<'data> {
    type PrimaryKey = BillingEftshortfallDetail1PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.participantid() == key.participantid
            && self.transaction_type() == key.transaction_type
            && self.weekno == key.weekno
    }
}
impl<'data> mmsdm_core::CompareWithRow for BillingEftshortfallDetail1PrimaryKey {
    type Row<'other> = BillingEftshortfallDetail1Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.participantid == row.participantid()
            && self.transaction_type == row.transaction_type()
            && self.weekno == row.weekno
    }
}
impl mmsdm_core::CompareWithPrimaryKey for BillingEftshortfallDetail1PrimaryKey {
    type PrimaryKey = BillingEftshortfallDetail1PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.participantid == key.participantid
            && self.transaction_type == key.transaction_type && self.weekno == key.weekno
    }
}
#[cfg(feature = "arrow")]
impl mmsdm_core::ArrowSchema for BillingEftshortfallDetail1 {
    type Builder = BillingEftshortfallDetail1Builder;
    fn schema() -> arrow::datatypes::Schema {
        arrow::datatypes::Schema::new(
            alloc::vec::Vec::from([
                arrow::datatypes::Field::new(
                    "contractyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "weekno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "billrunno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "participantid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "transaction_type",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "amount",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
            ]),
        )
    }
    fn new_builder() -> Self::Builder {
        BillingEftshortfallDetail1Builder {
            contractyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            weekno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            billrunno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            participantid_array: arrow::array::builder::StringBuilder::new(),
            transaction_type_array: arrow::array::builder::StringBuilder::new(),
            amount_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
        }
    }
    fn append_builder(builder: &mut Self::Builder, row: Self::Row<'_>) {
        builder
            .contractyear_array
            .append_value({
                let mut val = row.contractyear;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .weekno_array
            .append_value({
                let mut val = row.weekno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .billrunno_array
            .append_value({
                let mut val = row.billrunno;
                val.rescale(0);
                val.mantissa()
            });
        builder.participantid_array.append_value(row.participantid());
        builder.transaction_type_array.append_value(row.transaction_type());
        builder
            .amount_array
            .append_option({
                row.amount
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
    }
    fn finalize_builder(
        builder: &mut Self::Builder,
    ) -> mmsdm_core::Result<arrow::array::RecordBatch> {
        arrow::array::RecordBatch::try_new(
                alloc::sync::Arc::new(<Self as mmsdm_core::ArrowSchema>::schema()),
                alloc::vec::Vec::from([
                    alloc::sync::Arc::new(builder.contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.participantid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.transaction_type_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.amount_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                ]),
            )
            .map_err(Into::into)
    }
}
#[cfg(feature = "arrow")]
pub struct BillingEftshortfallDetail1Builder {
    contractyear_array: arrow::array::builder::Decimal128Builder,
    weekno_array: arrow::array::builder::Decimal128Builder,
    billrunno_array: arrow::array::builder::Decimal128Builder,
    participantid_array: arrow::array::builder::StringBuilder,
    transaction_type_array: arrow::array::builder::StringBuilder,
    amount_array: arrow::array::builder::Decimal128Builder,
}
pub struct BillingEnergyGensetDetail1 {
    extract_row_partition: alloc::boxed::Box<
        dyn Fn(
            &BillingEnergyGensetDetail1Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    >,
    row_partition_key: mmsdm_core::PartitionKey,
}
impl BillingEnergyGensetDetail1 {
    pub fn new(
        row_partition_key: mmsdm_core::PartitionKey,
        func: impl Fn(
            &<Self as mmsdm_core::GetTable>::Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    ) -> Self {
        Self {
            extract_row_partition: alloc::boxed::Box::new(func),
            row_partition_key,
        }
    }
}
pub struct BillingEnergyGensetDetail1Mapping([usize; 20]);
/// # Summary
///
/// ## BILLING_ENERGY_GENSET_DETAIL
///  _The Billing Energy Genset report contains the Genset Energy detail summary for the Billing Week data_
///
/// * Data Set Name: Billing
/// * File Name: Energy Genset Detail
/// * Data Version: 1
///
///
///
///
///
/// # Primary Key Columns
///
/// * BILLRUNNO
/// * CONNECTIONPOINTID
/// * CONTRACTYEAR
/// * DUID
/// * GENSETID
/// * METERID
/// * PARTICIPANTID
/// * REGIONID
/// * STATIONID
/// * WEEKNO
#[derive(Debug, PartialEq, Eq)]
pub struct BillingEnergyGensetDetail1Row<'data> {
    /// The Billing Contract Year
    pub contractyear: rust_decimal::Decimal,
    /// The Billing Week No
    pub weekno: rust_decimal::Decimal,
    /// The Billing Run No
    pub billrunno: rust_decimal::Decimal,
    /// The Participant Id Identifier
    pub participantid: core::ops::Range<usize>,
    /// The StationId identifier associated with the GensetId
    pub stationid: core::ops::Range<usize>,
    /// The DUID for the meter associated with the GensetId
    pub duid: core::ops::Range<usize>,
    /// The GensetId for the Meter Id received
    pub gensetid: core::ops::Range<usize>,
    /// The Region Id for the Connection Point associated with the DUID
    pub regionid: core::ops::Range<usize>,
    /// The Connection Point associated with the DUID
    pub connectionpointid: core::ops::Range<usize>,
    /// The Meter ID Identifier (NMI)
    pub meterid: core::ops::Range<usize>,
    /// The Consumed Energy for the Meter Id . Energy received in the meter reads (DLF Adjusted) in that Billing Week
    pub ce_mwh: Option<rust_decimal::Decimal>,
    /// The UFEA Energy MWh Consumed for that Connection Point for the Participant Id in that Billing Week
    pub ufea_mwh: Option<rust_decimal::Decimal>,
    /// The Adjusted Consumed Energy MWh Consumed for that Connection Point for the Participant Id in that Billing Week
    pub ace_mwh: Option<rust_decimal::Decimal>,
    /// The Adjusted Sent Out Energy MWh Consumed for that Connection Point for the Participant Id in that Billing Week
    pub asoe_mwh: Option<rust_decimal::Decimal>,
    /// The Total MWh(ACE_MWh + ASOE_MWh) for that Connection Point for the Participant Id in that Billing Week
    pub total_mwh: Option<rust_decimal::Decimal>,
    /// The DME MWh for that Connection Point for the Participant Id in that Billing Week. This is the MWh value that is used for the UFEA Allocation
    pub dme_mwh: Option<rust_decimal::Decimal>,
    /// The Adjusted Consumed Energy Dollar Amount for that Connection Point for the Participant Id in that Billing Week
    pub ace_amount: Option<rust_decimal::Decimal>,
    /// The Adjusted Sent Out Energy Dollar Amount for that Connection Point for the Participant Id in that Billing Week
    pub asoe_amount: Option<rust_decimal::Decimal>,
    /// The Total Amount(ACE_Amount + ASOE_Amount) for that Connection Point for the Participant Id in that Billing Week
    pub total_amount: Option<rust_decimal::Decimal>,
    /// The Last changed date time for the record
    pub lastchanged: Option<chrono::NaiveDateTime>,
    backing_data: mmsdm_core::CsvRow<'data>,
}
impl<'data> BillingEnergyGensetDetail1Row<'data> {
    pub fn participantid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.participantid.clone())
    }
    pub fn stationid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.stationid.clone())
    }
    pub fn duid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.duid.clone())
    }
    pub fn gensetid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.gensetid.clone())
    }
    pub fn regionid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.regionid.clone())
    }
    pub fn connectionpointid(&self) -> &str {
        core::ops::Index::index(
            self.backing_data.as_slice(),
            self.connectionpointid.clone(),
        )
    }
    pub fn meterid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.meterid.clone())
    }
}
impl mmsdm_core::GetTable for BillingEnergyGensetDetail1 {
    const VERSION: i32 = 1;
    const DATA_SET_NAME: &'static str = "BILLING";
    const TABLE_NAME: &'static str = "ENERGY_GENSET_DETAIL";
    const DEFAULT_FIELD_MAPPING: Self::FieldMapping = BillingEnergyGensetDetail1Mapping([
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
    ]);
    const COLUMNS: &'static [&'static str] = &[
        "CONTRACTYEAR",
        "WEEKNO",
        "BILLRUNNO",
        "PARTICIPANTID",
        "STATIONID",
        "DUID",
        "GENSETID",
        "REGIONID",
        "CONNECTIONPOINTID",
        "METERID",
        "CE_MWH",
        "UFEA_MWH",
        "ACE_MWH",
        "ASOE_MWH",
        "TOTAL_MWH",
        "DME_MWH",
        "ACE_AMOUNT",
        "ASOE_AMOUNT",
        "TOTAL_AMOUNT",
        "LASTCHANGED",
    ];
    type Row<'row> = BillingEnergyGensetDetail1Row<'row>;
    type FieldMapping = BillingEnergyGensetDetail1Mapping;
    type PrimaryKey = BillingEnergyGensetDetail1PrimaryKey;
    fn from_row<'data>(
        row: mmsdm_core::CsvRow<'data>,
        field_mapping: &Self::FieldMapping,
    ) -> mmsdm_core::Result<Self::Row<'data>> {
        Ok(BillingEnergyGensetDetail1Row {
            contractyear: row
                .get_custom_parsed_at_idx(
                    "contractyear",
                    field_mapping.0[0],
                    mmsdm_core::mms_decimal::parse,
                )?,
            weekno: row
                .get_custom_parsed_at_idx(
                    "weekno",
                    field_mapping.0[1],
                    mmsdm_core::mms_decimal::parse,
                )?,
            billrunno: row
                .get_custom_parsed_at_idx(
                    "billrunno",
                    field_mapping.0[2],
                    mmsdm_core::mms_decimal::parse,
                )?,
            participantid: row.get_range("participantid", field_mapping.0[3])?,
            stationid: row.get_range("stationid", field_mapping.0[4])?,
            duid: row.get_range("duid", field_mapping.0[5])?,
            gensetid: row.get_range("gensetid", field_mapping.0[6])?,
            regionid: row.get_range("regionid", field_mapping.0[7])?,
            connectionpointid: row.get_range("connectionpointid", field_mapping.0[8])?,
            meterid: row.get_range("meterid", field_mapping.0[9])?,
            ce_mwh: row
                .get_opt_custom_parsed_at_idx(
                    "ce_mwh",
                    field_mapping.0[10],
                    mmsdm_core::mms_decimal::parse,
                )?,
            ufea_mwh: row
                .get_opt_custom_parsed_at_idx(
                    "ufea_mwh",
                    field_mapping.0[11],
                    mmsdm_core::mms_decimal::parse,
                )?,
            ace_mwh: row
                .get_opt_custom_parsed_at_idx(
                    "ace_mwh",
                    field_mapping.0[12],
                    mmsdm_core::mms_decimal::parse,
                )?,
            asoe_mwh: row
                .get_opt_custom_parsed_at_idx(
                    "asoe_mwh",
                    field_mapping.0[13],
                    mmsdm_core::mms_decimal::parse,
                )?,
            total_mwh: row
                .get_opt_custom_parsed_at_idx(
                    "total_mwh",
                    field_mapping.0[14],
                    mmsdm_core::mms_decimal::parse,
                )?,
            dme_mwh: row
                .get_opt_custom_parsed_at_idx(
                    "dme_mwh",
                    field_mapping.0[15],
                    mmsdm_core::mms_decimal::parse,
                )?,
            ace_amount: row
                .get_opt_custom_parsed_at_idx(
                    "ace_amount",
                    field_mapping.0[16],
                    mmsdm_core::mms_decimal::parse,
                )?,
            asoe_amount: row
                .get_opt_custom_parsed_at_idx(
                    "asoe_amount",
                    field_mapping.0[17],
                    mmsdm_core::mms_decimal::parse,
                )?,
            total_amount: row
                .get_opt_custom_parsed_at_idx(
                    "total_amount",
                    field_mapping.0[18],
                    mmsdm_core::mms_decimal::parse,
                )?,
            lastchanged: row
                .get_opt_custom_parsed_at_idx(
                    "lastchanged",
                    field_mapping.0[19],
                    mmsdm_core::mms_datetime::parse,
                )?,
            backing_data: row,
        })
    }
    fn field_mapping_from_row<'a>(
        mut row: mmsdm_core::CsvRow<'a>,
    ) -> mmsdm_core::Result<Self::FieldMapping> {
        if !row.is_heading() {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!("Expected an I row but got {row:?}"),
                ),
            );
        }
        let row_key = mmsdm_core::FileKey::from_row(row.borrow())?;
        if !Self::matches_file_key(&row_key, row_key.version) {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!(
                        "Expected a row matching {}.{}.v{} but got {row_key}",
                        Self::DATA_SET_NAME, Self::TABLE_NAME, Self::VERSION
                    ),
                ),
            );
        }
        let mut base_mapping = Self::DEFAULT_FIELD_MAPPING.0;
        for (field_index, field) in Self::COLUMNS.iter().enumerate() {
            base_mapping[field_index] = row
                .iter_fields()
                .position(|f| f == *field)
                .unwrap_or(usize::MAX);
        }
        Ok(BillingEnergyGensetDetail1Mapping(base_mapping))
    }
    fn matches_file_key(key: &mmsdm_core::FileKey<'_>, version: i32) -> bool {
        version == key.version && Self::DATA_SET_NAME == key.data_set_name()
            && Self::TABLE_NAME == key.table_name()
    }
    fn primary_key(row: &Self::Row<'_>) -> BillingEnergyGensetDetail1PrimaryKey {
        BillingEnergyGensetDetail1PrimaryKey {
            billrunno: row.billrunno,
            connectionpointid: row.connectionpointid().to_string(),
            contractyear: row.contractyear,
            duid: row.duid().to_string(),
            gensetid: row.gensetid().to_string(),
            meterid: row.meterid().to_string(),
            participantid: row.participantid().to_string(),
            regionid: row.regionid().to_string(),
            stationid: row.stationid().to_string(),
            weekno: row.weekno,
        }
    }
    fn partition_value(&self, row: &Self::Row<'_>) -> mmsdm_core::PartitionValue {
        (self.extract_row_partition)(row)
    }
    fn partition_name(&self, row: &Self::Row<'_>) -> alloc::string::String {
        alloc::format!("billing_energy_genset_detail_v1_{}", self.partition_value(row))
    }
    fn partition_key(&self) -> mmsdm_core::PartitionKey {
        self.row_partition_key
    }
    fn to_static<'a>(row: &Self::Row<'a>) -> Self::Row<'static> {
        BillingEnergyGensetDetail1Row {
            contractyear: row.contractyear.clone(),
            weekno: row.weekno.clone(),
            billrunno: row.billrunno.clone(),
            participantid: row.participantid.clone(),
            stationid: row.stationid.clone(),
            duid: row.duid.clone(),
            gensetid: row.gensetid.clone(),
            regionid: row.regionid.clone(),
            connectionpointid: row.connectionpointid.clone(),
            meterid: row.meterid.clone(),
            ce_mwh: row.ce_mwh.clone(),
            ufea_mwh: row.ufea_mwh.clone(),
            ace_mwh: row.ace_mwh.clone(),
            asoe_mwh: row.asoe_mwh.clone(),
            total_mwh: row.total_mwh.clone(),
            dme_mwh: row.dme_mwh.clone(),
            ace_amount: row.ace_amount.clone(),
            asoe_amount: row.asoe_amount.clone(),
            total_amount: row.total_amount.clone(),
            lastchanged: row.lastchanged.clone(),
            backing_data: row.backing_data.to_owned(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct BillingEnergyGensetDetail1PrimaryKey {
    pub billrunno: rust_decimal::Decimal,
    pub connectionpointid: alloc::string::String,
    pub contractyear: rust_decimal::Decimal,
    pub duid: alloc::string::String,
    pub gensetid: alloc::string::String,
    pub meterid: alloc::string::String,
    pub participantid: alloc::string::String,
    pub regionid: alloc::string::String,
    pub stationid: alloc::string::String,
    pub weekno: rust_decimal::Decimal,
}
impl mmsdm_core::PrimaryKey for BillingEnergyGensetDetail1PrimaryKey {}
impl<'data> mmsdm_core::CompareWithRow for BillingEnergyGensetDetail1Row<'data> {
    type Row<'other> = BillingEnergyGensetDetail1Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno
            && self.connectionpointid() == row.connectionpointid()
            && self.contractyear == row.contractyear && self.duid() == row.duid()
            && self.gensetid() == row.gensetid() && self.meterid() == row.meterid()
            && self.participantid() == row.participantid()
            && self.regionid() == row.regionid() && self.stationid() == row.stationid()
            && self.weekno == row.weekno
    }
}
impl<'data> mmsdm_core::CompareWithPrimaryKey for BillingEnergyGensetDetail1Row<'data> {
    type PrimaryKey = BillingEnergyGensetDetail1PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno
            && self.connectionpointid() == key.connectionpointid
            && self.contractyear == key.contractyear && self.duid() == key.duid
            && self.gensetid() == key.gensetid && self.meterid() == key.meterid
            && self.participantid() == key.participantid
            && self.regionid() == key.regionid && self.stationid() == key.stationid
            && self.weekno == key.weekno
    }
}
impl<'data> mmsdm_core::CompareWithRow for BillingEnergyGensetDetail1PrimaryKey {
    type Row<'other> = BillingEnergyGensetDetail1Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno
            && self.connectionpointid == row.connectionpointid()
            && self.contractyear == row.contractyear && self.duid == row.duid()
            && self.gensetid == row.gensetid() && self.meterid == row.meterid()
            && self.participantid == row.participantid()
            && self.regionid == row.regionid() && self.stationid == row.stationid()
            && self.weekno == row.weekno
    }
}
impl mmsdm_core::CompareWithPrimaryKey for BillingEnergyGensetDetail1PrimaryKey {
    type PrimaryKey = BillingEnergyGensetDetail1PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno
            && self.connectionpointid == key.connectionpointid
            && self.contractyear == key.contractyear && self.duid == key.duid
            && self.gensetid == key.gensetid && self.meterid == key.meterid
            && self.participantid == key.participantid && self.regionid == key.regionid
            && self.stationid == key.stationid && self.weekno == key.weekno
    }
}
#[cfg(feature = "arrow")]
impl mmsdm_core::ArrowSchema for BillingEnergyGensetDetail1 {
    type Builder = BillingEnergyGensetDetail1Builder;
    fn schema() -> arrow::datatypes::Schema {
        arrow::datatypes::Schema::new(
            alloc::vec::Vec::from([
                arrow::datatypes::Field::new(
                    "contractyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "weekno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "billrunno",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "participantid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "stationid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "duid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "gensetid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "regionid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "connectionpointid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "meterid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "ce_mwh",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "ufea_mwh",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "ace_mwh",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "asoe_mwh",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "total_mwh",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "dme_mwh",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "ace_amount",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "asoe_amount",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "total_amount",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lastchanged",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    true,
                ),
            ]),
        )
    }
    fn new_builder() -> Self::Builder {
        BillingEnergyGensetDetail1Builder {
            contractyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            weekno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            billrunno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            participantid_array: arrow::array::builder::StringBuilder::new(),
            stationid_array: arrow::array::builder::StringBuilder::new(),
            duid_array: arrow::array::builder::StringBuilder::new(),
            gensetid_array: arrow::array::builder::StringBuilder::new(),
            regionid_array: arrow::array::builder::StringBuilder::new(),
            connectionpointid_array: arrow::array::builder::StringBuilder::new(),
            meterid_array: arrow::array::builder::StringBuilder::new(),
            ce_mwh_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            ufea_mwh_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            ace_mwh_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            asoe_mwh_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            total_mwh_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            dme_mwh_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            ace_amount_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            asoe_amount_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            total_amount_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
        }
    }
    fn append_builder(builder: &mut Self::Builder, row: Self::Row<'_>) {
        builder
            .contractyear_array
            .append_value({
                let mut val = row.contractyear;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .weekno_array
            .append_value({
                let mut val = row.weekno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .billrunno_array
            .append_value({
                let mut val = row.billrunno;
                val.rescale(0);
                val.mantissa()
            });
        builder.participantid_array.append_value(row.participantid());
        builder.stationid_array.append_value(row.stationid());
        builder.duid_array.append_value(row.duid());
        builder.gensetid_array.append_value(row.gensetid());
        builder.regionid_array.append_value(row.regionid());
        builder.connectionpointid_array.append_value(row.connectionpointid());
        builder.meterid_array.append_value(row.meterid());
        builder
            .ce_mwh_array
            .append_option({
                row.ce_mwh
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .ufea_mwh_array
            .append_option({
                row.ufea_mwh
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .ace_mwh_array
            .append_option({
                row.ace_mwh
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .asoe_mwh_array
            .append_option({
                row.asoe_mwh
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .total_mwh_array
            .append_option({
                row.total_mwh
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .dme_mwh_array
            .append_option({
                row.dme_mwh
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .ace_amount_array
            .append_option({
                row.ace_amount
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .asoe_amount_array
            .append_option({
                row.asoe_amount
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .total_amount_array
            .append_option({
                row.total_amount
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .lastchanged_array
            .append_option(row.lastchanged.map(|val| val.and_utc().timestamp_millis()));
    }
    fn finalize_builder(
        builder: &mut Self::Builder,
    ) -> mmsdm_core::Result<arrow::array::RecordBatch> {
        arrow::array::RecordBatch::try_new(
                alloc::sync::Arc::new(<Self as mmsdm_core::ArrowSchema>::schema()),
                alloc::vec::Vec::from([
                    alloc::sync::Arc::new(builder.contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.participantid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.stationid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.duid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.gensetid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.regionid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.connectionpointid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.meterid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.ce_mwh_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.ufea_mwh_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.ace_mwh_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.asoe_mwh_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.total_mwh_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.dme_mwh_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.ace_amount_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.asoe_amount_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.total_amount_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lastchanged_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                ]),
            )
            .map_err(Into::into)
    }
}
#[cfg(feature = "arrow")]
pub struct BillingEnergyGensetDetail1Builder {
    contractyear_array: arrow::array::builder::Decimal128Builder,
    weekno_array: arrow::array::builder::Decimal128Builder,
    billrunno_array: arrow::array::builder::Decimal128Builder,
    participantid_array: arrow::array::builder::StringBuilder,
    stationid_array: arrow::array::builder::StringBuilder,
    duid_array: arrow::array::builder::StringBuilder,
    gensetid_array: arrow::array::builder::StringBuilder,
    regionid_array: arrow::array::builder::StringBuilder,
    connectionpointid_array: arrow::array::builder::StringBuilder,
    meterid_array: arrow::array::builder::StringBuilder,
    ce_mwh_array: arrow::array::builder::Decimal128Builder,
    ufea_mwh_array: arrow::array::builder::Decimal128Builder,
    ace_mwh_array: arrow::array::builder::Decimal128Builder,
    asoe_mwh_array: arrow::array::builder::Decimal128Builder,
    total_mwh_array: arrow::array::builder::Decimal128Builder,
    dme_mwh_array: arrow::array::builder::Decimal128Builder,
    ace_amount_array: arrow::array::builder::Decimal128Builder,
    asoe_amount_array: arrow::array::builder::Decimal128Builder,
    total_amount_array: arrow::array::builder::Decimal128Builder,
    lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder,
}
pub struct BillingEnergyTransaction1 {
    extract_row_partition: alloc::boxed::Box<
        dyn Fn(
            &BillingEnergyTransaction1Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    >,
    row_partition_key: mmsdm_core::PartitionKey,
}
impl BillingEnergyTransaction1 {
    pub fn new(
        row_partition_key: mmsdm_core::PartitionKey,
        func: impl Fn(
            &<Self as mmsdm_core::GetTable>::Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    ) -> Self {
        Self {
            extract_row_partition: alloc::boxed::Box::new(func),
            row_partition_key,
        }
    }
}
pub struct BillingEnergyTransaction1Mapping([usize; 16]);
/// # Summary
///
/// ## BILLING_ENERGY_TRANSACTIONS
///  _The Billing Energy Transactions is the summary of the Settlement Energy Transactions that has the ACE and ASOE MWh and Dollar values that is used for the Statement_
///
/// * Data Set Name: Billing
/// * File Name: Energy Transaction
/// * Data Version: 1
///
///
///
///
///
/// # Primary Key Columns
///
/// * BILLRUNNO
/// * CONNECTIONPOINTID
/// * CONTRACTYEAR
/// * PARTICIPANTID
/// * REGIONID
/// * WEEKNO
#[derive(Debug, PartialEq, Eq)]
pub struct BillingEnergyTransaction1Row<'data> {
    /// The Billing Contract Year
    pub contractyear: rust_decimal::Decimal,
    /// The Billing WeekNo
    pub weekno: rust_decimal::Decimal,
    /// The Billing RunNo
    pub billrunno: rust_decimal::Decimal,
    /// The Participant Id Identifier
    pub participantid: core::ops::Range<usize>,
    /// The ConnectionPoint Id for the Billing Aggregation for the Participant Id.
    pub connectionpointid: core::ops::Range<usize>,
    /// The Region Id Identifier
    pub regionid: core::ops::Range<usize>,
    /// The Consumed Energy MWh Consumed for that Connection Point for the Participant Id in that Billing Week
    pub ce_mwh: Option<rust_decimal::Decimal>,
    /// The UFEA Energy MWh Consumed for that Connection Point for the Participant Id in that Billing Week
    pub ufea_mwh: Option<rust_decimal::Decimal>,
    /// The Adjusted Consumed Energy MWh Consumed for that Connection Point for the Participant Id in that Billing Week
    pub ace_mwh: Option<rust_decimal::Decimal>,
    /// The Adjusted Sent Out Energy MWh Consumed for that Connection Point for the Participant Id in that Billing Week
    pub asoe_mwh: Option<rust_decimal::Decimal>,
    /// The Adjusted Consumed Energy Dollar Amount for that Connection Point for the Participant Id in that Billing Week
    pub ace_amount: Option<rust_decimal::Decimal>,
    /// The Adjusted Sent Out Energy Dollar Amount for that Connection Point for the Participant Id in that Billing Week
    pub asoe_amount: Option<rust_decimal::Decimal>,
    /// The Total MWh(ACE_MWh + ASOE_MWh) for that Connection Point for the Participant Id in that Billing Week
    pub total_mwh: Option<rust_decimal::Decimal>,
    /// The Total Amount(ACE_Amount + ASOE_Amount) for that Connection Point for the Participant Id in that Billing Week
    pub total_amount: Option<rust_decimal::Decimal>,
    /// The DME MWh for that Connection Point for the Participant Id in that Billing Week. This is the MWh value that is used for the UFEA Allocation.
    pub dme_mwh: Option<rust_decimal::Decimal>,
    /// The Last Changed date time for the record
    pub lastchanged: Option<chrono::NaiveDateTime>,
    backing_data: mmsdm_core::CsvRow<'data>,
}
impl<'data> BillingEnergyTransaction1Row<'data> {
    pub fn participantid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.participantid.clone())
    }
    pub fn connectionpointid(&self) -> &str {
        core::ops::Index::index(
            self.backing_data.as_slice(),
            self.connectionpointid.clone(),
        )
    }
    pub fn regionid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.regionid.clone())
    }
}
impl mmsdm_core::GetTable for BillingEnergyTransaction1 {
    const VERSION: i32 = 1;
    const DATA_SET_NAME: &'static str = "BILLING";
    const TABLE_NAME: &'static str = "ENERGY_TRANSACTION";
    const DEFAULT_FIELD_MAPPING: Self::FieldMapping = BillingEnergyTransaction1Mapping([
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
    ]);
    const COLUMNS: &'static [&'static str] = &[
        "CONTRACTYEAR",
        "WEEKNO",
        "BILLRUNNO",
        "PARTICIPANTID",
        "CONNECTIONPOINTID",
        "REGIONID",
        "CE_MWH",
        "UFEA_MWH",
        "ACE_MWH",
        "ASOE_MWH",
        "ACE_AMOUNT",
        "ASOE_AMOUNT",
        "TOTAL_MWH",
        "TOTAL_AMOUNT",
        "DME_MWH",
        "LASTCHANGED",
    ];
    type Row<'row> = BillingEnergyTransaction1Row<'row>;
    type FieldMapping = BillingEnergyTransaction1Mapping;
    type PrimaryKey = BillingEnergyTransaction1PrimaryKey;
    fn from_row<'data>(
        row: mmsdm_core::CsvRow<'data>,
        field_mapping: &Self::FieldMapping,
    ) -> mmsdm_core::Result<Self::Row<'data>> {
        Ok(BillingEnergyTransaction1Row {
            contractyear: row
                .get_custom_parsed_at_idx(
                    "contractyear",
                    field_mapping.0[0],
                    mmsdm_core::mms_decimal::parse,
                )?,
            weekno: row
                .get_custom_parsed_at_idx(
                    "weekno",
                    field_mapping.0[1],
                    mmsdm_core::mms_decimal::parse,
                )?,
            billrunno: row
                .get_custom_parsed_at_idx(
                    "billrunno",
                    field_mapping.0[2],
                    mmsdm_core::mms_decimal::parse,
                )?,
            participantid: row.get_range("participantid", field_mapping.0[3])?,
            connectionpointid: row.get_range("connectionpointid", field_mapping.0[4])?,
            regionid: row.get_range("regionid", field_mapping.0[5])?,
            ce_mwh: row
                .get_opt_custom_parsed_at_idx(
                    "ce_mwh",
                    field_mapping.0[6],
                    mmsdm_core::mms_decimal::parse,
                )?,
            ufea_mwh: row
                .get_opt_custom_parsed_at_idx(
                    "ufea_mwh",
                    field_mapping.0[7],
                    mmsdm_core::mms_decimal::parse,
                )?,
            ace_mwh: row
                .get_opt_custom_parsed_at_idx(
                    "ace_mwh",
                    field_mapping.0[8],
                    mmsdm_core::mms_decimal::parse,
                )?,
            asoe_mwh: row
                .get_opt_custom_parsed_at_idx(
                    "asoe_mwh",
                    field_mapping.0[9],
                    mmsdm_core::mms_decimal::parse,
                )?,
            ace_amount: row
                .get_opt_custom_parsed_at_idx(
                    "ace_amount",
                    field_mapping.0[10],
                    mmsdm_core::mms_decimal::parse,
                )?,
            asoe_amount: row
                .get_opt_custom_parsed_at_idx(
                    "asoe_amount",
                    field_mapping.0[11],
                    mmsdm_core::mms_decimal::parse,
                )?,
            total_mwh: row
                .get_opt_custom_parsed_at_idx(
                    "total_mwh",
                    field_mapping.0[12],
                    mmsdm_core::mms_decimal::parse,
                )?,
            total_amount: row
                .get_opt_custom_parsed_at_idx(
                    "total_amount",
                    field_mapping.0[13],
                    mmsdm_core::mms_decimal::parse,
                )?,
            dme_mwh: row
                .get_opt_custom_parsed_at_idx(
                    "dme_mwh",
                    field_mapping.0[14],
                    mmsdm_core::mms_decimal::parse,
                )?,
            lastchanged: row
                .get_opt_custom_parsed_at_idx(
                    "lastchanged",
                    field_mapping.0[15],
                    mmsdm_core::mms_datetime::parse,
                )?,
            backing_data: row,
        })
    }
    fn field_mapping_from_row<'a>(
        mut row: mmsdm_core::CsvRow<'a>,
    ) -> mmsdm_core::Result<Self::FieldMapping> {
        if !row.is_heading() {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!("Expected an I row but got {row:?}"),
                ),
            );
        }
        let row_key = mmsdm_core::FileKey::from_row(row.borrow())?;
        if !Self::matches_file_key(&row_key, row_key.version) {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!(
                        "Expected a row matching {}.{}.v{} but got {row_key}",
                        Self::DATA_SET_NAME, Self::TABLE_NAME, Self::VERSION
                    ),
                ),
            );
        }
        let mut base_mapping = Self::DEFAULT_FIELD_MAPPING.0;
        for (field_index, field) in Self::COLUMNS.iter().enumerate() {
            base_mapping[field_index] = row
                .iter_fields()
                .position(|f| f == *field)
                .unwrap_or(usize::MAX);
        }
        Ok(BillingEnergyTransaction1Mapping(base_mapping))
    }
    fn matches_file_key(key: &mmsdm_core::FileKey<'_>, version: i32) -> bool {
        version == key.version && Self::DATA_SET_NAME == key.data_set_name()
            && Self::TABLE_NAME == key.table_name()
    }
    fn primary_key(row: &Self::Row<'_>) -> BillingEnergyTransaction1PrimaryKey {
        BillingEnergyTransaction1PrimaryKey {
            billrunno: row.billrunno,
            connectionpointid: row.connectionpointid().to_string(),
            contractyear: row.contractyear,
            participantid: row.participantid().to_string(),
            regionid: row.regionid().to_string(),
            weekno: row.weekno,
        }
    }
    fn partition_value(&self, row: &Self::Row<'_>) -> mmsdm_core::PartitionValue {
        (self.extract_row_partition)(row)
    }
    fn partition_name(&self, row: &Self::Row<'_>) -> alloc::string::String {
        alloc::format!("billing_energy_transaction_v1_{}", self.partition_value(row))
    }
    fn partition_key(&self) -> mmsdm_core::PartitionKey {
        self.row_partition_key
    }
    fn to_static<'a>(row: &Self::Row<'a>) -> Self::Row<'static> {
        BillingEnergyTransaction1Row {
            contractyear: row.contractyear.clone(),
            weekno: row.weekno.clone(),
            billrunno: row.billrunno.clone(),
            participantid: row.participantid.clone(),
            connectionpointid: row.connectionpointid.clone(),
            regionid: row.regionid.clone(),
            ce_mwh: row.ce_mwh.clone(),
            ufea_mwh: row.ufea_mwh.clone(),
            ace_mwh: row.ace_mwh.clone(),
            asoe_mwh: row.asoe_mwh.clone(),
            ace_amount: row.ace_amount.clone(),
            asoe_amount: row.asoe_amount.clone(),
            total_mwh: row.total_mwh.clone(),
            total_amount: row.total_amount.clone(),
            dme_mwh: row.dme_mwh.clone(),
            lastchanged: row.lastchanged.clone(),
            backing_data: row.backing_data.to_owned(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct BillingEnergyTransaction1PrimaryKey {
    pub billrunno: rust_decimal::Decimal,
    pub connectionpointid: alloc::string::String,
    pub contractyear: rust_decimal::Decimal,
    pub participantid: alloc::string::String,
    pub regionid: alloc::string::String,
    pub weekno: rust_decimal::Decimal,
}
impl mmsdm_core::PrimaryKey for BillingEnergyTransaction1PrimaryKey {}
impl<'data> mmsdm_core::CompareWithRow for BillingEnergyTransaction1Row<'data> {
    type Row<'other> = BillingEnergyTransaction1Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno
            && self.connectionpointid() == row.connectionpointid()
            && self.contractyear == row.contractyear
            && self.participantid() == row.participantid()
            && self.regionid() == row.regionid() && self.weekno == row.weekno
    }
}
impl<'data> mmsdm_core::CompareWithPrimaryKey for BillingEnergyTransaction1Row<'data> {
    type PrimaryKey = BillingEnergyTransaction1PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno
            && self.connectionpointid() == key.connectionpointid
            && self.contractyear == key.contractyear
            && self.participantid() == key.participantid
            && self.regionid() == key.regionid && self.weekno == key.weekno
    }
}
impl<'data> mmsdm_core::CompareWithRow for BillingEnergyTransaction1PrimaryKey {
    type Row<'other> = BillingEnergyTransaction1Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno
            && self.connectionpointid == row.connectionpointid()
            && self.contractyear == row.contractyear
            && self.participantid == row.participantid()
            && self.regionid == row.regionid() && self.weekno == row.weekno
    }
}
impl mmsdm_core::CompareWithPrimaryKey for BillingEnergyTransaction1PrimaryKey {
    type PrimaryKey = BillingEnergyTransaction1PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno
            && self.connectionpointid == key.connectionpointid
            && self.contractyear == key.contractyear
            && self.participantid == key.participantid && self.regionid == key.regionid
            && self.weekno == key.weekno
    }
}
#[cfg(feature = "arrow")]
impl mmsdm_core::ArrowSchema for BillingEnergyTransaction1 {
    type Builder = BillingEnergyTransaction1Builder;
    fn schema() -> arrow::datatypes::Schema {
        arrow::datatypes::Schema::new(
            alloc::vec::Vec::from([
                arrow::datatypes::Field::new(
                    "contractyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "weekno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "billrunno",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "participantid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "connectionpointid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "regionid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "ce_mwh",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "ufea_mwh",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "ace_mwh",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "asoe_mwh",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "ace_amount",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "asoe_amount",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "total_mwh",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "total_amount",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "dme_mwh",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lastchanged",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    true,
                ),
            ]),
        )
    }
    fn new_builder() -> Self::Builder {
        BillingEnergyTransaction1Builder {
            contractyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            weekno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            billrunno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            participantid_array: arrow::array::builder::StringBuilder::new(),
            connectionpointid_array: arrow::array::builder::StringBuilder::new(),
            regionid_array: arrow::array::builder::StringBuilder::new(),
            ce_mwh_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            ufea_mwh_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            ace_mwh_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            asoe_mwh_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            ace_amount_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            asoe_amount_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            total_mwh_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            total_amount_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            dme_mwh_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
        }
    }
    fn append_builder(builder: &mut Self::Builder, row: Self::Row<'_>) {
        builder
            .contractyear_array
            .append_value({
                let mut val = row.contractyear;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .weekno_array
            .append_value({
                let mut val = row.weekno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .billrunno_array
            .append_value({
                let mut val = row.billrunno;
                val.rescale(0);
                val.mantissa()
            });
        builder.participantid_array.append_value(row.participantid());
        builder.connectionpointid_array.append_value(row.connectionpointid());
        builder.regionid_array.append_value(row.regionid());
        builder
            .ce_mwh_array
            .append_option({
                row.ce_mwh
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .ufea_mwh_array
            .append_option({
                row.ufea_mwh
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .ace_mwh_array
            .append_option({
                row.ace_mwh
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .asoe_mwh_array
            .append_option({
                row.asoe_mwh
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .ace_amount_array
            .append_option({
                row.ace_amount
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .asoe_amount_array
            .append_option({
                row.asoe_amount
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .total_mwh_array
            .append_option({
                row.total_mwh
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .total_amount_array
            .append_option({
                row.total_amount
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .dme_mwh_array
            .append_option({
                row.dme_mwh
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .lastchanged_array
            .append_option(row.lastchanged.map(|val| val.and_utc().timestamp_millis()));
    }
    fn finalize_builder(
        builder: &mut Self::Builder,
    ) -> mmsdm_core::Result<arrow::array::RecordBatch> {
        arrow::array::RecordBatch::try_new(
                alloc::sync::Arc::new(<Self as mmsdm_core::ArrowSchema>::schema()),
                alloc::vec::Vec::from([
                    alloc::sync::Arc::new(builder.contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.participantid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.connectionpointid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.regionid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.ce_mwh_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.ufea_mwh_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.ace_mwh_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.asoe_mwh_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.ace_amount_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.asoe_amount_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.total_mwh_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.total_amount_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.dme_mwh_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lastchanged_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                ]),
            )
            .map_err(Into::into)
    }
}
#[cfg(feature = "arrow")]
pub struct BillingEnergyTransaction1Builder {
    contractyear_array: arrow::array::builder::Decimal128Builder,
    weekno_array: arrow::array::builder::Decimal128Builder,
    billrunno_array: arrow::array::builder::Decimal128Builder,
    participantid_array: arrow::array::builder::StringBuilder,
    connectionpointid_array: arrow::array::builder::StringBuilder,
    regionid_array: arrow::array::builder::StringBuilder,
    ce_mwh_array: arrow::array::builder::Decimal128Builder,
    ufea_mwh_array: arrow::array::builder::Decimal128Builder,
    ace_mwh_array: arrow::array::builder::Decimal128Builder,
    asoe_mwh_array: arrow::array::builder::Decimal128Builder,
    ace_amount_array: arrow::array::builder::Decimal128Builder,
    asoe_amount_array: arrow::array::builder::Decimal128Builder,
    total_mwh_array: arrow::array::builder::Decimal128Builder,
    total_amount_array: arrow::array::builder::Decimal128Builder,
    dme_mwh_array: arrow::array::builder::Decimal128Builder,
    lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder,
}
pub struct BillingEnergyTranSaps1 {
    extract_row_partition: alloc::boxed::Box<
        dyn Fn(
            &BillingEnergyTranSaps1Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    >,
    row_partition_key: mmsdm_core::PartitionKey,
}
impl BillingEnergyTranSaps1 {
    pub fn new(
        row_partition_key: mmsdm_core::PartitionKey,
        func: impl Fn(
            &<Self as mmsdm_core::GetTable>::Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    ) -> Self {
        Self {
            extract_row_partition: alloc::boxed::Box::new(func),
            row_partition_key,
        }
    }
}
pub struct BillingEnergyTranSaps1Mapping([usize; 11]);
/// # Summary
///
/// ## BILLING_ENERGY_TRAN_SAPS
///  _The SAP Billing Transaction Details for the Participants_
///
/// * Data Set Name: Billing
/// * File Name: Energy Tran Saps
/// * Data Version: 1
///
///
///
///
///
/// # Primary Key Columns
///
/// * BILLRUNNO
/// * CONTRACTYEAR
/// * PARTICIPANTID
/// * TNI
/// * WEEKNO
#[derive(Debug, PartialEq, Eq)]
pub struct BillingEnergyTranSaps1Row<'data> {
    /// The Billing Contract Year
    pub contractyear: rust_decimal::Decimal,
    /// The Billing WeekNo
    pub weekno: rust_decimal::Decimal,
    /// The Billing RunNo
    pub billrunno: rust_decimal::Decimal,
    /// The SAP Participant ID
    pub participantid: core::ops::Range<usize>,
    /// The SAPS Connection Point ID
    pub tni: core::ops::Range<usize>,
    /// The Region ID associated with the TNI
    pub regionid: core::ops::Range<usize>,
    /// The Energy MWh Consumed for that TNI for the Participant Id in that Billing Week
    pub consumed_energy_mwh: Option<rust_decimal::Decimal>,
    /// The Energy MWh Sent Out for the TNI for the Participant Id in that Billing Week
    pub sentout_energy_mwh: Option<rust_decimal::Decimal>,
    /// The Cost of the Consumed Energy
    pub consumed_energy_cost: Option<rust_decimal::Decimal>,
    /// The Cost of the Sent Out Energy
    pub sentout_energy_cost: Option<rust_decimal::Decimal>,
    /// The Last datetime record is updated
    pub lastchanged: Option<chrono::NaiveDateTime>,
    backing_data: mmsdm_core::CsvRow<'data>,
}
impl<'data> BillingEnergyTranSaps1Row<'data> {
    pub fn participantid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.participantid.clone())
    }
    pub fn tni(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.tni.clone())
    }
    pub fn regionid(&self) -> Option<&str> {
        if self.regionid.is_empty() {
            None
        } else {
            Some(
                core::ops::Index::index(
                    self.backing_data.as_slice(),
                    self.regionid.clone(),
                ),
            )
        }
    }
}
impl mmsdm_core::GetTable for BillingEnergyTranSaps1 {
    const VERSION: i32 = 1;
    const DATA_SET_NAME: &'static str = "BILLING";
    const TABLE_NAME: &'static str = "ENERGY_TRAN_SAPS";
    const DEFAULT_FIELD_MAPPING: Self::FieldMapping = BillingEnergyTranSaps1Mapping([
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
    ]);
    const COLUMNS: &'static [&'static str] = &[
        "CONTRACTYEAR",
        "WEEKNO",
        "BILLRUNNO",
        "PARTICIPANTID",
        "TNI",
        "REGIONID",
        "CONSUMED_ENERGY_MWH",
        "SENTOUT_ENERGY_MWH",
        "CONSUMED_ENERGY_COST",
        "SENTOUT_ENERGY_COST",
        "LASTCHANGED",
    ];
    type Row<'row> = BillingEnergyTranSaps1Row<'row>;
    type FieldMapping = BillingEnergyTranSaps1Mapping;
    type PrimaryKey = BillingEnergyTranSaps1PrimaryKey;
    fn from_row<'data>(
        row: mmsdm_core::CsvRow<'data>,
        field_mapping: &Self::FieldMapping,
    ) -> mmsdm_core::Result<Self::Row<'data>> {
        Ok(BillingEnergyTranSaps1Row {
            contractyear: row
                .get_custom_parsed_at_idx(
                    "contractyear",
                    field_mapping.0[0],
                    mmsdm_core::mms_decimal::parse,
                )?,
            weekno: row
                .get_custom_parsed_at_idx(
                    "weekno",
                    field_mapping.0[1],
                    mmsdm_core::mms_decimal::parse,
                )?,
            billrunno: row
                .get_custom_parsed_at_idx(
                    "billrunno",
                    field_mapping.0[2],
                    mmsdm_core::mms_decimal::parse,
                )?,
            participantid: row.get_range("participantid", field_mapping.0[3])?,
            tni: row.get_range("tni", field_mapping.0[4])?,
            regionid: row.get_opt_range("regionid", field_mapping.0[5])?,
            consumed_energy_mwh: row
                .get_opt_custom_parsed_at_idx(
                    "consumed_energy_mwh",
                    field_mapping.0[6],
                    mmsdm_core::mms_decimal::parse,
                )?,
            sentout_energy_mwh: row
                .get_opt_custom_parsed_at_idx(
                    "sentout_energy_mwh",
                    field_mapping.0[7],
                    mmsdm_core::mms_decimal::parse,
                )?,
            consumed_energy_cost: row
                .get_opt_custom_parsed_at_idx(
                    "consumed_energy_cost",
                    field_mapping.0[8],
                    mmsdm_core::mms_decimal::parse,
                )?,
            sentout_energy_cost: row
                .get_opt_custom_parsed_at_idx(
                    "sentout_energy_cost",
                    field_mapping.0[9],
                    mmsdm_core::mms_decimal::parse,
                )?,
            lastchanged: row
                .get_opt_custom_parsed_at_idx(
                    "lastchanged",
                    field_mapping.0[10],
                    mmsdm_core::mms_datetime::parse,
                )?,
            backing_data: row,
        })
    }
    fn field_mapping_from_row<'a>(
        mut row: mmsdm_core::CsvRow<'a>,
    ) -> mmsdm_core::Result<Self::FieldMapping> {
        if !row.is_heading() {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!("Expected an I row but got {row:?}"),
                ),
            );
        }
        let row_key = mmsdm_core::FileKey::from_row(row.borrow())?;
        if !Self::matches_file_key(&row_key, row_key.version) {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!(
                        "Expected a row matching {}.{}.v{} but got {row_key}",
                        Self::DATA_SET_NAME, Self::TABLE_NAME, Self::VERSION
                    ),
                ),
            );
        }
        let mut base_mapping = Self::DEFAULT_FIELD_MAPPING.0;
        for (field_index, field) in Self::COLUMNS.iter().enumerate() {
            base_mapping[field_index] = row
                .iter_fields()
                .position(|f| f == *field)
                .unwrap_or(usize::MAX);
        }
        Ok(BillingEnergyTranSaps1Mapping(base_mapping))
    }
    fn matches_file_key(key: &mmsdm_core::FileKey<'_>, version: i32) -> bool {
        version == key.version && Self::DATA_SET_NAME == key.data_set_name()
            && Self::TABLE_NAME == key.table_name()
    }
    fn primary_key(row: &Self::Row<'_>) -> BillingEnergyTranSaps1PrimaryKey {
        BillingEnergyTranSaps1PrimaryKey {
            billrunno: row.billrunno,
            contractyear: row.contractyear,
            participantid: row.participantid().to_string(),
            tni: row.tni().to_string(),
            weekno: row.weekno,
        }
    }
    fn partition_value(&self, row: &Self::Row<'_>) -> mmsdm_core::PartitionValue {
        (self.extract_row_partition)(row)
    }
    fn partition_name(&self, row: &Self::Row<'_>) -> alloc::string::String {
        alloc::format!("billing_energy_tran_saps_v1_{}", self.partition_value(row))
    }
    fn partition_key(&self) -> mmsdm_core::PartitionKey {
        self.row_partition_key
    }
    fn to_static<'a>(row: &Self::Row<'a>) -> Self::Row<'static> {
        BillingEnergyTranSaps1Row {
            contractyear: row.contractyear.clone(),
            weekno: row.weekno.clone(),
            billrunno: row.billrunno.clone(),
            participantid: row.participantid.clone(),
            tni: row.tni.clone(),
            regionid: row.regionid.clone(),
            consumed_energy_mwh: row.consumed_energy_mwh.clone(),
            sentout_energy_mwh: row.sentout_energy_mwh.clone(),
            consumed_energy_cost: row.consumed_energy_cost.clone(),
            sentout_energy_cost: row.sentout_energy_cost.clone(),
            lastchanged: row.lastchanged.clone(),
            backing_data: row.backing_data.to_owned(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct BillingEnergyTranSaps1PrimaryKey {
    pub billrunno: rust_decimal::Decimal,
    pub contractyear: rust_decimal::Decimal,
    pub participantid: alloc::string::String,
    pub tni: alloc::string::String,
    pub weekno: rust_decimal::Decimal,
}
impl mmsdm_core::PrimaryKey for BillingEnergyTranSaps1PrimaryKey {}
impl<'data> mmsdm_core::CompareWithRow for BillingEnergyTranSaps1Row<'data> {
    type Row<'other> = BillingEnergyTranSaps1Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.participantid() == row.participantid() && self.tni() == row.tni()
            && self.weekno == row.weekno
    }
}
impl<'data> mmsdm_core::CompareWithPrimaryKey for BillingEnergyTranSaps1Row<'data> {
    type PrimaryKey = BillingEnergyTranSaps1PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.participantid() == key.participantid && self.tni() == key.tni
            && self.weekno == key.weekno
    }
}
impl<'data> mmsdm_core::CompareWithRow for BillingEnergyTranSaps1PrimaryKey {
    type Row<'other> = BillingEnergyTranSaps1Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.participantid == row.participantid() && self.tni == row.tni()
            && self.weekno == row.weekno
    }
}
impl mmsdm_core::CompareWithPrimaryKey for BillingEnergyTranSaps1PrimaryKey {
    type PrimaryKey = BillingEnergyTranSaps1PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.participantid == key.participantid && self.tni == key.tni
            && self.weekno == key.weekno
    }
}
#[cfg(feature = "arrow")]
impl mmsdm_core::ArrowSchema for BillingEnergyTranSaps1 {
    type Builder = BillingEnergyTranSaps1Builder;
    fn schema() -> arrow::datatypes::Schema {
        arrow::datatypes::Schema::new(
            alloc::vec::Vec::from([
                arrow::datatypes::Field::new(
                    "contractyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "weekno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "billrunno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "participantid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "tni",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "regionid",
                    arrow::datatypes::DataType::Utf8,
                    true,
                ),
                arrow::datatypes::Field::new(
                    "consumed_energy_mwh",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "sentout_energy_mwh",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "consumed_energy_cost",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "sentout_energy_cost",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lastchanged",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    true,
                ),
            ]),
        )
    }
    fn new_builder() -> Self::Builder {
        BillingEnergyTranSaps1Builder {
            contractyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            weekno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            billrunno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            participantid_array: arrow::array::builder::StringBuilder::new(),
            tni_array: arrow::array::builder::StringBuilder::new(),
            regionid_array: arrow::array::builder::StringBuilder::new(),
            consumed_energy_mwh_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            sentout_energy_mwh_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            consumed_energy_cost_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            sentout_energy_cost_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
        }
    }
    fn append_builder(builder: &mut Self::Builder, row: Self::Row<'_>) {
        builder
            .contractyear_array
            .append_value({
                let mut val = row.contractyear;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .weekno_array
            .append_value({
                let mut val = row.weekno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .billrunno_array
            .append_value({
                let mut val = row.billrunno;
                val.rescale(0);
                val.mantissa()
            });
        builder.participantid_array.append_value(row.participantid());
        builder.tni_array.append_value(row.tni());
        builder.regionid_array.append_option(row.regionid());
        builder
            .consumed_energy_mwh_array
            .append_option({
                row.consumed_energy_mwh
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .sentout_energy_mwh_array
            .append_option({
                row.sentout_energy_mwh
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .consumed_energy_cost_array
            .append_option({
                row.consumed_energy_cost
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .sentout_energy_cost_array
            .append_option({
                row.sentout_energy_cost
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .lastchanged_array
            .append_option(row.lastchanged.map(|val| val.and_utc().timestamp_millis()));
    }
    fn finalize_builder(
        builder: &mut Self::Builder,
    ) -> mmsdm_core::Result<arrow::array::RecordBatch> {
        arrow::array::RecordBatch::try_new(
                alloc::sync::Arc::new(<Self as mmsdm_core::ArrowSchema>::schema()),
                alloc::vec::Vec::from([
                    alloc::sync::Arc::new(builder.contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.participantid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.tni_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.regionid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.consumed_energy_mwh_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.sentout_energy_mwh_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.consumed_energy_cost_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.sentout_energy_cost_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lastchanged_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                ]),
            )
            .map_err(Into::into)
    }
}
#[cfg(feature = "arrow")]
pub struct BillingEnergyTranSaps1Builder {
    contractyear_array: arrow::array::builder::Decimal128Builder,
    weekno_array: arrow::array::builder::Decimal128Builder,
    billrunno_array: arrow::array::builder::Decimal128Builder,
    participantid_array: arrow::array::builder::StringBuilder,
    tni_array: arrow::array::builder::StringBuilder,
    regionid_array: arrow::array::builder::StringBuilder,
    consumed_energy_mwh_array: arrow::array::builder::Decimal128Builder,
    sentout_energy_mwh_array: arrow::array::builder::Decimal128Builder,
    consumed_energy_cost_array: arrow::array::builder::Decimal128Builder,
    sentout_energy_cost_array: arrow::array::builder::Decimal128Builder,
    lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder,
}
pub struct BillingGstDetail5 {
    extract_row_partition: alloc::boxed::Box<
        dyn Fn(
            &BillingGstDetail5Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    >,
    row_partition_key: mmsdm_core::PartitionKey,
}
impl BillingGstDetail5 {
    pub fn new(
        row_partition_key: mmsdm_core::PartitionKey,
        func: impl Fn(
            &<Self as mmsdm_core::GetTable>::Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    ) -> Self {
        Self {
            extract_row_partition: alloc::boxed::Box::new(func),
            row_partition_key,
        }
    }
}
pub struct BillingGstDetail5Mapping([usize; 9]);
/// # Summary
///
/// ## BILLING_GST_DETAIL
///  _BILLING_GST_DETAIL shows the BAS class, GST_Exclusive and GST amount (if any) attributable to a participant for each transaction type._
///
/// * Data Set Name: Billing
/// * File Name: Gst Detail
/// * Data Version: 5
///
/// # Description
///  BILLING_GST_DETAIL data is confidential to NSP participants. Source Populated by the posting of a billing run. Volume Approximately 20 records are inserted per billrunno, or about 220 records inserted per week.
///
///
///
/// # Primary Key Columns
///
/// * BAS_CLASS
/// * BILLRUNNO
/// * CONTRACTYEAR
/// * PARTICIPANTID
/// * TRANSACTION_TYPE
/// * WEEKNO
#[derive(Debug, PartialEq, Eq)]
pub struct BillingGstDetail5Row<'data> {
    /// AEMO Contract Year number starting in week containing 1st January
    pub contractyear: rust_decimal::Decimal,
    /// Week no within the contract year. Week no 1 is the week containing 1st January
    pub weekno: rust_decimal::Decimal,
    /// Unique run no within a given contract year and week no
    pub billrunno: rust_decimal::Decimal,
    /// Unique participant identifier
    pub participantid: core::ops::Range<usize>,
    /// The BAS classification that the transaction type belongs to.
    pub bas_class: core::ops::Range<usize>,
    /// The transaction type (e.g. CUSTOMER_ENERGY_PURCHASES)
    pub transaction_type: core::ops::Range<usize>,
    /// The GST exclusive amount paid by/to the participant to/by AEMO for this transaction type.
    pub gst_exclusive_amount: Option<rust_decimal::Decimal>,
    /// The GST amount for this transaction type.
    pub gst_amount: Option<rust_decimal::Decimal>,
    /// Last date and time record changed
    pub lastchanged: Option<chrono::NaiveDateTime>,
    backing_data: mmsdm_core::CsvRow<'data>,
}
impl<'data> BillingGstDetail5Row<'data> {
    pub fn participantid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.participantid.clone())
    }
    pub fn bas_class(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.bas_class.clone())
    }
    pub fn transaction_type(&self) -> &str {
        core::ops::Index::index(
            self.backing_data.as_slice(),
            self.transaction_type.clone(),
        )
    }
}
impl mmsdm_core::GetTable for BillingGstDetail5 {
    const VERSION: i32 = 5;
    const DATA_SET_NAME: &'static str = "BILLING";
    const TABLE_NAME: &'static str = "GST_DETAIL";
    const DEFAULT_FIELD_MAPPING: Self::FieldMapping = BillingGstDetail5Mapping([
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
    ]);
    const COLUMNS: &'static [&'static str] = &[
        "CONTRACTYEAR",
        "WEEKNO",
        "BILLRUNNO",
        "PARTICIPANTID",
        "BAS_CLASS",
        "TRANSACTION_TYPE",
        "GST_EXCLUSIVE_AMOUNT",
        "GST_AMOUNT",
        "LASTCHANGED",
    ];
    type Row<'row> = BillingGstDetail5Row<'row>;
    type FieldMapping = BillingGstDetail5Mapping;
    type PrimaryKey = BillingGstDetail5PrimaryKey;
    fn from_row<'data>(
        row: mmsdm_core::CsvRow<'data>,
        field_mapping: &Self::FieldMapping,
    ) -> mmsdm_core::Result<Self::Row<'data>> {
        Ok(BillingGstDetail5Row {
            contractyear: row
                .get_custom_parsed_at_idx(
                    "contractyear",
                    field_mapping.0[0],
                    mmsdm_core::mms_decimal::parse,
                )?,
            weekno: row
                .get_custom_parsed_at_idx(
                    "weekno",
                    field_mapping.0[1],
                    mmsdm_core::mms_decimal::parse,
                )?,
            billrunno: row
                .get_custom_parsed_at_idx(
                    "billrunno",
                    field_mapping.0[2],
                    mmsdm_core::mms_decimal::parse,
                )?,
            participantid: row.get_range("participantid", field_mapping.0[3])?,
            bas_class: row.get_range("bas_class", field_mapping.0[4])?,
            transaction_type: row.get_range("transaction_type", field_mapping.0[5])?,
            gst_exclusive_amount: row
                .get_opt_custom_parsed_at_idx(
                    "gst_exclusive_amount",
                    field_mapping.0[6],
                    mmsdm_core::mms_decimal::parse,
                )?,
            gst_amount: row
                .get_opt_custom_parsed_at_idx(
                    "gst_amount",
                    field_mapping.0[7],
                    mmsdm_core::mms_decimal::parse,
                )?,
            lastchanged: row
                .get_opt_custom_parsed_at_idx(
                    "lastchanged",
                    field_mapping.0[8],
                    mmsdm_core::mms_datetime::parse,
                )?,
            backing_data: row,
        })
    }
    fn field_mapping_from_row<'a>(
        mut row: mmsdm_core::CsvRow<'a>,
    ) -> mmsdm_core::Result<Self::FieldMapping> {
        if !row.is_heading() {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!("Expected an I row but got {row:?}"),
                ),
            );
        }
        let row_key = mmsdm_core::FileKey::from_row(row.borrow())?;
        if !Self::matches_file_key(&row_key, row_key.version) {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!(
                        "Expected a row matching {}.{}.v{} but got {row_key}",
                        Self::DATA_SET_NAME, Self::TABLE_NAME, Self::VERSION
                    ),
                ),
            );
        }
        let mut base_mapping = Self::DEFAULT_FIELD_MAPPING.0;
        for (field_index, field) in Self::COLUMNS.iter().enumerate() {
            base_mapping[field_index] = row
                .iter_fields()
                .position(|f| f == *field)
                .unwrap_or(usize::MAX);
        }
        Ok(BillingGstDetail5Mapping(base_mapping))
    }
    fn matches_file_key(key: &mmsdm_core::FileKey<'_>, version: i32) -> bool {
        version == key.version && Self::DATA_SET_NAME == key.data_set_name()
            && Self::TABLE_NAME == key.table_name()
    }
    fn primary_key(row: &Self::Row<'_>) -> BillingGstDetail5PrimaryKey {
        BillingGstDetail5PrimaryKey {
            bas_class: row.bas_class().to_string(),
            billrunno: row.billrunno,
            contractyear: row.contractyear,
            participantid: row.participantid().to_string(),
            transaction_type: row.transaction_type().to_string(),
            weekno: row.weekno,
        }
    }
    fn partition_value(&self, row: &Self::Row<'_>) -> mmsdm_core::PartitionValue {
        (self.extract_row_partition)(row)
    }
    fn partition_name(&self, row: &Self::Row<'_>) -> alloc::string::String {
        alloc::format!("billing_gst_detail_v5_{}", self.partition_value(row))
    }
    fn partition_key(&self) -> mmsdm_core::PartitionKey {
        self.row_partition_key
    }
    fn to_static<'a>(row: &Self::Row<'a>) -> Self::Row<'static> {
        BillingGstDetail5Row {
            contractyear: row.contractyear.clone(),
            weekno: row.weekno.clone(),
            billrunno: row.billrunno.clone(),
            participantid: row.participantid.clone(),
            bas_class: row.bas_class.clone(),
            transaction_type: row.transaction_type.clone(),
            gst_exclusive_amount: row.gst_exclusive_amount.clone(),
            gst_amount: row.gst_amount.clone(),
            lastchanged: row.lastchanged.clone(),
            backing_data: row.backing_data.to_owned(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct BillingGstDetail5PrimaryKey {
    pub bas_class: alloc::string::String,
    pub billrunno: rust_decimal::Decimal,
    pub contractyear: rust_decimal::Decimal,
    pub participantid: alloc::string::String,
    pub transaction_type: alloc::string::String,
    pub weekno: rust_decimal::Decimal,
}
impl mmsdm_core::PrimaryKey for BillingGstDetail5PrimaryKey {}
impl<'data> mmsdm_core::CompareWithRow for BillingGstDetail5Row<'data> {
    type Row<'other> = BillingGstDetail5Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.bas_class() == row.bas_class() && self.billrunno == row.billrunno
            && self.contractyear == row.contractyear
            && self.participantid() == row.participantid()
            && self.transaction_type() == row.transaction_type()
            && self.weekno == row.weekno
    }
}
impl<'data> mmsdm_core::CompareWithPrimaryKey for BillingGstDetail5Row<'data> {
    type PrimaryKey = BillingGstDetail5PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.bas_class() == key.bas_class && self.billrunno == key.billrunno
            && self.contractyear == key.contractyear
            && self.participantid() == key.participantid
            && self.transaction_type() == key.transaction_type
            && self.weekno == key.weekno
    }
}
impl<'data> mmsdm_core::CompareWithRow for BillingGstDetail5PrimaryKey {
    type Row<'other> = BillingGstDetail5Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.bas_class == row.bas_class() && self.billrunno == row.billrunno
            && self.contractyear == row.contractyear
            && self.participantid == row.participantid()
            && self.transaction_type == row.transaction_type()
            && self.weekno == row.weekno
    }
}
impl mmsdm_core::CompareWithPrimaryKey for BillingGstDetail5PrimaryKey {
    type PrimaryKey = BillingGstDetail5PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.bas_class == key.bas_class && self.billrunno == key.billrunno
            && self.contractyear == key.contractyear
            && self.participantid == key.participantid
            && self.transaction_type == key.transaction_type && self.weekno == key.weekno
    }
}
#[cfg(feature = "arrow")]
impl mmsdm_core::ArrowSchema for BillingGstDetail5 {
    type Builder = BillingGstDetail5Builder;
    fn schema() -> arrow::datatypes::Schema {
        arrow::datatypes::Schema::new(
            alloc::vec::Vec::from([
                arrow::datatypes::Field::new(
                    "contractyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "weekno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "billrunno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "participantid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "bas_class",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "transaction_type",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "gst_exclusive_amount",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "gst_amount",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lastchanged",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    true,
                ),
            ]),
        )
    }
    fn new_builder() -> Self::Builder {
        BillingGstDetail5Builder {
            contractyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            weekno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            billrunno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            participantid_array: arrow::array::builder::StringBuilder::new(),
            bas_class_array: arrow::array::builder::StringBuilder::new(),
            transaction_type_array: arrow::array::builder::StringBuilder::new(),
            gst_exclusive_amount_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            gst_amount_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
        }
    }
    fn append_builder(builder: &mut Self::Builder, row: Self::Row<'_>) {
        builder
            .contractyear_array
            .append_value({
                let mut val = row.contractyear;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .weekno_array
            .append_value({
                let mut val = row.weekno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .billrunno_array
            .append_value({
                let mut val = row.billrunno;
                val.rescale(0);
                val.mantissa()
            });
        builder.participantid_array.append_value(row.participantid());
        builder.bas_class_array.append_value(row.bas_class());
        builder.transaction_type_array.append_value(row.transaction_type());
        builder
            .gst_exclusive_amount_array
            .append_option({
                row.gst_exclusive_amount
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .gst_amount_array
            .append_option({
                row.gst_amount
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .lastchanged_array
            .append_option(row.lastchanged.map(|val| val.and_utc().timestamp_millis()));
    }
    fn finalize_builder(
        builder: &mut Self::Builder,
    ) -> mmsdm_core::Result<arrow::array::RecordBatch> {
        arrow::array::RecordBatch::try_new(
                alloc::sync::Arc::new(<Self as mmsdm_core::ArrowSchema>::schema()),
                alloc::vec::Vec::from([
                    alloc::sync::Arc::new(builder.contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.participantid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.bas_class_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.transaction_type_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.gst_exclusive_amount_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.gst_amount_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lastchanged_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                ]),
            )
            .map_err(Into::into)
    }
}
#[cfg(feature = "arrow")]
pub struct BillingGstDetail5Builder {
    contractyear_array: arrow::array::builder::Decimal128Builder,
    weekno_array: arrow::array::builder::Decimal128Builder,
    billrunno_array: arrow::array::builder::Decimal128Builder,
    participantid_array: arrow::array::builder::StringBuilder,
    bas_class_array: arrow::array::builder::StringBuilder,
    transaction_type_array: arrow::array::builder::StringBuilder,
    gst_exclusive_amount_array: arrow::array::builder::Decimal128Builder,
    gst_amount_array: arrow::array::builder::Decimal128Builder,
    lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder,
}
pub struct BillingGstSummary5 {
    extract_row_partition: alloc::boxed::Box<
        dyn Fn(
            &BillingGstSummary5Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    >,
    row_partition_key: mmsdm_core::PartitionKey,
}
impl BillingGstSummary5 {
    pub fn new(
        row_partition_key: mmsdm_core::PartitionKey,
        func: impl Fn(
            &<Self as mmsdm_core::GetTable>::Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    ) -> Self {
        Self {
            extract_row_partition: alloc::boxed::Box::new(func),
            row_partition_key,
        }
    }
}
pub struct BillingGstSummary5Mapping([usize; 8]);
/// # Summary
///
/// ## BILLING_GST_SUMMARY
///  _BILLING_GST_SUMMARY shows the GST_Exclusive and GST amount (if any)  attributable to a participant for each BAS class._
///
/// * Data Set Name: Billing
/// * File Name: Gst Summary
/// * Data Version: 5
///
/// # Description
///  BILLING_GST_SUMMARY data is confidential to NSP participants. Source Populated by the posting of a billing run. Volume Approximately 5 records are inserted per billrunno, or about 55 records inserted per week.
///
///
///
/// # Primary Key Columns
///
/// * BAS_CLASS
/// * BILLRUNNO
/// * CONTRACTYEAR
/// * PARTICIPANTID
/// * WEEKNO
#[derive(Debug, PartialEq, Eq)]
pub struct BillingGstSummary5Row<'data> {
    /// AEMO Contract Year number starting in week containing 1st January
    pub contractyear: rust_decimal::Decimal,
    /// Week no within the contract year. Week no 1 is the week containing 1st January
    pub weekno: rust_decimal::Decimal,
    /// Unique run no within a given contract year and week no
    pub billrunno: rust_decimal::Decimal,
    /// Unique participant identifier
    pub participantid: core::ops::Range<usize>,
    /// The BAS classification
    pub bas_class: core::ops::Range<usize>,
    /// The GST exclusive amount paid by/to the participant to/by AEMO for this BAS classification.
    pub gst_exclusive_amount: Option<rust_decimal::Decimal>,
    /// The GST amount for this BAS classification.
    pub gst_amount: Option<rust_decimal::Decimal>,
    /// Last date and time record changed
    pub lastchanged: Option<chrono::NaiveDateTime>,
    backing_data: mmsdm_core::CsvRow<'data>,
}
impl<'data> BillingGstSummary5Row<'data> {
    pub fn participantid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.participantid.clone())
    }
    pub fn bas_class(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.bas_class.clone())
    }
}
impl mmsdm_core::GetTable for BillingGstSummary5 {
    const VERSION: i32 = 5;
    const DATA_SET_NAME: &'static str = "BILLING";
    const TABLE_NAME: &'static str = "GST_SUMMARY";
    const DEFAULT_FIELD_MAPPING: Self::FieldMapping = BillingGstSummary5Mapping([
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
    ]);
    const COLUMNS: &'static [&'static str] = &[
        "CONTRACTYEAR",
        "WEEKNO",
        "BILLRUNNO",
        "PARTICIPANTID",
        "BAS_CLASS",
        "GST_EXCLUSIVE_AMOUNT",
        "GST_AMOUNT",
        "LASTCHANGED",
    ];
    type Row<'row> = BillingGstSummary5Row<'row>;
    type FieldMapping = BillingGstSummary5Mapping;
    type PrimaryKey = BillingGstSummary5PrimaryKey;
    fn from_row<'data>(
        row: mmsdm_core::CsvRow<'data>,
        field_mapping: &Self::FieldMapping,
    ) -> mmsdm_core::Result<Self::Row<'data>> {
        Ok(BillingGstSummary5Row {
            contractyear: row
                .get_custom_parsed_at_idx(
                    "contractyear",
                    field_mapping.0[0],
                    mmsdm_core::mms_decimal::parse,
                )?,
            weekno: row
                .get_custom_parsed_at_idx(
                    "weekno",
                    field_mapping.0[1],
                    mmsdm_core::mms_decimal::parse,
                )?,
            billrunno: row
                .get_custom_parsed_at_idx(
                    "billrunno",
                    field_mapping.0[2],
                    mmsdm_core::mms_decimal::parse,
                )?,
            participantid: row.get_range("participantid", field_mapping.0[3])?,
            bas_class: row.get_range("bas_class", field_mapping.0[4])?,
            gst_exclusive_amount: row
                .get_opt_custom_parsed_at_idx(
                    "gst_exclusive_amount",
                    field_mapping.0[5],
                    mmsdm_core::mms_decimal::parse,
                )?,
            gst_amount: row
                .get_opt_custom_parsed_at_idx(
                    "gst_amount",
                    field_mapping.0[6],
                    mmsdm_core::mms_decimal::parse,
                )?,
            lastchanged: row
                .get_opt_custom_parsed_at_idx(
                    "lastchanged",
                    field_mapping.0[7],
                    mmsdm_core::mms_datetime::parse,
                )?,
            backing_data: row,
        })
    }
    fn field_mapping_from_row<'a>(
        mut row: mmsdm_core::CsvRow<'a>,
    ) -> mmsdm_core::Result<Self::FieldMapping> {
        if !row.is_heading() {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!("Expected an I row but got {row:?}"),
                ),
            );
        }
        let row_key = mmsdm_core::FileKey::from_row(row.borrow())?;
        if !Self::matches_file_key(&row_key, row_key.version) {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!(
                        "Expected a row matching {}.{}.v{} but got {row_key}",
                        Self::DATA_SET_NAME, Self::TABLE_NAME, Self::VERSION
                    ),
                ),
            );
        }
        let mut base_mapping = Self::DEFAULT_FIELD_MAPPING.0;
        for (field_index, field) in Self::COLUMNS.iter().enumerate() {
            base_mapping[field_index] = row
                .iter_fields()
                .position(|f| f == *field)
                .unwrap_or(usize::MAX);
        }
        Ok(BillingGstSummary5Mapping(base_mapping))
    }
    fn matches_file_key(key: &mmsdm_core::FileKey<'_>, version: i32) -> bool {
        version == key.version && Self::DATA_SET_NAME == key.data_set_name()
            && Self::TABLE_NAME == key.table_name()
    }
    fn primary_key(row: &Self::Row<'_>) -> BillingGstSummary5PrimaryKey {
        BillingGstSummary5PrimaryKey {
            bas_class: row.bas_class().to_string(),
            billrunno: row.billrunno,
            contractyear: row.contractyear,
            participantid: row.participantid().to_string(),
            weekno: row.weekno,
        }
    }
    fn partition_value(&self, row: &Self::Row<'_>) -> mmsdm_core::PartitionValue {
        (self.extract_row_partition)(row)
    }
    fn partition_name(&self, row: &Self::Row<'_>) -> alloc::string::String {
        alloc::format!("billing_gst_summary_v5_{}", self.partition_value(row))
    }
    fn partition_key(&self) -> mmsdm_core::PartitionKey {
        self.row_partition_key
    }
    fn to_static<'a>(row: &Self::Row<'a>) -> Self::Row<'static> {
        BillingGstSummary5Row {
            contractyear: row.contractyear.clone(),
            weekno: row.weekno.clone(),
            billrunno: row.billrunno.clone(),
            participantid: row.participantid.clone(),
            bas_class: row.bas_class.clone(),
            gst_exclusive_amount: row.gst_exclusive_amount.clone(),
            gst_amount: row.gst_amount.clone(),
            lastchanged: row.lastchanged.clone(),
            backing_data: row.backing_data.to_owned(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct BillingGstSummary5PrimaryKey {
    pub bas_class: alloc::string::String,
    pub billrunno: rust_decimal::Decimal,
    pub contractyear: rust_decimal::Decimal,
    pub participantid: alloc::string::String,
    pub weekno: rust_decimal::Decimal,
}
impl mmsdm_core::PrimaryKey for BillingGstSummary5PrimaryKey {}
impl<'data> mmsdm_core::CompareWithRow for BillingGstSummary5Row<'data> {
    type Row<'other> = BillingGstSummary5Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.bas_class() == row.bas_class() && self.billrunno == row.billrunno
            && self.contractyear == row.contractyear
            && self.participantid() == row.participantid() && self.weekno == row.weekno
    }
}
impl<'data> mmsdm_core::CompareWithPrimaryKey for BillingGstSummary5Row<'data> {
    type PrimaryKey = BillingGstSummary5PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.bas_class() == key.bas_class && self.billrunno == key.billrunno
            && self.contractyear == key.contractyear
            && self.participantid() == key.participantid && self.weekno == key.weekno
    }
}
impl<'data> mmsdm_core::CompareWithRow for BillingGstSummary5PrimaryKey {
    type Row<'other> = BillingGstSummary5Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.bas_class == row.bas_class() && self.billrunno == row.billrunno
            && self.contractyear == row.contractyear
            && self.participantid == row.participantid() && self.weekno == row.weekno
    }
}
impl mmsdm_core::CompareWithPrimaryKey for BillingGstSummary5PrimaryKey {
    type PrimaryKey = BillingGstSummary5PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.bas_class == key.bas_class && self.billrunno == key.billrunno
            && self.contractyear == key.contractyear
            && self.participantid == key.participantid && self.weekno == key.weekno
    }
}
#[cfg(feature = "arrow")]
impl mmsdm_core::ArrowSchema for BillingGstSummary5 {
    type Builder = BillingGstSummary5Builder;
    fn schema() -> arrow::datatypes::Schema {
        arrow::datatypes::Schema::new(
            alloc::vec::Vec::from([
                arrow::datatypes::Field::new(
                    "contractyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "weekno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "billrunno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "participantid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "bas_class",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "gst_exclusive_amount",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "gst_amount",
                    arrow::datatypes::DataType::Decimal128(15, 5),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lastchanged",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    true,
                ),
            ]),
        )
    }
    fn new_builder() -> Self::Builder {
        BillingGstSummary5Builder {
            contractyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            weekno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            billrunno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            participantid_array: arrow::array::builder::StringBuilder::new(),
            bas_class_array: arrow::array::builder::StringBuilder::new(),
            gst_exclusive_amount_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            gst_amount_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(15, 5)),
            lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
        }
    }
    fn append_builder(builder: &mut Self::Builder, row: Self::Row<'_>) {
        builder
            .contractyear_array
            .append_value({
                let mut val = row.contractyear;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .weekno_array
            .append_value({
                let mut val = row.weekno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .billrunno_array
            .append_value({
                let mut val = row.billrunno;
                val.rescale(0);
                val.mantissa()
            });
        builder.participantid_array.append_value(row.participantid());
        builder.bas_class_array.append_value(row.bas_class());
        builder
            .gst_exclusive_amount_array
            .append_option({
                row.gst_exclusive_amount
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .gst_amount_array
            .append_option({
                row.gst_amount
                    .map(|mut val| {
                        val.rescale(5);
                        val.mantissa()
                    })
            });
        builder
            .lastchanged_array
            .append_option(row.lastchanged.map(|val| val.and_utc().timestamp_millis()));
    }
    fn finalize_builder(
        builder: &mut Self::Builder,
    ) -> mmsdm_core::Result<arrow::array::RecordBatch> {
        arrow::array::RecordBatch::try_new(
                alloc::sync::Arc::new(<Self as mmsdm_core::ArrowSchema>::schema()),
                alloc::vec::Vec::from([
                    alloc::sync::Arc::new(builder.contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.participantid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.bas_class_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.gst_exclusive_amount_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.gst_amount_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lastchanged_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                ]),
            )
            .map_err(Into::into)
    }
}
#[cfg(feature = "arrow")]
pub struct BillingGstSummary5Builder {
    contractyear_array: arrow::array::builder::Decimal128Builder,
    weekno_array: arrow::array::builder::Decimal128Builder,
    billrunno_array: arrow::array::builder::Decimal128Builder,
    participantid_array: arrow::array::builder::StringBuilder,
    bas_class_array: arrow::array::builder::StringBuilder,
    gst_exclusive_amount_array: arrow::array::builder::Decimal128Builder,
    gst_amount_array: arrow::array::builder::Decimal128Builder,
    lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder,
}
pub struct BillingNmasTstPayments1 {
    extract_row_partition: alloc::boxed::Box<
        dyn Fn(
            &BillingNmasTstPayments1Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    >,
    row_partition_key: mmsdm_core::PartitionKey,
}
impl BillingNmasTstPayments1 {
    pub fn new(
        row_partition_key: mmsdm_core::PartitionKey,
        func: impl Fn(
            &<Self as mmsdm_core::GetTable>::Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    ) -> Self {
        Self {
            extract_row_partition: alloc::boxed::Box::new(func),
            row_partition_key,
        }
    }
}
pub struct BillingNmasTstPayments1Mapping([usize; 7]);
/// # Summary
///
/// ## BILLING_NMAS_TST_PAYMENTS
///  _BILLING_NMAS_TEST_PAYMENTS publish the NSCAS/SRAS Testing Payments data for a posted billing week._
///
/// * Data Set Name: Billing
/// * File Name: Nmas Tst Payments
/// * Data Version: 1
///
///
///
///
///
/// # Primary Key Columns
///
/// * BILLRUNNO
/// * CONTRACTID
/// * CONTRACTYEAR
/// * PARTICIPANTID
/// * SERVICE
/// * WEEKNO
#[derive(Debug, PartialEq, Eq)]
pub struct BillingNmasTstPayments1Row<'data> {
    /// AEMO Contract Year number starting in week containing 1 January
    pub contractyear: rust_decimal::Decimal,
    /// Week no within the contract year. Week no 1 is the week containing 1 January
    pub weekno: rust_decimal::Decimal,
    /// The current Billing RunNo for the week
    pub billrunno: rust_decimal::Decimal,
    /// The Participant from whom the amount is recovered
    pub participantid: core::ops::Range<usize>,
    /// The type of NSCAS service. Current value values are:<br>- REACTIVE<br>- LOADSHED
    pub service: core::ops::Range<usize>,
    /// The NMAS Contract Id
    pub contractid: core::ops::Range<usize>,
    /// The Testing Payment Amount to recover
    pub payment_amount: Option<rust_decimal::Decimal>,
    backing_data: mmsdm_core::CsvRow<'data>,
}
impl<'data> BillingNmasTstPayments1Row<'data> {
    pub fn participantid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.participantid.clone())
    }
    pub fn service(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.service.clone())
    }
    pub fn contractid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.contractid.clone())
    }
}
impl mmsdm_core::GetTable for BillingNmasTstPayments1 {
    const VERSION: i32 = 1;
    const DATA_SET_NAME: &'static str = "BILLING";
    const TABLE_NAME: &'static str = "NMAS_TST_PAYMENTS";
    const DEFAULT_FIELD_MAPPING: Self::FieldMapping = BillingNmasTstPayments1Mapping([
        4,
        5,
        6,
        7,
        8,
        9,
        10,
    ]);
    const COLUMNS: &'static [&'static str] = &[
        "CONTRACTYEAR",
        "WEEKNO",
        "BILLRUNNO",
        "PARTICIPANTID",
        "SERVICE",
        "CONTRACTID",
        "PAYMENT_AMOUNT",
    ];
    type Row<'row> = BillingNmasTstPayments1Row<'row>;
    type FieldMapping = BillingNmasTstPayments1Mapping;
    type PrimaryKey = BillingNmasTstPayments1PrimaryKey;
    fn from_row<'data>(
        row: mmsdm_core::CsvRow<'data>,
        field_mapping: &Self::FieldMapping,
    ) -> mmsdm_core::Result<Self::Row<'data>> {
        Ok(BillingNmasTstPayments1Row {
            contractyear: row
                .get_custom_parsed_at_idx(
                    "contractyear",
                    field_mapping.0[0],
                    mmsdm_core::mms_decimal::parse,
                )?,
            weekno: row
                .get_custom_parsed_at_idx(
                    "weekno",
                    field_mapping.0[1],
                    mmsdm_core::mms_decimal::parse,
                )?,
            billrunno: row
                .get_custom_parsed_at_idx(
                    "billrunno",
                    field_mapping.0[2],
                    mmsdm_core::mms_decimal::parse,
                )?,
            participantid: row.get_range("participantid", field_mapping.0[3])?,
            service: row.get_range("service", field_mapping.0[4])?,
            contractid: row.get_range("contractid", field_mapping.0[5])?,
            payment_amount: row
                .get_opt_custom_parsed_at_idx(
                    "payment_amount",
                    field_mapping.0[6],
                    mmsdm_core::mms_decimal::parse,
                )?,
            backing_data: row,
        })
    }
    fn field_mapping_from_row<'a>(
        mut row: mmsdm_core::CsvRow<'a>,
    ) -> mmsdm_core::Result<Self::FieldMapping> {
        if !row.is_heading() {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!("Expected an I row but got {row:?}"),
                ),
            );
        }
        let row_key = mmsdm_core::FileKey::from_row(row.borrow())?;
        if !Self::matches_file_key(&row_key, row_key.version) {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!(
                        "Expected a row matching {}.{}.v{} but got {row_key}",
                        Self::DATA_SET_NAME, Self::TABLE_NAME, Self::VERSION
                    ),
                ),
            );
        }
        let mut base_mapping = Self::DEFAULT_FIELD_MAPPING.0;
        for (field_index, field) in Self::COLUMNS.iter().enumerate() {
            base_mapping[field_index] = row
                .iter_fields()
                .position(|f| f == *field)
                .unwrap_or(usize::MAX);
        }
        Ok(BillingNmasTstPayments1Mapping(base_mapping))
    }
    fn matches_file_key(key: &mmsdm_core::FileKey<'_>, version: i32) -> bool {
        version == key.version && Self::DATA_SET_NAME == key.data_set_name()
            && Self::TABLE_NAME == key.table_name()
    }
    fn primary_key(row: &Self::Row<'_>) -> BillingNmasTstPayments1PrimaryKey {
        BillingNmasTstPayments1PrimaryKey {
            billrunno: row.billrunno,
            contractid: row.contractid().to_string(),
            contractyear: row.contractyear,
            participantid: row.participantid().to_string(),
            service: row.service().to_string(),
            weekno: row.weekno,
        }
    }
    fn partition_value(&self, row: &Self::Row<'_>) -> mmsdm_core::PartitionValue {
        (self.extract_row_partition)(row)
    }
    fn partition_name(&self, row: &Self::Row<'_>) -> alloc::string::String {
        alloc::format!("billing_nmas_tst_payments_v1_{}", self.partition_value(row))
    }
    fn partition_key(&self) -> mmsdm_core::PartitionKey {
        self.row_partition_key
    }
    fn to_static<'a>(row: &Self::Row<'a>) -> Self::Row<'static> {
        BillingNmasTstPayments1Row {
            contractyear: row.contractyear.clone(),
            weekno: row.weekno.clone(),
            billrunno: row.billrunno.clone(),
            participantid: row.participantid.clone(),
            service: row.service.clone(),
            contractid: row.contractid.clone(),
            payment_amount: row.payment_amount.clone(),
            backing_data: row.backing_data.to_owned(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct BillingNmasTstPayments1PrimaryKey {
    pub billrunno: rust_decimal::Decimal,
    pub contractid: alloc::string::String,
    pub contractyear: rust_decimal::Decimal,
    pub participantid: alloc::string::String,
    pub service: alloc::string::String,
    pub weekno: rust_decimal::Decimal,
}
impl mmsdm_core::PrimaryKey for BillingNmasTstPayments1PrimaryKey {}
impl<'data> mmsdm_core::CompareWithRow for BillingNmasTstPayments1Row<'data> {
    type Row<'other> = BillingNmasTstPayments1Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractid() == row.contractid()
            && self.contractyear == row.contractyear
            && self.participantid() == row.participantid()
            && self.service() == row.service() && self.weekno == row.weekno
    }
}
impl<'data> mmsdm_core::CompareWithPrimaryKey for BillingNmasTstPayments1Row<'data> {
    type PrimaryKey = BillingNmasTstPayments1PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractid() == key.contractid
            && self.contractyear == key.contractyear
            && self.participantid() == key.participantid && self.service() == key.service
            && self.weekno == key.weekno
    }
}
impl<'data> mmsdm_core::CompareWithRow for BillingNmasTstPayments1PrimaryKey {
    type Row<'other> = BillingNmasTstPayments1Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractid == row.contractid()
            && self.contractyear == row.contractyear
            && self.participantid == row.participantid() && self.service == row.service()
            && self.weekno == row.weekno
    }
}
impl mmsdm_core::CompareWithPrimaryKey for BillingNmasTstPayments1PrimaryKey {
    type PrimaryKey = BillingNmasTstPayments1PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractid == key.contractid
            && self.contractyear == key.contractyear
            && self.participantid == key.participantid && self.service == key.service
            && self.weekno == key.weekno
    }
}
#[cfg(feature = "arrow")]
impl mmsdm_core::ArrowSchema for BillingNmasTstPayments1 {
    type Builder = BillingNmasTstPayments1Builder;
    fn schema() -> arrow::datatypes::Schema {
        arrow::datatypes::Schema::new(
            alloc::vec::Vec::from([
                arrow::datatypes::Field::new(
                    "contractyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "weekno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "billrunno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "participantid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "service",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "contractid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "payment_amount",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
            ]),
        )
    }
    fn new_builder() -> Self::Builder {
        BillingNmasTstPayments1Builder {
            contractyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            weekno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            billrunno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            participantid_array: arrow::array::builder::StringBuilder::new(),
            service_array: arrow::array::builder::StringBuilder::new(),
            contractid_array: arrow::array::builder::StringBuilder::new(),
            payment_amount_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
        }
    }
    fn append_builder(builder: &mut Self::Builder, row: Self::Row<'_>) {
        builder
            .contractyear_array
            .append_value({
                let mut val = row.contractyear;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .weekno_array
            .append_value({
                let mut val = row.weekno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .billrunno_array
            .append_value({
                let mut val = row.billrunno;
                val.rescale(0);
                val.mantissa()
            });
        builder.participantid_array.append_value(row.participantid());
        builder.service_array.append_value(row.service());
        builder.contractid_array.append_value(row.contractid());
        builder
            .payment_amount_array
            .append_option({
                row.payment_amount
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
    }
    fn finalize_builder(
        builder: &mut Self::Builder,
    ) -> mmsdm_core::Result<arrow::array::RecordBatch> {
        arrow::array::RecordBatch::try_new(
                alloc::sync::Arc::new(<Self as mmsdm_core::ArrowSchema>::schema()),
                alloc::vec::Vec::from([
                    alloc::sync::Arc::new(builder.contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.participantid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.service_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.contractid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.payment_amount_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                ]),
            )
            .map_err(Into::into)
    }
}
#[cfg(feature = "arrow")]
pub struct BillingNmasTstPayments1Builder {
    contractyear_array: arrow::array::builder::Decimal128Builder,
    weekno_array: arrow::array::builder::Decimal128Builder,
    billrunno_array: arrow::array::builder::Decimal128Builder,
    participantid_array: arrow::array::builder::StringBuilder,
    service_array: arrow::array::builder::StringBuilder,
    contractid_array: arrow::array::builder::StringBuilder,
    payment_amount_array: arrow::array::builder::Decimal128Builder,
}
pub struct BillingNmasTstRecovery2 {
    extract_row_partition: alloc::boxed::Box<
        dyn Fn(
            &BillingNmasTstRecovery2Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    >,
    row_partition_key: mmsdm_core::PartitionKey,
}
impl BillingNmasTstRecovery2 {
    pub fn new(
        row_partition_key: mmsdm_core::PartitionKey,
        func: impl Fn(
            &<Self as mmsdm_core::GetTable>::Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    ) -> Self {
        Self {
            extract_row_partition: alloc::boxed::Box::new(func),
            row_partition_key,
        }
    }
}
pub struct BillingNmasTstRecovery2Mapping([usize; 28]);
/// # Summary
///
/// ## BILLING_NMAS_TST_RECOVERY
///  _BILLING_NMAS_TEST_RECOVERY sets out the recovery of NMAS testing payments_
///
/// * Data Set Name: Billing
/// * File Name: Nmas Tst Recovery
/// * Data Version: 2
///
///
///
///
///
/// # Primary Key Columns
///
/// * BILLRUNNO
/// * CONTRACTID
/// * CONTRACTYEAR
/// * PARTICIPANTID
/// * REGIONID
/// * SERVICE
/// * WEEKNO
#[derive(Debug, PartialEq, Eq)]
pub struct BillingNmasTstRecovery2Row<'data> {
    /// AEMO Contract Year number starting in week containing 1 January
    pub contractyear: rust_decimal::Decimal,
    /// Week no within the contract year. Week no 1 is the week containing 1 January
    pub weekno: rust_decimal::Decimal,
    /// The current Billing RunNo for the week
    pub billrunno: rust_decimal::Decimal,
    /// The Participant from whom the amount is recovered
    pub participantid: core::ops::Range<usize>,
    /// The type of NSCAS service. Current value values are:<br>- REACTIVE<br>- LOADSHED<br>- RESTART
    pub service: core::ops::Range<usize>,
    /// The NMAS Contract Id
    pub contractid: core::ops::Range<usize>,
    /// The region from where the amount is recovered
    pub regionid: core::ops::Range<usize>,
    /// The Benefitting Factor for the RegionId
    pub rbf: Option<rust_decimal::Decimal>,
    /// The total Testing Payment Amount to recover from all benefitting regions
    pub test_payment: Option<rust_decimal::Decimal>,
    /// The Recovery Start Date for the Testing Payment Calculation
    pub recovery_start_date: Option<chrono::NaiveDateTime>,
    /// The Recovery End Date for the Testing Payment Calculation
    pub recovery_end_date: Option<chrono::NaiveDateTime>,
    /// The Participant energy in MWh for the recovery period
    pub participant_energy: Option<rust_decimal::Decimal>,
    /// The RegionId energy in MWh for the recovery period
    pub region_energy: Option<rust_decimal::Decimal>,
    /// The NEM energy in MWh for the recovery period
    pub nem_energy: Option<rust_decimal::Decimal>,
    /// The Customer Proportion for recovery amount in Percent
    pub customer_proportion: Option<rust_decimal::Decimal>,
    /// The Generator Proportion for recovery amount in Percent (100-Customer Portion)
    pub generator_proportion: Option<rust_decimal::Decimal>,
    /// The Participant Generation for the recovery period
    pub participant_generation: Option<rust_decimal::Decimal>,
    /// The NEM Generation for the recovery period
    pub nem_generation: Option<rust_decimal::Decimal>,
    /// The Total recovery amount for the billing week, being the sum of the customer and generator proportions for the PARTICIPANTID in REGIONID and sum of RecoveryAmount_ACE and RecoveryAmount_ASOE.
    pub recovery_amount: Option<rust_decimal::Decimal>,
    /// The Last Updated date and time
    pub lastchanged: Option<chrono::NaiveDateTime>,
    /// The Participant ACE MWh Value used in the Recovery of the Testing Payment Amount if the service is recovered from ACE. NULL for Billing Week prior to the IESS rule effective date
    pub participant_ace_mwh: Option<rust_decimal::Decimal>,
    /// The Region ACE MWh Value used in the Recovery of the Testing Payment Amount if the service is recovered from ACE. NULL for Billing Week prior to the IESS rule effective date
    pub region_ace_mwh: Option<rust_decimal::Decimal>,
    /// The Portion of ACE MWh Value used in the Recovery Calculation. . NULL for Billing Week prior to the IESS rule effective date
    pub ace_portion: Option<rust_decimal::Decimal>,
    /// The Portion of ASOE MWh Value used in the Recovery Calculation (100 - ACE_Portion). . NULL for Billing Week prior to the IESS rule effective date
    pub asoe_portion: Option<rust_decimal::Decimal>,
    /// The Participant ASOE MWh Value used in the Recovery of the Testing Payment Amount if the service is recovered from ASOE. NULL for Billing Week prior to the IESS rule effective date
    pub participant_asoe_mwh: Option<rust_decimal::Decimal>,
    /// The Region ASOE MWh Value used in the Recovery of the Testing Payment Amount if the service is recovered from ASOE. NULL for Billing Week prior to the IESS rule effective date
    pub region_asoe_mwh: Option<rust_decimal::Decimal>,
    /// The Participant Recovery Amount based on ACE MWh Value if the service is recovered from ACE . NULL for Billing Week prior to the IESS rule effective date
    pub recoveryamount_ace: Option<rust_decimal::Decimal>,
    /// The Participant Recovery Amount based on ASOE MWh Value if the service is recovered from ASOE . NULL for Billing Week prior to the IESS rule effective date
    pub recoveryamount_asoe: Option<rust_decimal::Decimal>,
    backing_data: mmsdm_core::CsvRow<'data>,
}
impl<'data> BillingNmasTstRecovery2Row<'data> {
    pub fn participantid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.participantid.clone())
    }
    pub fn service(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.service.clone())
    }
    pub fn contractid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.contractid.clone())
    }
    pub fn regionid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.regionid.clone())
    }
}
impl mmsdm_core::GetTable for BillingNmasTstRecovery2 {
    const VERSION: i32 = 2;
    const DATA_SET_NAME: &'static str = "BILLING";
    const TABLE_NAME: &'static str = "NMAS_TST_RECOVERY";
    const DEFAULT_FIELD_MAPPING: Self::FieldMapping = BillingNmasTstRecovery2Mapping([
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        27,
        28,
        29,
        30,
        31,
    ]);
    const COLUMNS: &'static [&'static str] = &[
        "CONTRACTYEAR",
        "WEEKNO",
        "BILLRUNNO",
        "PARTICIPANTID",
        "SERVICE",
        "CONTRACTID",
        "REGIONID",
        "RBF",
        "TEST_PAYMENT",
        "RECOVERY_START_DATE",
        "RECOVERY_END_DATE",
        "PARTICIPANT_ENERGY",
        "REGION_ENERGY",
        "NEM_ENERGY",
        "CUSTOMER_PROPORTION",
        "GENERATOR_PROPORTION",
        "PARTICIPANT_GENERATION",
        "NEM_GENERATION",
        "RECOVERY_AMOUNT",
        "LASTCHANGED",
        "PARTICIPANT_ACE_MWH",
        "REGION_ACE_MWH",
        "ACE_PORTION",
        "ASOE_PORTION",
        "PARTICIPANT_ASOE_MWH",
        "REGION_ASOE_MWH",
        "RECOVERYAMOUNT_ACE",
        "RECOVERYAMOUNT_ASOE",
    ];
    type Row<'row> = BillingNmasTstRecovery2Row<'row>;
    type FieldMapping = BillingNmasTstRecovery2Mapping;
    type PrimaryKey = BillingNmasTstRecovery2PrimaryKey;
    fn from_row<'data>(
        row: mmsdm_core::CsvRow<'data>,
        field_mapping: &Self::FieldMapping,
    ) -> mmsdm_core::Result<Self::Row<'data>> {
        Ok(BillingNmasTstRecovery2Row {
            contractyear: row
                .get_custom_parsed_at_idx(
                    "contractyear",
                    field_mapping.0[0],
                    mmsdm_core::mms_decimal::parse,
                )?,
            weekno: row
                .get_custom_parsed_at_idx(
                    "weekno",
                    field_mapping.0[1],
                    mmsdm_core::mms_decimal::parse,
                )?,
            billrunno: row
                .get_custom_parsed_at_idx(
                    "billrunno",
                    field_mapping.0[2],
                    mmsdm_core::mms_decimal::parse,
                )?,
            participantid: row.get_range("participantid", field_mapping.0[3])?,
            service: row.get_range("service", field_mapping.0[4])?,
            contractid: row.get_range("contractid", field_mapping.0[5])?,
            regionid: row.get_range("regionid", field_mapping.0[6])?,
            rbf: row
                .get_opt_custom_parsed_at_idx(
                    "rbf",
                    field_mapping.0[7],
                    mmsdm_core::mms_decimal::parse,
                )?,
            test_payment: row
                .get_opt_custom_parsed_at_idx(
                    "test_payment",
                    field_mapping.0[8],
                    mmsdm_core::mms_decimal::parse,
                )?,
            recovery_start_date: row
                .get_opt_custom_parsed_at_idx(
                    "recovery_start_date",
                    field_mapping.0[9],
                    mmsdm_core::mms_datetime::parse,
                )?,
            recovery_end_date: row
                .get_opt_custom_parsed_at_idx(
                    "recovery_end_date",
                    field_mapping.0[10],
                    mmsdm_core::mms_datetime::parse,
                )?,
            participant_energy: row
                .get_opt_custom_parsed_at_idx(
                    "participant_energy",
                    field_mapping.0[11],
                    mmsdm_core::mms_decimal::parse,
                )?,
            region_energy: row
                .get_opt_custom_parsed_at_idx(
                    "region_energy",
                    field_mapping.0[12],
                    mmsdm_core::mms_decimal::parse,
                )?,
            nem_energy: row
                .get_opt_custom_parsed_at_idx(
                    "nem_energy",
                    field_mapping.0[13],
                    mmsdm_core::mms_decimal::parse,
                )?,
            customer_proportion: row
                .get_opt_custom_parsed_at_idx(
                    "customer_proportion",
                    field_mapping.0[14],
                    mmsdm_core::mms_decimal::parse,
                )?,
            generator_proportion: row
                .get_opt_custom_parsed_at_idx(
                    "generator_proportion",
                    field_mapping.0[15],
                    mmsdm_core::mms_decimal::parse,
                )?,
            participant_generation: row
                .get_opt_custom_parsed_at_idx(
                    "participant_generation",
                    field_mapping.0[16],
                    mmsdm_core::mms_decimal::parse,
                )?,
            nem_generation: row
                .get_opt_custom_parsed_at_idx(
                    "nem_generation",
                    field_mapping.0[17],
                    mmsdm_core::mms_decimal::parse,
                )?,
            recovery_amount: row
                .get_opt_custom_parsed_at_idx(
                    "recovery_amount",
                    field_mapping.0[18],
                    mmsdm_core::mms_decimal::parse,
                )?,
            lastchanged: row
                .get_opt_custom_parsed_at_idx(
                    "lastchanged",
                    field_mapping.0[19],
                    mmsdm_core::mms_datetime::parse,
                )?,
            participant_ace_mwh: row
                .get_opt_custom_parsed_at_idx(
                    "participant_ace_mwh",
                    field_mapping.0[20],
                    mmsdm_core::mms_decimal::parse,
                )?,
            region_ace_mwh: row
                .get_opt_custom_parsed_at_idx(
                    "region_ace_mwh",
                    field_mapping.0[21],
                    mmsdm_core::mms_decimal::parse,
                )?,
            ace_portion: row
                .get_opt_custom_parsed_at_idx(
                    "ace_portion",
                    field_mapping.0[22],
                    mmsdm_core::mms_decimal::parse,
                )?,
            asoe_portion: row
                .get_opt_custom_parsed_at_idx(
                    "asoe_portion",
                    field_mapping.0[23],
                    mmsdm_core::mms_decimal::parse,
                )?,
            participant_asoe_mwh: row
                .get_opt_custom_parsed_at_idx(
                    "participant_asoe_mwh",
                    field_mapping.0[24],
                    mmsdm_core::mms_decimal::parse,
                )?,
            region_asoe_mwh: row
                .get_opt_custom_parsed_at_idx(
                    "region_asoe_mwh",
                    field_mapping.0[25],
                    mmsdm_core::mms_decimal::parse,
                )?,
            recoveryamount_ace: row
                .get_opt_custom_parsed_at_idx(
                    "recoveryamount_ace",
                    field_mapping.0[26],
                    mmsdm_core::mms_decimal::parse,
                )?,
            recoveryamount_asoe: row
                .get_opt_custom_parsed_at_idx(
                    "recoveryamount_asoe",
                    field_mapping.0[27],
                    mmsdm_core::mms_decimal::parse,
                )?,
            backing_data: row,
        })
    }
    fn field_mapping_from_row<'a>(
        mut row: mmsdm_core::CsvRow<'a>,
    ) -> mmsdm_core::Result<Self::FieldMapping> {
        if !row.is_heading() {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!("Expected an I row but got {row:?}"),
                ),
            );
        }
        let row_key = mmsdm_core::FileKey::from_row(row.borrow())?;
        if !Self::matches_file_key(&row_key, row_key.version) {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!(
                        "Expected a row matching {}.{}.v{} but got {row_key}",
                        Self::DATA_SET_NAME, Self::TABLE_NAME, Self::VERSION
                    ),
                ),
            );
        }
        let mut base_mapping = Self::DEFAULT_FIELD_MAPPING.0;
        for (field_index, field) in Self::COLUMNS.iter().enumerate() {
            base_mapping[field_index] = row
                .iter_fields()
                .position(|f| f == *field)
                .unwrap_or(usize::MAX);
        }
        Ok(BillingNmasTstRecovery2Mapping(base_mapping))
    }
    fn matches_file_key(key: &mmsdm_core::FileKey<'_>, version: i32) -> bool {
        version == key.version && Self::DATA_SET_NAME == key.data_set_name()
            && Self::TABLE_NAME == key.table_name()
    }
    fn primary_key(row: &Self::Row<'_>) -> BillingNmasTstRecovery2PrimaryKey {
        BillingNmasTstRecovery2PrimaryKey {
            billrunno: row.billrunno,
            contractid: row.contractid().to_string(),
            contractyear: row.contractyear,
            participantid: row.participantid().to_string(),
            regionid: row.regionid().to_string(),
            service: row.service().to_string(),
            weekno: row.weekno,
        }
    }
    fn partition_value(&self, row: &Self::Row<'_>) -> mmsdm_core::PartitionValue {
        (self.extract_row_partition)(row)
    }
    fn partition_name(&self, row: &Self::Row<'_>) -> alloc::string::String {
        alloc::format!("billing_nmas_tst_recovery_v2_{}", self.partition_value(row))
    }
    fn partition_key(&self) -> mmsdm_core::PartitionKey {
        self.row_partition_key
    }
    fn to_static<'a>(row: &Self::Row<'a>) -> Self::Row<'static> {
        BillingNmasTstRecovery2Row {
            contractyear: row.contractyear.clone(),
            weekno: row.weekno.clone(),
            billrunno: row.billrunno.clone(),
            participantid: row.participantid.clone(),
            service: row.service.clone(),
            contractid: row.contractid.clone(),
            regionid: row.regionid.clone(),
            rbf: row.rbf.clone(),
            test_payment: row.test_payment.clone(),
            recovery_start_date: row.recovery_start_date.clone(),
            recovery_end_date: row.recovery_end_date.clone(),
            participant_energy: row.participant_energy.clone(),
            region_energy: row.region_energy.clone(),
            nem_energy: row.nem_energy.clone(),
            customer_proportion: row.customer_proportion.clone(),
            generator_proportion: row.generator_proportion.clone(),
            participant_generation: row.participant_generation.clone(),
            nem_generation: row.nem_generation.clone(),
            recovery_amount: row.recovery_amount.clone(),
            lastchanged: row.lastchanged.clone(),
            participant_ace_mwh: row.participant_ace_mwh.clone(),
            region_ace_mwh: row.region_ace_mwh.clone(),
            ace_portion: row.ace_portion.clone(),
            asoe_portion: row.asoe_portion.clone(),
            participant_asoe_mwh: row.participant_asoe_mwh.clone(),
            region_asoe_mwh: row.region_asoe_mwh.clone(),
            recoveryamount_ace: row.recoveryamount_ace.clone(),
            recoveryamount_asoe: row.recoveryamount_asoe.clone(),
            backing_data: row.backing_data.to_owned(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct BillingNmasTstRecovery2PrimaryKey {
    pub billrunno: rust_decimal::Decimal,
    pub contractid: alloc::string::String,
    pub contractyear: rust_decimal::Decimal,
    pub participantid: alloc::string::String,
    pub regionid: alloc::string::String,
    pub service: alloc::string::String,
    pub weekno: rust_decimal::Decimal,
}
impl mmsdm_core::PrimaryKey for BillingNmasTstRecovery2PrimaryKey {}
impl<'data> mmsdm_core::CompareWithRow for BillingNmasTstRecovery2Row<'data> {
    type Row<'other> = BillingNmasTstRecovery2Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractid() == row.contractid()
            && self.contractyear == row.contractyear
            && self.participantid() == row.participantid()
            && self.regionid() == row.regionid() && self.service() == row.service()
            && self.weekno == row.weekno
    }
}
impl<'data> mmsdm_core::CompareWithPrimaryKey for BillingNmasTstRecovery2Row<'data> {
    type PrimaryKey = BillingNmasTstRecovery2PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractid() == key.contractid
            && self.contractyear == key.contractyear
            && self.participantid() == key.participantid
            && self.regionid() == key.regionid && self.service() == key.service
            && self.weekno == key.weekno
    }
}
impl<'data> mmsdm_core::CompareWithRow for BillingNmasTstRecovery2PrimaryKey {
    type Row<'other> = BillingNmasTstRecovery2Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractid == row.contractid()
            && self.contractyear == row.contractyear
            && self.participantid == row.participantid()
            && self.regionid == row.regionid() && self.service == row.service()
            && self.weekno == row.weekno
    }
}
impl mmsdm_core::CompareWithPrimaryKey for BillingNmasTstRecovery2PrimaryKey {
    type PrimaryKey = BillingNmasTstRecovery2PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractid == key.contractid
            && self.contractyear == key.contractyear
            && self.participantid == key.participantid && self.regionid == key.regionid
            && self.service == key.service && self.weekno == key.weekno
    }
}
#[cfg(feature = "arrow")]
impl mmsdm_core::ArrowSchema for BillingNmasTstRecovery2 {
    type Builder = BillingNmasTstRecovery2Builder;
    fn schema() -> arrow::datatypes::Schema {
        arrow::datatypes::Schema::new(
            alloc::vec::Vec::from([
                arrow::datatypes::Field::new(
                    "contractyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "weekno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "billrunno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "participantid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "service",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "contractid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "regionid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "rbf",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "test_payment",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "recovery_start_date",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "recovery_end_date",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "participant_energy",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "region_energy",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "nem_energy",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "customer_proportion",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "generator_proportion",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "participant_generation",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "nem_generation",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "recovery_amount",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lastchanged",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "participant_ace_mwh",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "region_ace_mwh",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "ace_portion",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "asoe_portion",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "participant_asoe_mwh",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "region_asoe_mwh",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "recoveryamount_ace",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "recoveryamount_asoe",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
            ]),
        )
    }
    fn new_builder() -> Self::Builder {
        BillingNmasTstRecovery2Builder {
            contractyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            weekno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            billrunno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            participantid_array: arrow::array::builder::StringBuilder::new(),
            service_array: arrow::array::builder::StringBuilder::new(),
            contractid_array: arrow::array::builder::StringBuilder::new(),
            regionid_array: arrow::array::builder::StringBuilder::new(),
            rbf_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            test_payment_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            recovery_start_date_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
            recovery_end_date_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
            participant_energy_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            region_energy_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            nem_energy_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            customer_proportion_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            generator_proportion_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            participant_generation_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            nem_generation_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            recovery_amount_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
            participant_ace_mwh_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            region_ace_mwh_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            ace_portion_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            asoe_portion_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            participant_asoe_mwh_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            region_asoe_mwh_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            recoveryamount_ace_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            recoveryamount_asoe_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
        }
    }
    fn append_builder(builder: &mut Self::Builder, row: Self::Row<'_>) {
        builder
            .contractyear_array
            .append_value({
                let mut val = row.contractyear;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .weekno_array
            .append_value({
                let mut val = row.weekno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .billrunno_array
            .append_value({
                let mut val = row.billrunno;
                val.rescale(0);
                val.mantissa()
            });
        builder.participantid_array.append_value(row.participantid());
        builder.service_array.append_value(row.service());
        builder.contractid_array.append_value(row.contractid());
        builder.regionid_array.append_value(row.regionid());
        builder
            .rbf_array
            .append_option({
                row.rbf
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .test_payment_array
            .append_option({
                row.test_payment
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .recovery_start_date_array
            .append_option(
                row.recovery_start_date.map(|val| val.and_utc().timestamp_millis()),
            );
        builder
            .recovery_end_date_array
            .append_option(
                row.recovery_end_date.map(|val| val.and_utc().timestamp_millis()),
            );
        builder
            .participant_energy_array
            .append_option({
                row.participant_energy
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .region_energy_array
            .append_option({
                row.region_energy
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .nem_energy_array
            .append_option({
                row.nem_energy
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .customer_proportion_array
            .append_option({
                row.customer_proportion
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .generator_proportion_array
            .append_option({
                row.generator_proportion
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .participant_generation_array
            .append_option({
                row.participant_generation
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .nem_generation_array
            .append_option({
                row.nem_generation
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .recovery_amount_array
            .append_option({
                row.recovery_amount
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .lastchanged_array
            .append_option(row.lastchanged.map(|val| val.and_utc().timestamp_millis()));
        builder
            .participant_ace_mwh_array
            .append_option({
                row.participant_ace_mwh
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .region_ace_mwh_array
            .append_option({
                row.region_ace_mwh
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .ace_portion_array
            .append_option({
                row.ace_portion
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .asoe_portion_array
            .append_option({
                row.asoe_portion
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .participant_asoe_mwh_array
            .append_option({
                row.participant_asoe_mwh
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .region_asoe_mwh_array
            .append_option({
                row.region_asoe_mwh
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .recoveryamount_ace_array
            .append_option({
                row.recoveryamount_ace
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .recoveryamount_asoe_array
            .append_option({
                row.recoveryamount_asoe
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
    }
    fn finalize_builder(
        builder: &mut Self::Builder,
    ) -> mmsdm_core::Result<arrow::array::RecordBatch> {
        arrow::array::RecordBatch::try_new(
                alloc::sync::Arc::new(<Self as mmsdm_core::ArrowSchema>::schema()),
                alloc::vec::Vec::from([
                    alloc::sync::Arc::new(builder.contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.participantid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.service_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.contractid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.regionid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.rbf_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.test_payment_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.recovery_start_date_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.recovery_end_date_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.participant_energy_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.region_energy_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.nem_energy_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.customer_proportion_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.generator_proportion_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.participant_generation_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.nem_generation_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.recovery_amount_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lastchanged_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.participant_ace_mwh_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.region_ace_mwh_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.ace_portion_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.asoe_portion_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.participant_asoe_mwh_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.region_asoe_mwh_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.recoveryamount_ace_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.recoveryamount_asoe_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                ]),
            )
            .map_err(Into::into)
    }
}
#[cfg(feature = "arrow")]
pub struct BillingNmasTstRecovery2Builder {
    contractyear_array: arrow::array::builder::Decimal128Builder,
    weekno_array: arrow::array::builder::Decimal128Builder,
    billrunno_array: arrow::array::builder::Decimal128Builder,
    participantid_array: arrow::array::builder::StringBuilder,
    service_array: arrow::array::builder::StringBuilder,
    contractid_array: arrow::array::builder::StringBuilder,
    regionid_array: arrow::array::builder::StringBuilder,
    rbf_array: arrow::array::builder::Decimal128Builder,
    test_payment_array: arrow::array::builder::Decimal128Builder,
    recovery_start_date_array: arrow::array::builder::TimestampMillisecondBuilder,
    recovery_end_date_array: arrow::array::builder::TimestampMillisecondBuilder,
    participant_energy_array: arrow::array::builder::Decimal128Builder,
    region_energy_array: arrow::array::builder::Decimal128Builder,
    nem_energy_array: arrow::array::builder::Decimal128Builder,
    customer_proportion_array: arrow::array::builder::Decimal128Builder,
    generator_proportion_array: arrow::array::builder::Decimal128Builder,
    participant_generation_array: arrow::array::builder::Decimal128Builder,
    nem_generation_array: arrow::array::builder::Decimal128Builder,
    recovery_amount_array: arrow::array::builder::Decimal128Builder,
    lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder,
    participant_ace_mwh_array: arrow::array::builder::Decimal128Builder,
    region_ace_mwh_array: arrow::array::builder::Decimal128Builder,
    ace_portion_array: arrow::array::builder::Decimal128Builder,
    asoe_portion_array: arrow::array::builder::Decimal128Builder,
    participant_asoe_mwh_array: arrow::array::builder::Decimal128Builder,
    region_asoe_mwh_array: arrow::array::builder::Decimal128Builder,
    recoveryamount_ace_array: arrow::array::builder::Decimal128Builder,
    recoveryamount_asoe_array: arrow::array::builder::Decimal128Builder,
}
pub struct BillingNmasTstRecvryRbf1 {
    extract_row_partition: alloc::boxed::Box<
        dyn Fn(
            &BillingNmasTstRecvryRbf1Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    >,
    row_partition_key: mmsdm_core::PartitionKey,
}
impl BillingNmasTstRecvryRbf1 {
    pub fn new(
        row_partition_key: mmsdm_core::PartitionKey,
        func: impl Fn(
            &<Self as mmsdm_core::GetTable>::Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    ) -> Self {
        Self {
            extract_row_partition: alloc::boxed::Box::new(func),
            row_partition_key,
        }
    }
}
pub struct BillingNmasTstRecvryRbf1Mapping([usize; 10]);
/// # Summary
///
/// ## BILLING_NMAS_TST_RECVRY_RBF
///  _BILLING_NMAS_TEST_RECVRY_RBF sets out the NSCAS/SRAS Testing Payment recovery data for the posted billing week._
///
/// * Data Set Name: Billing
/// * File Name: Nmas Tst Recvry Rbf
/// * Data Version: 1
///
///
///
///
///
/// # Primary Key Columns
///
/// * BILLRUNNO
/// * CONTRACTID
/// * CONTRACTYEAR
/// * REGIONID
/// * SERVICE
/// * WEEKNO
#[derive(Debug, PartialEq, Eq)]
pub struct BillingNmasTstRecvryRbf1Row<'data> {
    /// AEMO Contract Year number starting in week containing 1 January
    pub contractyear: rust_decimal::Decimal,
    /// Week no within the contract year. Week no 1 is the week containing 1 January
    pub weekno: rust_decimal::Decimal,
    /// The current Billing RunNo for the week
    pub billrunno: rust_decimal::Decimal,
    /// The type of NSCAS service. Current value values are:<br>- REACTIVE<br>- LOADSHED
    pub service: core::ops::Range<usize>,
    /// The NMAS Contract Id
    pub contractid: core::ops::Range<usize>,
    /// The region from where the amount is recovered
    pub regionid: core::ops::Range<usize>,
    /// The Benefitting Factor for the RegionId
    pub rbf: Option<rust_decimal::Decimal>,
    /// The total Testing Payment Amount to recover from all benefitting regions
    pub payment_amount: Option<rust_decimal::Decimal>,
    /// The Testing Payment amount to recover from RegionId
    pub recovery_amount: Option<rust_decimal::Decimal>,
    /// The Last Updated date and time
    pub lastchanged: Option<chrono::NaiveDateTime>,
    backing_data: mmsdm_core::CsvRow<'data>,
}
impl<'data> BillingNmasTstRecvryRbf1Row<'data> {
    pub fn service(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.service.clone())
    }
    pub fn contractid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.contractid.clone())
    }
    pub fn regionid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.regionid.clone())
    }
}
impl mmsdm_core::GetTable for BillingNmasTstRecvryRbf1 {
    const VERSION: i32 = 1;
    const DATA_SET_NAME: &'static str = "BILLING";
    const TABLE_NAME: &'static str = "NMAS_TST_RECVRY_RBF";
    const DEFAULT_FIELD_MAPPING: Self::FieldMapping = BillingNmasTstRecvryRbf1Mapping([
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
    ]);
    const COLUMNS: &'static [&'static str] = &[
        "CONTRACTYEAR",
        "WEEKNO",
        "BILLRUNNO",
        "SERVICE",
        "CONTRACTID",
        "REGIONID",
        "RBF",
        "PAYMENT_AMOUNT",
        "RECOVERY_AMOUNT",
        "LASTCHANGED",
    ];
    type Row<'row> = BillingNmasTstRecvryRbf1Row<'row>;
    type FieldMapping = BillingNmasTstRecvryRbf1Mapping;
    type PrimaryKey = BillingNmasTstRecvryRbf1PrimaryKey;
    fn from_row<'data>(
        row: mmsdm_core::CsvRow<'data>,
        field_mapping: &Self::FieldMapping,
    ) -> mmsdm_core::Result<Self::Row<'data>> {
        Ok(BillingNmasTstRecvryRbf1Row {
            contractyear: row
                .get_custom_parsed_at_idx(
                    "contractyear",
                    field_mapping.0[0],
                    mmsdm_core::mms_decimal::parse,
                )?,
            weekno: row
                .get_custom_parsed_at_idx(
                    "weekno",
                    field_mapping.0[1],
                    mmsdm_core::mms_decimal::parse,
                )?,
            billrunno: row
                .get_custom_parsed_at_idx(
                    "billrunno",
                    field_mapping.0[2],
                    mmsdm_core::mms_decimal::parse,
                )?,
            service: row.get_range("service", field_mapping.0[3])?,
            contractid: row.get_range("contractid", field_mapping.0[4])?,
            regionid: row.get_range("regionid", field_mapping.0[5])?,
            rbf: row
                .get_opt_custom_parsed_at_idx(
                    "rbf",
                    field_mapping.0[6],
                    mmsdm_core::mms_decimal::parse,
                )?,
            payment_amount: row
                .get_opt_custom_parsed_at_idx(
                    "payment_amount",
                    field_mapping.0[7],
                    mmsdm_core::mms_decimal::parse,
                )?,
            recovery_amount: row
                .get_opt_custom_parsed_at_idx(
                    "recovery_amount",
                    field_mapping.0[8],
                    mmsdm_core::mms_decimal::parse,
                )?,
            lastchanged: row
                .get_opt_custom_parsed_at_idx(
                    "lastchanged",
                    field_mapping.0[9],
                    mmsdm_core::mms_datetime::parse,
                )?,
            backing_data: row,
        })
    }
    fn field_mapping_from_row<'a>(
        mut row: mmsdm_core::CsvRow<'a>,
    ) -> mmsdm_core::Result<Self::FieldMapping> {
        if !row.is_heading() {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!("Expected an I row but got {row:?}"),
                ),
            );
        }
        let row_key = mmsdm_core::FileKey::from_row(row.borrow())?;
        if !Self::matches_file_key(&row_key, row_key.version) {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!(
                        "Expected a row matching {}.{}.v{} but got {row_key}",
                        Self::DATA_SET_NAME, Self::TABLE_NAME, Self::VERSION
                    ),
                ),
            );
        }
        let mut base_mapping = Self::DEFAULT_FIELD_MAPPING.0;
        for (field_index, field) in Self::COLUMNS.iter().enumerate() {
            base_mapping[field_index] = row
                .iter_fields()
                .position(|f| f == *field)
                .unwrap_or(usize::MAX);
        }
        Ok(BillingNmasTstRecvryRbf1Mapping(base_mapping))
    }
    fn matches_file_key(key: &mmsdm_core::FileKey<'_>, version: i32) -> bool {
        version == key.version && Self::DATA_SET_NAME == key.data_set_name()
            && Self::TABLE_NAME == key.table_name()
    }
    fn primary_key(row: &Self::Row<'_>) -> BillingNmasTstRecvryRbf1PrimaryKey {
        BillingNmasTstRecvryRbf1PrimaryKey {
            billrunno: row.billrunno,
            contractid: row.contractid().to_string(),
            contractyear: row.contractyear,
            regionid: row.regionid().to_string(),
            service: row.service().to_string(),
            weekno: row.weekno,
        }
    }
    fn partition_value(&self, row: &Self::Row<'_>) -> mmsdm_core::PartitionValue {
        (self.extract_row_partition)(row)
    }
    fn partition_name(&self, row: &Self::Row<'_>) -> alloc::string::String {
        alloc::format!("billing_nmas_tst_recvry_rbf_v1_{}", self.partition_value(row))
    }
    fn partition_key(&self) -> mmsdm_core::PartitionKey {
        self.row_partition_key
    }
    fn to_static<'a>(row: &Self::Row<'a>) -> Self::Row<'static> {
        BillingNmasTstRecvryRbf1Row {
            contractyear: row.contractyear.clone(),
            weekno: row.weekno.clone(),
            billrunno: row.billrunno.clone(),
            service: row.service.clone(),
            contractid: row.contractid.clone(),
            regionid: row.regionid.clone(),
            rbf: row.rbf.clone(),
            payment_amount: row.payment_amount.clone(),
            recovery_amount: row.recovery_amount.clone(),
            lastchanged: row.lastchanged.clone(),
            backing_data: row.backing_data.to_owned(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct BillingNmasTstRecvryRbf1PrimaryKey {
    pub billrunno: rust_decimal::Decimal,
    pub contractid: alloc::string::String,
    pub contractyear: rust_decimal::Decimal,
    pub regionid: alloc::string::String,
    pub service: alloc::string::String,
    pub weekno: rust_decimal::Decimal,
}
impl mmsdm_core::PrimaryKey for BillingNmasTstRecvryRbf1PrimaryKey {}
impl<'data> mmsdm_core::CompareWithRow for BillingNmasTstRecvryRbf1Row<'data> {
    type Row<'other> = BillingNmasTstRecvryRbf1Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractid() == row.contractid()
            && self.contractyear == row.contractyear && self.regionid() == row.regionid()
            && self.service() == row.service() && self.weekno == row.weekno
    }
}
impl<'data> mmsdm_core::CompareWithPrimaryKey for BillingNmasTstRecvryRbf1Row<'data> {
    type PrimaryKey = BillingNmasTstRecvryRbf1PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractid() == key.contractid
            && self.contractyear == key.contractyear && self.regionid() == key.regionid
            && self.service() == key.service && self.weekno == key.weekno
    }
}
impl<'data> mmsdm_core::CompareWithRow for BillingNmasTstRecvryRbf1PrimaryKey {
    type Row<'other> = BillingNmasTstRecvryRbf1Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractid == row.contractid()
            && self.contractyear == row.contractyear && self.regionid == row.regionid()
            && self.service == row.service() && self.weekno == row.weekno
    }
}
impl mmsdm_core::CompareWithPrimaryKey for BillingNmasTstRecvryRbf1PrimaryKey {
    type PrimaryKey = BillingNmasTstRecvryRbf1PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractid == key.contractid
            && self.contractyear == key.contractyear && self.regionid == key.regionid
            && self.service == key.service && self.weekno == key.weekno
    }
}
#[cfg(feature = "arrow")]
impl mmsdm_core::ArrowSchema for BillingNmasTstRecvryRbf1 {
    type Builder = BillingNmasTstRecvryRbf1Builder;
    fn schema() -> arrow::datatypes::Schema {
        arrow::datatypes::Schema::new(
            alloc::vec::Vec::from([
                arrow::datatypes::Field::new(
                    "contractyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "weekno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "billrunno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "service",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "contractid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "regionid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "rbf",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "payment_amount",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "recovery_amount",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "lastchanged",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    true,
                ),
            ]),
        )
    }
    fn new_builder() -> Self::Builder {
        BillingNmasTstRecvryRbf1Builder {
            contractyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            weekno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            billrunno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            service_array: arrow::array::builder::StringBuilder::new(),
            contractid_array: arrow::array::builder::StringBuilder::new(),
            regionid_array: arrow::array::builder::StringBuilder::new(),
            rbf_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            payment_amount_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            recovery_amount_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
        }
    }
    fn append_builder(builder: &mut Self::Builder, row: Self::Row<'_>) {
        builder
            .contractyear_array
            .append_value({
                let mut val = row.contractyear;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .weekno_array
            .append_value({
                let mut val = row.weekno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .billrunno_array
            .append_value({
                let mut val = row.billrunno;
                val.rescale(0);
                val.mantissa()
            });
        builder.service_array.append_value(row.service());
        builder.contractid_array.append_value(row.contractid());
        builder.regionid_array.append_value(row.regionid());
        builder
            .rbf_array
            .append_option({
                row.rbf
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .payment_amount_array
            .append_option({
                row.payment_amount
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .recovery_amount_array
            .append_option({
                row.recovery_amount
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .lastchanged_array
            .append_option(row.lastchanged.map(|val| val.and_utc().timestamp_millis()));
    }
    fn finalize_builder(
        builder: &mut Self::Builder,
    ) -> mmsdm_core::Result<arrow::array::RecordBatch> {
        arrow::array::RecordBatch::try_new(
                alloc::sync::Arc::new(<Self as mmsdm_core::ArrowSchema>::schema()),
                alloc::vec::Vec::from([
                    alloc::sync::Arc::new(builder.contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.service_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.contractid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.regionid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.rbf_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.payment_amount_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.recovery_amount_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.lastchanged_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                ]),
            )
            .map_err(Into::into)
    }
}
#[cfg(feature = "arrow")]
pub struct BillingNmasTstRecvryRbf1Builder {
    contractyear_array: arrow::array::builder::Decimal128Builder,
    weekno_array: arrow::array::builder::Decimal128Builder,
    billrunno_array: arrow::array::builder::Decimal128Builder,
    service_array: arrow::array::builder::StringBuilder,
    contractid_array: arrow::array::builder::StringBuilder,
    regionid_array: arrow::array::builder::StringBuilder,
    rbf_array: arrow::array::builder::Decimal128Builder,
    payment_amount_array: arrow::array::builder::Decimal128Builder,
    recovery_amount_array: arrow::array::builder::Decimal128Builder,
    lastchanged_array: arrow::array::builder::TimestampMillisecondBuilder,
}
pub struct BillingNmasTstRecvryTrk1 {
    extract_row_partition: alloc::boxed::Box<
        dyn Fn(
            &BillingNmasTstRecvryTrk1Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    >,
    row_partition_key: mmsdm_core::PartitionKey,
}
impl BillingNmasTstRecvryTrk1 {
    pub fn new(
        row_partition_key: mmsdm_core::PartitionKey,
        func: impl Fn(
            &<Self as mmsdm_core::GetTable>::Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    ) -> Self {
        Self {
            extract_row_partition: alloc::boxed::Box::new(func),
            row_partition_key,
        }
    }
}
pub struct BillingNmasTstRecvryTrk1Mapping([usize; 6]);
/// # Summary
///
/// ## BILLING_NMAS_TST_RECVRY_TRK
///  _BILLING_NMAS_TEST_RECVRY_TRK tracks the energy data used to allocate the test payment recovery over the recovery period._
///
/// * Data Set Name: Billing
/// * File Name: Nmas Tst Recvry Trk
/// * Data Version: 1
///
///
///
///
///
/// # Primary Key Columns
///
/// * BILLRUNNO
/// * CONTRACTYEAR
/// * RECOVERY_BILLRUNNO
/// * RECOVERY_CONTRACTYEAR
/// * RECOVERY_WEEKNO
/// * WEEKNO
#[derive(Debug, PartialEq, Eq)]
pub struct BillingNmasTstRecvryTrk1Row<'data> {
    /// AEMO Contract Year number starting in week containing 1 January
    pub contractyear: rust_decimal::Decimal,
    /// Week no within the contract year. Week no 1 is the week containing 1 January
    pub weekno: rust_decimal::Decimal,
    /// The current Billing RunNo for the week
    pub billrunno: rust_decimal::Decimal,
    /// AEMO Contract Year for energy data used in recovery calculation
    pub recovery_contractyear: rust_decimal::Decimal,
    /// Week no for energy data used in recovery calculation
    pub recovery_weekno: rust_decimal::Decimal,
    /// Billing RunNo for energy data used in recovery calculation
    pub recovery_billrunno: rust_decimal::Decimal,
    backing_data: core::marker::PhantomData<&'data ()>,
}
impl<'data> BillingNmasTstRecvryTrk1Row<'data> {}
impl mmsdm_core::GetTable for BillingNmasTstRecvryTrk1 {
    const VERSION: i32 = 1;
    const DATA_SET_NAME: &'static str = "BILLING";
    const TABLE_NAME: &'static str = "NMAS_TST_RECVRY_TRK";
    const DEFAULT_FIELD_MAPPING: Self::FieldMapping = BillingNmasTstRecvryTrk1Mapping([
        4,
        5,
        6,
        7,
        8,
        9,
    ]);
    const COLUMNS: &'static [&'static str] = &[
        "CONTRACTYEAR",
        "WEEKNO",
        "BILLRUNNO",
        "RECOVERY_CONTRACTYEAR",
        "RECOVERY_WEEKNO",
        "RECOVERY_BILLRUNNO",
    ];
    type Row<'row> = BillingNmasTstRecvryTrk1Row<'row>;
    type FieldMapping = BillingNmasTstRecvryTrk1Mapping;
    type PrimaryKey = BillingNmasTstRecvryTrk1PrimaryKey;
    fn from_row<'data>(
        row: mmsdm_core::CsvRow<'data>,
        field_mapping: &Self::FieldMapping,
    ) -> mmsdm_core::Result<Self::Row<'data>> {
        Ok(BillingNmasTstRecvryTrk1Row {
            contractyear: row
                .get_custom_parsed_at_idx(
                    "contractyear",
                    field_mapping.0[0],
                    mmsdm_core::mms_decimal::parse,
                )?,
            weekno: row
                .get_custom_parsed_at_idx(
                    "weekno",
                    field_mapping.0[1],
                    mmsdm_core::mms_decimal::parse,
                )?,
            billrunno: row
                .get_custom_parsed_at_idx(
                    "billrunno",
                    field_mapping.0[2],
                    mmsdm_core::mms_decimal::parse,
                )?,
            recovery_contractyear: row
                .get_custom_parsed_at_idx(
                    "recovery_contractyear",
                    field_mapping.0[3],
                    mmsdm_core::mms_decimal::parse,
                )?,
            recovery_weekno: row
                .get_custom_parsed_at_idx(
                    "recovery_weekno",
                    field_mapping.0[4],
                    mmsdm_core::mms_decimal::parse,
                )?,
            recovery_billrunno: row
                .get_custom_parsed_at_idx(
                    "recovery_billrunno",
                    field_mapping.0[5],
                    mmsdm_core::mms_decimal::parse,
                )?,
            backing_data: core::marker::PhantomData,
        })
    }
    fn field_mapping_from_row<'a>(
        mut row: mmsdm_core::CsvRow<'a>,
    ) -> mmsdm_core::Result<Self::FieldMapping> {
        if !row.is_heading() {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!("Expected an I row but got {row:?}"),
                ),
            );
        }
        let row_key = mmsdm_core::FileKey::from_row(row.borrow())?;
        if !Self::matches_file_key(&row_key, row_key.version) {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!(
                        "Expected a row matching {}.{}.v{} but got {row_key}",
                        Self::DATA_SET_NAME, Self::TABLE_NAME, Self::VERSION
                    ),
                ),
            );
        }
        let mut base_mapping = Self::DEFAULT_FIELD_MAPPING.0;
        for (field_index, field) in Self::COLUMNS.iter().enumerate() {
            base_mapping[field_index] = row
                .iter_fields()
                .position(|f| f == *field)
                .unwrap_or(usize::MAX);
        }
        Ok(BillingNmasTstRecvryTrk1Mapping(base_mapping))
    }
    fn matches_file_key(key: &mmsdm_core::FileKey<'_>, version: i32) -> bool {
        version == key.version && Self::DATA_SET_NAME == key.data_set_name()
            && Self::TABLE_NAME == key.table_name()
    }
    fn primary_key(row: &Self::Row<'_>) -> BillingNmasTstRecvryTrk1PrimaryKey {
        BillingNmasTstRecvryTrk1PrimaryKey {
            billrunno: row.billrunno,
            contractyear: row.contractyear,
            recovery_billrunno: row.recovery_billrunno,
            recovery_contractyear: row.recovery_contractyear,
            recovery_weekno: row.recovery_weekno,
            weekno: row.weekno,
        }
    }
    fn partition_value(&self, row: &Self::Row<'_>) -> mmsdm_core::PartitionValue {
        (self.extract_row_partition)(row)
    }
    fn partition_name(&self, row: &Self::Row<'_>) -> alloc::string::String {
        alloc::format!("billing_nmas_tst_recvry_trk_v1_{}", self.partition_value(row))
    }
    fn partition_key(&self) -> mmsdm_core::PartitionKey {
        self.row_partition_key
    }
    fn to_static<'a>(row: &Self::Row<'a>) -> Self::Row<'static> {
        BillingNmasTstRecvryTrk1Row {
            contractyear: row.contractyear.clone(),
            weekno: row.weekno.clone(),
            billrunno: row.billrunno.clone(),
            recovery_contractyear: row.recovery_contractyear.clone(),
            recovery_weekno: row.recovery_weekno.clone(),
            recovery_billrunno: row.recovery_billrunno.clone(),
            backing_data: core::marker::PhantomData,
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct BillingNmasTstRecvryTrk1PrimaryKey {
    pub billrunno: rust_decimal::Decimal,
    pub contractyear: rust_decimal::Decimal,
    pub recovery_billrunno: rust_decimal::Decimal,
    pub recovery_contractyear: rust_decimal::Decimal,
    pub recovery_weekno: rust_decimal::Decimal,
    pub weekno: rust_decimal::Decimal,
}
impl mmsdm_core::PrimaryKey for BillingNmasTstRecvryTrk1PrimaryKey {}
impl<'data> mmsdm_core::CompareWithRow for BillingNmasTstRecvryTrk1Row<'data> {
    type Row<'other> = BillingNmasTstRecvryTrk1Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.recovery_billrunno == row.recovery_billrunno
            && self.recovery_contractyear == row.recovery_contractyear
            && self.recovery_weekno == row.recovery_weekno && self.weekno == row.weekno
    }
}
impl<'data> mmsdm_core::CompareWithPrimaryKey for BillingNmasTstRecvryTrk1Row<'data> {
    type PrimaryKey = BillingNmasTstRecvryTrk1PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.recovery_billrunno == key.recovery_billrunno
            && self.recovery_contractyear == key.recovery_contractyear
            && self.recovery_weekno == key.recovery_weekno && self.weekno == key.weekno
    }
}
impl<'data> mmsdm_core::CompareWithRow for BillingNmasTstRecvryTrk1PrimaryKey {
    type Row<'other> = BillingNmasTstRecvryTrk1Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.recovery_billrunno == row.recovery_billrunno
            && self.recovery_contractyear == row.recovery_contractyear
            && self.recovery_weekno == row.recovery_weekno && self.weekno == row.weekno
    }
}
impl mmsdm_core::CompareWithPrimaryKey for BillingNmasTstRecvryTrk1PrimaryKey {
    type PrimaryKey = BillingNmasTstRecvryTrk1PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.recovery_billrunno == key.recovery_billrunno
            && self.recovery_contractyear == key.recovery_contractyear
            && self.recovery_weekno == key.recovery_weekno && self.weekno == key.weekno
    }
}
#[cfg(feature = "arrow")]
impl mmsdm_core::ArrowSchema for BillingNmasTstRecvryTrk1 {
    type Builder = BillingNmasTstRecvryTrk1Builder;
    fn schema() -> arrow::datatypes::Schema {
        arrow::datatypes::Schema::new(
            alloc::vec::Vec::from([
                arrow::datatypes::Field::new(
                    "contractyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "weekno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "billrunno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "recovery_contractyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "recovery_weekno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "recovery_billrunno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
            ]),
        )
    }
    fn new_builder() -> Self::Builder {
        BillingNmasTstRecvryTrk1Builder {
            contractyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            weekno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            billrunno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            recovery_contractyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            recovery_weekno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            recovery_billrunno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
        }
    }
    fn append_builder(builder: &mut Self::Builder, row: Self::Row<'_>) {
        builder
            .contractyear_array
            .append_value({
                let mut val = row.contractyear;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .weekno_array
            .append_value({
                let mut val = row.weekno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .billrunno_array
            .append_value({
                let mut val = row.billrunno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .recovery_contractyear_array
            .append_value({
                let mut val = row.recovery_contractyear;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .recovery_weekno_array
            .append_value({
                let mut val = row.recovery_weekno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .recovery_billrunno_array
            .append_value({
                let mut val = row.recovery_billrunno;
                val.rescale(0);
                val.mantissa()
            });
    }
    fn finalize_builder(
        builder: &mut Self::Builder,
    ) -> mmsdm_core::Result<arrow::array::RecordBatch> {
        arrow::array::RecordBatch::try_new(
                alloc::sync::Arc::new(<Self as mmsdm_core::ArrowSchema>::schema()),
                alloc::vec::Vec::from([
                    alloc::sync::Arc::new(builder.contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.recovery_contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.recovery_weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.recovery_billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                ]),
            )
            .map_err(Into::into)
    }
}
#[cfg(feature = "arrow")]
pub struct BillingNmasTstRecvryTrk1Builder {
    contractyear_array: arrow::array::builder::Decimal128Builder,
    weekno_array: arrow::array::builder::Decimal128Builder,
    billrunno_array: arrow::array::builder::Decimal128Builder,
    recovery_contractyear_array: arrow::array::builder::Decimal128Builder,
    recovery_weekno_array: arrow::array::builder::Decimal128Builder,
    recovery_billrunno_array: arrow::array::builder::Decimal128Builder,
}
pub struct BillingSecdepositApplication1 {
    extract_row_partition: alloc::boxed::Box<
        dyn Fn(
            &BillingSecdepositApplication1Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    >,
    row_partition_key: mmsdm_core::PartitionKey,
}
impl BillingSecdepositApplication1 {
    pub fn new(
        row_partition_key: mmsdm_core::PartitionKey,
        func: impl Fn(
            &<Self as mmsdm_core::GetTable>::Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    ) -> Self {
        Self {
            extract_row_partition: alloc::boxed::Box::new(func),
            row_partition_key,
        }
    }
}
pub struct BillingSecdepositApplication1Mapping([usize; 5]);
/// # Summary
///
/// ## BILLING_SECDEPOSIT_APPLICATION
///  _The security deposit application details_
///
/// * Data Set Name: Billing
/// * File Name: Secdeposit Application
/// * Data Version: 1
///
/// # Description
///  BILLING_SECDEPOSIT_APPLICATION data is confidential, and is available only to the relevant participant.
///
///
///
/// # Primary Key Columns
///
/// * BILLRUNNO
/// * CONTRACTYEAR
/// * PARTICIPANTID
/// * WEEKNO
#[derive(Debug, PartialEq, Eq)]
pub struct BillingSecdepositApplication1Row<'data> {
    /// The billing contract year where (security deposit application) SDA is applied
    pub contractyear: rust_decimal::Decimal,
    /// The billing week no. where the SDA is applied
    pub weekno: rust_decimal::Decimal,
    /// The billing run no. where the SDA is applied
    pub billrunno: rust_decimal::Decimal,
    /// The Participant ID lodging the SDA
    pub participantid: core::ops::Range<usize>,
    /// The SDA application amount
    pub application_amount: Option<rust_decimal::Decimal>,
    backing_data: mmsdm_core::CsvRow<'data>,
}
impl<'data> BillingSecdepositApplication1Row<'data> {
    pub fn participantid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.participantid.clone())
    }
}
impl mmsdm_core::GetTable for BillingSecdepositApplication1 {
    const VERSION: i32 = 1;
    const DATA_SET_NAME: &'static str = "BILLING";
    const TABLE_NAME: &'static str = "SECDEPOSIT_APPLICATION";
    const DEFAULT_FIELD_MAPPING: Self::FieldMapping = BillingSecdepositApplication1Mapping([
        4,
        5,
        6,
        7,
        8,
    ]);
    const COLUMNS: &'static [&'static str] = &[
        "CONTRACTYEAR",
        "WEEKNO",
        "BILLRUNNO",
        "PARTICIPANTID",
        "APPLICATION_AMOUNT",
    ];
    type Row<'row> = BillingSecdepositApplication1Row<'row>;
    type FieldMapping = BillingSecdepositApplication1Mapping;
    type PrimaryKey = BillingSecdepositApplication1PrimaryKey;
    fn from_row<'data>(
        row: mmsdm_core::CsvRow<'data>,
        field_mapping: &Self::FieldMapping,
    ) -> mmsdm_core::Result<Self::Row<'data>> {
        Ok(BillingSecdepositApplication1Row {
            contractyear: row
                .get_custom_parsed_at_idx(
                    "contractyear",
                    field_mapping.0[0],
                    mmsdm_core::mms_decimal::parse,
                )?,
            weekno: row
                .get_custom_parsed_at_idx(
                    "weekno",
                    field_mapping.0[1],
                    mmsdm_core::mms_decimal::parse,
                )?,
            billrunno: row
                .get_custom_parsed_at_idx(
                    "billrunno",
                    field_mapping.0[2],
                    mmsdm_core::mms_decimal::parse,
                )?,
            participantid: row.get_range("participantid", field_mapping.0[3])?,
            application_amount: row
                .get_opt_custom_parsed_at_idx(
                    "application_amount",
                    field_mapping.0[4],
                    mmsdm_core::mms_decimal::parse,
                )?,
            backing_data: row,
        })
    }
    fn field_mapping_from_row<'a>(
        mut row: mmsdm_core::CsvRow<'a>,
    ) -> mmsdm_core::Result<Self::FieldMapping> {
        if !row.is_heading() {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!("Expected an I row but got {row:?}"),
                ),
            );
        }
        let row_key = mmsdm_core::FileKey::from_row(row.borrow())?;
        if !Self::matches_file_key(&row_key, row_key.version) {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!(
                        "Expected a row matching {}.{}.v{} but got {row_key}",
                        Self::DATA_SET_NAME, Self::TABLE_NAME, Self::VERSION
                    ),
                ),
            );
        }
        let mut base_mapping = Self::DEFAULT_FIELD_MAPPING.0;
        for (field_index, field) in Self::COLUMNS.iter().enumerate() {
            base_mapping[field_index] = row
                .iter_fields()
                .position(|f| f == *field)
                .unwrap_or(usize::MAX);
        }
        Ok(BillingSecdepositApplication1Mapping(base_mapping))
    }
    fn matches_file_key(key: &mmsdm_core::FileKey<'_>, version: i32) -> bool {
        version == key.version && Self::DATA_SET_NAME == key.data_set_name()
            && Self::TABLE_NAME == key.table_name()
    }
    fn primary_key(row: &Self::Row<'_>) -> BillingSecdepositApplication1PrimaryKey {
        BillingSecdepositApplication1PrimaryKey {
            billrunno: row.billrunno,
            contractyear: row.contractyear,
            participantid: row.participantid().to_string(),
            weekno: row.weekno,
        }
    }
    fn partition_value(&self, row: &Self::Row<'_>) -> mmsdm_core::PartitionValue {
        (self.extract_row_partition)(row)
    }
    fn partition_name(&self, row: &Self::Row<'_>) -> alloc::string::String {
        alloc::format!("billing_secdeposit_application_v1_{}", self.partition_value(row))
    }
    fn partition_key(&self) -> mmsdm_core::PartitionKey {
        self.row_partition_key
    }
    fn to_static<'a>(row: &Self::Row<'a>) -> Self::Row<'static> {
        BillingSecdepositApplication1Row {
            contractyear: row.contractyear.clone(),
            weekno: row.weekno.clone(),
            billrunno: row.billrunno.clone(),
            participantid: row.participantid.clone(),
            application_amount: row.application_amount.clone(),
            backing_data: row.backing_data.to_owned(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct BillingSecdepositApplication1PrimaryKey {
    pub billrunno: rust_decimal::Decimal,
    pub contractyear: rust_decimal::Decimal,
    pub participantid: alloc::string::String,
    pub weekno: rust_decimal::Decimal,
}
impl mmsdm_core::PrimaryKey for BillingSecdepositApplication1PrimaryKey {}
impl<'data> mmsdm_core::CompareWithRow for BillingSecdepositApplication1Row<'data> {
    type Row<'other> = BillingSecdepositApplication1Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.participantid() == row.participantid() && self.weekno == row.weekno
    }
}
impl<'data> mmsdm_core::CompareWithPrimaryKey
for BillingSecdepositApplication1Row<'data> {
    type PrimaryKey = BillingSecdepositApplication1PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.participantid() == key.participantid && self.weekno == key.weekno
    }
}
impl<'data> mmsdm_core::CompareWithRow for BillingSecdepositApplication1PrimaryKey {
    type Row<'other> = BillingSecdepositApplication1Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.participantid == row.participantid() && self.weekno == row.weekno
    }
}
impl mmsdm_core::CompareWithPrimaryKey for BillingSecdepositApplication1PrimaryKey {
    type PrimaryKey = BillingSecdepositApplication1PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.participantid == key.participantid && self.weekno == key.weekno
    }
}
#[cfg(feature = "arrow")]
impl mmsdm_core::ArrowSchema for BillingSecdepositApplication1 {
    type Builder = BillingSecdepositApplication1Builder;
    fn schema() -> arrow::datatypes::Schema {
        arrow::datatypes::Schema::new(
            alloc::vec::Vec::from([
                arrow::datatypes::Field::new(
                    "contractyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "weekno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "billrunno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "participantid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "application_amount",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
            ]),
        )
    }
    fn new_builder() -> Self::Builder {
        BillingSecdepositApplication1Builder {
            contractyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            weekno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            billrunno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            participantid_array: arrow::array::builder::StringBuilder::new(),
            application_amount_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
        }
    }
    fn append_builder(builder: &mut Self::Builder, row: Self::Row<'_>) {
        builder
            .contractyear_array
            .append_value({
                let mut val = row.contractyear;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .weekno_array
            .append_value({
                let mut val = row.weekno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .billrunno_array
            .append_value({
                let mut val = row.billrunno;
                val.rescale(0);
                val.mantissa()
            });
        builder.participantid_array.append_value(row.participantid());
        builder
            .application_amount_array
            .append_option({
                row.application_amount
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
    }
    fn finalize_builder(
        builder: &mut Self::Builder,
    ) -> mmsdm_core::Result<arrow::array::RecordBatch> {
        arrow::array::RecordBatch::try_new(
                alloc::sync::Arc::new(<Self as mmsdm_core::ArrowSchema>::schema()),
                alloc::vec::Vec::from([
                    alloc::sync::Arc::new(builder.contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.participantid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.application_amount_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                ]),
            )
            .map_err(Into::into)
    }
}
#[cfg(feature = "arrow")]
pub struct BillingSecdepositApplication1Builder {
    contractyear_array: arrow::array::builder::Decimal128Builder,
    weekno_array: arrow::array::builder::Decimal128Builder,
    billrunno_array: arrow::array::builder::Decimal128Builder,
    participantid_array: arrow::array::builder::StringBuilder,
    application_amount_array: arrow::array::builder::Decimal128Builder,
}
pub struct BillingSecdepInterestPay1 {
    extract_row_partition: alloc::boxed::Box<
        dyn Fn(
            &BillingSecdepInterestPay1Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    >,
    row_partition_key: mmsdm_core::PartitionKey,
}
impl BillingSecdepInterestPay1 {
    pub fn new(
        row_partition_key: mmsdm_core::PartitionKey,
        func: impl Fn(
            &<Self as mmsdm_core::GetTable>::Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    ) -> Self {
        Self {
            extract_row_partition: alloc::boxed::Box::new(func),
            row_partition_key,
        }
    }
}
pub struct BillingSecdepInterestPay1Mapping([usize; 9]);
/// # Summary
///
/// ## BILLING_SECDEP_INTEREST_PAY
///  _The interest amount for security deposit calculated by billing, based on whether it is a fixed/floating rate_
///
/// * Data Set Name: Billing
/// * File Name: Secdep Interest Pay
/// * Data Version: 1
///
/// # Description
///  BILLING_SECDEP_INTEREST_PAY data is confidential, and is available only to the relevant participant.
///
///
///
/// # Primary Key Columns
///
/// * BILLRUNNO
/// * CONTRACTYEAR
/// * PARTICIPANTID
/// * SECURITY_DEPOSIT_ID
/// * WEEKNO
#[derive(Debug, PartialEq, Eq)]
pub struct BillingSecdepInterestPay1Row<'data> {
    /// The billing contract year the SDA application is processed and interest calculated
    pub contractyear: rust_decimal::Decimal,
    /// The billing week no. the SDA application is processed and interest calculated
    pub weekno: rust_decimal::Decimal,
    /// The billing run no. the SDA application is processed and interest calculated
    pub billrunno: rust_decimal::Decimal,
    /// The security deposit ID for which billing has calculated the Interest amount
    pub security_deposit_id: core::ops::Range<usize>,
    /// The participant ID of the security deposit for whom the interest is paid
    pub participantid: core::ops::Range<usize>,
    /// The security deposit interest amount calculated by billing
    pub interest_amount: Option<rust_decimal::Decimal>,
    /// FIXED or DAILY
    pub interest_calc_type: core::ops::Range<usize>,
    /// The interest account ID used by billing for calculating the interest. <br>NULL if INTEREST_CALC_TYPE = FIXED
    pub interest_acct_id: core::ops::Range<usize>,
    /// The STATIC Interest Rate used by Billing for calculating the interest. This is NULL if INTEREST_CALC_TYPE &lt;&gt; FIXED
    pub interest_rate: Option<rust_decimal::Decimal>,
    backing_data: mmsdm_core::CsvRow<'data>,
}
impl<'data> BillingSecdepInterestPay1Row<'data> {
    pub fn security_deposit_id(&self) -> &str {
        core::ops::Index::index(
            self.backing_data.as_slice(),
            self.security_deposit_id.clone(),
        )
    }
    pub fn participantid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.participantid.clone())
    }
    pub fn interest_calc_type(&self) -> Option<&str> {
        if self.interest_calc_type.is_empty() {
            None
        } else {
            Some(
                core::ops::Index::index(
                    self.backing_data.as_slice(),
                    self.interest_calc_type.clone(),
                ),
            )
        }
    }
    pub fn interest_acct_id(&self) -> Option<&str> {
        if self.interest_acct_id.is_empty() {
            None
        } else {
            Some(
                core::ops::Index::index(
                    self.backing_data.as_slice(),
                    self.interest_acct_id.clone(),
                ),
            )
        }
    }
}
impl mmsdm_core::GetTable for BillingSecdepInterestPay1 {
    const VERSION: i32 = 1;
    const DATA_SET_NAME: &'static str = "BILLING";
    const TABLE_NAME: &'static str = "SECDEP_INTEREST_PAY";
    const DEFAULT_FIELD_MAPPING: Self::FieldMapping = BillingSecdepInterestPay1Mapping([
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
    ]);
    const COLUMNS: &'static [&'static str] = &[
        "CONTRACTYEAR",
        "WEEKNO",
        "BILLRUNNO",
        "SECURITY_DEPOSIT_ID",
        "PARTICIPANTID",
        "INTEREST_AMOUNT",
        "INTEREST_CALC_TYPE",
        "INTEREST_ACCT_ID",
        "INTEREST_RATE",
    ];
    type Row<'row> = BillingSecdepInterestPay1Row<'row>;
    type FieldMapping = BillingSecdepInterestPay1Mapping;
    type PrimaryKey = BillingSecdepInterestPay1PrimaryKey;
    fn from_row<'data>(
        row: mmsdm_core::CsvRow<'data>,
        field_mapping: &Self::FieldMapping,
    ) -> mmsdm_core::Result<Self::Row<'data>> {
        Ok(BillingSecdepInterestPay1Row {
            contractyear: row
                .get_custom_parsed_at_idx(
                    "contractyear",
                    field_mapping.0[0],
                    mmsdm_core::mms_decimal::parse,
                )?,
            weekno: row
                .get_custom_parsed_at_idx(
                    "weekno",
                    field_mapping.0[1],
                    mmsdm_core::mms_decimal::parse,
                )?,
            billrunno: row
                .get_custom_parsed_at_idx(
                    "billrunno",
                    field_mapping.0[2],
                    mmsdm_core::mms_decimal::parse,
                )?,
            security_deposit_id: row
                .get_range("security_deposit_id", field_mapping.0[3])?,
            participantid: row.get_range("participantid", field_mapping.0[4])?,
            interest_amount: row
                .get_opt_custom_parsed_at_idx(
                    "interest_amount",
                    field_mapping.0[5],
                    mmsdm_core::mms_decimal::parse,
                )?,
            interest_calc_type: row
                .get_opt_range("interest_calc_type", field_mapping.0[6])?,
            interest_acct_id: row.get_opt_range("interest_acct_id", field_mapping.0[7])?,
            interest_rate: row
                .get_opt_custom_parsed_at_idx(
                    "interest_rate",
                    field_mapping.0[8],
                    mmsdm_core::mms_decimal::parse,
                )?,
            backing_data: row,
        })
    }
    fn field_mapping_from_row<'a>(
        mut row: mmsdm_core::CsvRow<'a>,
    ) -> mmsdm_core::Result<Self::FieldMapping> {
        if !row.is_heading() {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!("Expected an I row but got {row:?}"),
                ),
            );
        }
        let row_key = mmsdm_core::FileKey::from_row(row.borrow())?;
        if !Self::matches_file_key(&row_key, row_key.version) {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!(
                        "Expected a row matching {}.{}.v{} but got {row_key}",
                        Self::DATA_SET_NAME, Self::TABLE_NAME, Self::VERSION
                    ),
                ),
            );
        }
        let mut base_mapping = Self::DEFAULT_FIELD_MAPPING.0;
        for (field_index, field) in Self::COLUMNS.iter().enumerate() {
            base_mapping[field_index] = row
                .iter_fields()
                .position(|f| f == *field)
                .unwrap_or(usize::MAX);
        }
        Ok(BillingSecdepInterestPay1Mapping(base_mapping))
    }
    fn matches_file_key(key: &mmsdm_core::FileKey<'_>, version: i32) -> bool {
        version == key.version && Self::DATA_SET_NAME == key.data_set_name()
            && Self::TABLE_NAME == key.table_name()
    }
    fn primary_key(row: &Self::Row<'_>) -> BillingSecdepInterestPay1PrimaryKey {
        BillingSecdepInterestPay1PrimaryKey {
            billrunno: row.billrunno,
            contractyear: row.contractyear,
            participantid: row.participantid().to_string(),
            security_deposit_id: row.security_deposit_id().to_string(),
            weekno: row.weekno,
        }
    }
    fn partition_value(&self, row: &Self::Row<'_>) -> mmsdm_core::PartitionValue {
        (self.extract_row_partition)(row)
    }
    fn partition_name(&self, row: &Self::Row<'_>) -> alloc::string::String {
        alloc::format!("billing_secdep_interest_pay_v1_{}", self.partition_value(row))
    }
    fn partition_key(&self) -> mmsdm_core::PartitionKey {
        self.row_partition_key
    }
    fn to_static<'a>(row: &Self::Row<'a>) -> Self::Row<'static> {
        BillingSecdepInterestPay1Row {
            contractyear: row.contractyear.clone(),
            weekno: row.weekno.clone(),
            billrunno: row.billrunno.clone(),
            security_deposit_id: row.security_deposit_id.clone(),
            participantid: row.participantid.clone(),
            interest_amount: row.interest_amount.clone(),
            interest_calc_type: row.interest_calc_type.clone(),
            interest_acct_id: row.interest_acct_id.clone(),
            interest_rate: row.interest_rate.clone(),
            backing_data: row.backing_data.to_owned(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct BillingSecdepInterestPay1PrimaryKey {
    pub billrunno: rust_decimal::Decimal,
    pub contractyear: rust_decimal::Decimal,
    pub participantid: alloc::string::String,
    pub security_deposit_id: alloc::string::String,
    pub weekno: rust_decimal::Decimal,
}
impl mmsdm_core::PrimaryKey for BillingSecdepInterestPay1PrimaryKey {}
impl<'data> mmsdm_core::CompareWithRow for BillingSecdepInterestPay1Row<'data> {
    type Row<'other> = BillingSecdepInterestPay1Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.participantid() == row.participantid()
            && self.security_deposit_id() == row.security_deposit_id()
            && self.weekno == row.weekno
    }
}
impl<'data> mmsdm_core::CompareWithPrimaryKey for BillingSecdepInterestPay1Row<'data> {
    type PrimaryKey = BillingSecdepInterestPay1PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.participantid() == key.participantid
            && self.security_deposit_id() == key.security_deposit_id
            && self.weekno == key.weekno
    }
}
impl<'data> mmsdm_core::CompareWithRow for BillingSecdepInterestPay1PrimaryKey {
    type Row<'other> = BillingSecdepInterestPay1Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.participantid == row.participantid()
            && self.security_deposit_id == row.security_deposit_id()
            && self.weekno == row.weekno
    }
}
impl mmsdm_core::CompareWithPrimaryKey for BillingSecdepInterestPay1PrimaryKey {
    type PrimaryKey = BillingSecdepInterestPay1PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.participantid == key.participantid
            && self.security_deposit_id == key.security_deposit_id
            && self.weekno == key.weekno
    }
}
#[cfg(feature = "arrow")]
impl mmsdm_core::ArrowSchema for BillingSecdepInterestPay1 {
    type Builder = BillingSecdepInterestPay1Builder;
    fn schema() -> arrow::datatypes::Schema {
        arrow::datatypes::Schema::new(
            alloc::vec::Vec::from([
                arrow::datatypes::Field::new(
                    "contractyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "weekno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "billrunno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "security_deposit_id",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "participantid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "interest_amount",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "interest_calc_type",
                    arrow::datatypes::DataType::Utf8,
                    true,
                ),
                arrow::datatypes::Field::new(
                    "interest_acct_id",
                    arrow::datatypes::DataType::Utf8,
                    true,
                ),
                arrow::datatypes::Field::new(
                    "interest_rate",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
            ]),
        )
    }
    fn new_builder() -> Self::Builder {
        BillingSecdepInterestPay1Builder {
            contractyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            weekno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            billrunno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            security_deposit_id_array: arrow::array::builder::StringBuilder::new(),
            participantid_array: arrow::array::builder::StringBuilder::new(),
            interest_amount_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            interest_calc_type_array: arrow::array::builder::StringBuilder::new(),
            interest_acct_id_array: arrow::array::builder::StringBuilder::new(),
            interest_rate_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
        }
    }
    fn append_builder(builder: &mut Self::Builder, row: Self::Row<'_>) {
        builder
            .contractyear_array
            .append_value({
                let mut val = row.contractyear;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .weekno_array
            .append_value({
                let mut val = row.weekno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .billrunno_array
            .append_value({
                let mut val = row.billrunno;
                val.rescale(0);
                val.mantissa()
            });
        builder.security_deposit_id_array.append_value(row.security_deposit_id());
        builder.participantid_array.append_value(row.participantid());
        builder
            .interest_amount_array
            .append_option({
                row.interest_amount
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder.interest_calc_type_array.append_option(row.interest_calc_type());
        builder.interest_acct_id_array.append_option(row.interest_acct_id());
        builder
            .interest_rate_array
            .append_option({
                row.interest_rate
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
    }
    fn finalize_builder(
        builder: &mut Self::Builder,
    ) -> mmsdm_core::Result<arrow::array::RecordBatch> {
        arrow::array::RecordBatch::try_new(
                alloc::sync::Arc::new(<Self as mmsdm_core::ArrowSchema>::schema()),
                alloc::vec::Vec::from([
                    alloc::sync::Arc::new(builder.contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.security_deposit_id_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.participantid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.interest_amount_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.interest_calc_type_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.interest_acct_id_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.interest_rate_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                ]),
            )
            .map_err(Into::into)
    }
}
#[cfg(feature = "arrow")]
pub struct BillingSecdepInterestPay1Builder {
    contractyear_array: arrow::array::builder::Decimal128Builder,
    weekno_array: arrow::array::builder::Decimal128Builder,
    billrunno_array: arrow::array::builder::Decimal128Builder,
    security_deposit_id_array: arrow::array::builder::StringBuilder,
    participantid_array: arrow::array::builder::StringBuilder,
    interest_amount_array: arrow::array::builder::Decimal128Builder,
    interest_calc_type_array: arrow::array::builder::StringBuilder,
    interest_acct_id_array: arrow::array::builder::StringBuilder,
    interest_rate_array: arrow::array::builder::Decimal128Builder,
}
pub struct BillingSecdepInterestRate1 {
    extract_row_partition: alloc::boxed::Box<
        dyn Fn(
            &BillingSecdepInterestRate1Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    >,
    row_partition_key: mmsdm_core::PartitionKey,
}
impl BillingSecdepInterestRate1 {
    pub fn new(
        row_partition_key: mmsdm_core::PartitionKey,
        func: impl Fn(
            &<Self as mmsdm_core::GetTable>::Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    ) -> Self {
        Self {
            extract_row_partition: alloc::boxed::Box::new(func),
            row_partition_key,
        }
    }
}
pub struct BillingSecdepInterestRate1Mapping([usize; 6]);
/// # Summary
///
/// ## BILLING_SECDEP_INTEREST_RATE
///  _The DAILY interest rates used by billing when calculating the interest amount_
///
/// * Data Set Name: Billing
/// * File Name: Secdep Interest Rate
/// * Data Version: 1
///
///
///
///
///
/// # Primary Key Columns
///
/// * BILLRUNNO
/// * CONTRACTYEAR
/// * EFFECTIVEDATE
/// * INTEREST_ACCT_ID
/// * WEEKNO
#[derive(Debug, PartialEq, Eq)]
pub struct BillingSecdepInterestRate1Row<'data> {
    /// The billing contract year the SDA application is processed and interest calculated
    pub contractyear: rust_decimal::Decimal,
    /// The billing week no. the SDA application is processed and interest calculated
    pub weekno: rust_decimal::Decimal,
    /// The billing run no. the SDA application is processed and interest calculated
    pub billrunno: rust_decimal::Decimal,
    /// The interest account ID used by security deposit interest calculation
    pub interest_acct_id: core::ops::Range<usize>,
    /// The effective date of the new interest change
    pub effectivedate: chrono::NaiveDateTime,
    /// The interest rate to apply from the effective date
    pub interest_rate: Option<rust_decimal::Decimal>,
    backing_data: mmsdm_core::CsvRow<'data>,
}
impl<'data> BillingSecdepInterestRate1Row<'data> {
    pub fn interest_acct_id(&self) -> &str {
        core::ops::Index::index(
            self.backing_data.as_slice(),
            self.interest_acct_id.clone(),
        )
    }
}
impl mmsdm_core::GetTable for BillingSecdepInterestRate1 {
    const VERSION: i32 = 1;
    const DATA_SET_NAME: &'static str = "BILLING";
    const TABLE_NAME: &'static str = "SECDEP_INTEREST_RATE";
    const DEFAULT_FIELD_MAPPING: Self::FieldMapping = BillingSecdepInterestRate1Mapping([
        4,
        5,
        6,
        7,
        8,
        9,
    ]);
    const COLUMNS: &'static [&'static str] = &[
        "CONTRACTYEAR",
        "WEEKNO",
        "BILLRUNNO",
        "INTEREST_ACCT_ID",
        "EFFECTIVEDATE",
        "INTEREST_RATE",
    ];
    type Row<'row> = BillingSecdepInterestRate1Row<'row>;
    type FieldMapping = BillingSecdepInterestRate1Mapping;
    type PrimaryKey = BillingSecdepInterestRate1PrimaryKey;
    fn from_row<'data>(
        row: mmsdm_core::CsvRow<'data>,
        field_mapping: &Self::FieldMapping,
    ) -> mmsdm_core::Result<Self::Row<'data>> {
        Ok(BillingSecdepInterestRate1Row {
            contractyear: row
                .get_custom_parsed_at_idx(
                    "contractyear",
                    field_mapping.0[0],
                    mmsdm_core::mms_decimal::parse,
                )?,
            weekno: row
                .get_custom_parsed_at_idx(
                    "weekno",
                    field_mapping.0[1],
                    mmsdm_core::mms_decimal::parse,
                )?,
            billrunno: row
                .get_custom_parsed_at_idx(
                    "billrunno",
                    field_mapping.0[2],
                    mmsdm_core::mms_decimal::parse,
                )?,
            interest_acct_id: row.get_range("interest_acct_id", field_mapping.0[3])?,
            effectivedate: row
                .get_custom_parsed_at_idx(
                    "effectivedate",
                    field_mapping.0[4],
                    mmsdm_core::mms_datetime::parse,
                )?,
            interest_rate: row
                .get_opt_custom_parsed_at_idx(
                    "interest_rate",
                    field_mapping.0[5],
                    mmsdm_core::mms_decimal::parse,
                )?,
            backing_data: row,
        })
    }
    fn field_mapping_from_row<'a>(
        mut row: mmsdm_core::CsvRow<'a>,
    ) -> mmsdm_core::Result<Self::FieldMapping> {
        if !row.is_heading() {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!("Expected an I row but got {row:?}"),
                ),
            );
        }
        let row_key = mmsdm_core::FileKey::from_row(row.borrow())?;
        if !Self::matches_file_key(&row_key, row_key.version) {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!(
                        "Expected a row matching {}.{}.v{} but got {row_key}",
                        Self::DATA_SET_NAME, Self::TABLE_NAME, Self::VERSION
                    ),
                ),
            );
        }
        let mut base_mapping = Self::DEFAULT_FIELD_MAPPING.0;
        for (field_index, field) in Self::COLUMNS.iter().enumerate() {
            base_mapping[field_index] = row
                .iter_fields()
                .position(|f| f == *field)
                .unwrap_or(usize::MAX);
        }
        Ok(BillingSecdepInterestRate1Mapping(base_mapping))
    }
    fn matches_file_key(key: &mmsdm_core::FileKey<'_>, version: i32) -> bool {
        version == key.version && Self::DATA_SET_NAME == key.data_set_name()
            && Self::TABLE_NAME == key.table_name()
    }
    fn primary_key(row: &Self::Row<'_>) -> BillingSecdepInterestRate1PrimaryKey {
        BillingSecdepInterestRate1PrimaryKey {
            billrunno: row.billrunno,
            contractyear: row.contractyear,
            effectivedate: row.effectivedate,
            interest_acct_id: row.interest_acct_id().to_string(),
            weekno: row.weekno,
        }
    }
    fn partition_value(&self, row: &Self::Row<'_>) -> mmsdm_core::PartitionValue {
        (self.extract_row_partition)(row)
    }
    fn partition_name(&self, row: &Self::Row<'_>) -> alloc::string::String {
        alloc::format!("billing_secdep_interest_rate_v1_{}", self.partition_value(row))
    }
    fn partition_key(&self) -> mmsdm_core::PartitionKey {
        self.row_partition_key
    }
    fn to_static<'a>(row: &Self::Row<'a>) -> Self::Row<'static> {
        BillingSecdepInterestRate1Row {
            contractyear: row.contractyear.clone(),
            weekno: row.weekno.clone(),
            billrunno: row.billrunno.clone(),
            interest_acct_id: row.interest_acct_id.clone(),
            effectivedate: row.effectivedate.clone(),
            interest_rate: row.interest_rate.clone(),
            backing_data: row.backing_data.to_owned(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct BillingSecdepInterestRate1PrimaryKey {
    pub billrunno: rust_decimal::Decimal,
    pub contractyear: rust_decimal::Decimal,
    pub effectivedate: chrono::NaiveDateTime,
    pub interest_acct_id: alloc::string::String,
    pub weekno: rust_decimal::Decimal,
}
impl mmsdm_core::PrimaryKey for BillingSecdepInterestRate1PrimaryKey {}
impl<'data> mmsdm_core::CompareWithRow for BillingSecdepInterestRate1Row<'data> {
    type Row<'other> = BillingSecdepInterestRate1Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.effectivedate == row.effectivedate
            && self.interest_acct_id() == row.interest_acct_id()
            && self.weekno == row.weekno
    }
}
impl<'data> mmsdm_core::CompareWithPrimaryKey for BillingSecdepInterestRate1Row<'data> {
    type PrimaryKey = BillingSecdepInterestRate1PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.effectivedate == key.effectivedate
            && self.interest_acct_id() == key.interest_acct_id
            && self.weekno == key.weekno
    }
}
impl<'data> mmsdm_core::CompareWithRow for BillingSecdepInterestRate1PrimaryKey {
    type Row<'other> = BillingSecdepInterestRate1Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.effectivedate == row.effectivedate
            && self.interest_acct_id == row.interest_acct_id()
            && self.weekno == row.weekno
    }
}
impl mmsdm_core::CompareWithPrimaryKey for BillingSecdepInterestRate1PrimaryKey {
    type PrimaryKey = BillingSecdepInterestRate1PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.effectivedate == key.effectivedate
            && self.interest_acct_id == key.interest_acct_id && self.weekno == key.weekno
    }
}
#[cfg(feature = "arrow")]
impl mmsdm_core::ArrowSchema for BillingSecdepInterestRate1 {
    type Builder = BillingSecdepInterestRate1Builder;
    fn schema() -> arrow::datatypes::Schema {
        arrow::datatypes::Schema::new(
            alloc::vec::Vec::from([
                arrow::datatypes::Field::new(
                    "contractyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "weekno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "billrunno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "interest_acct_id",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "effectivedate",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "interest_rate",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
            ]),
        )
    }
    fn new_builder() -> Self::Builder {
        BillingSecdepInterestRate1Builder {
            contractyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            weekno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            billrunno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            interest_acct_id_array: arrow::array::builder::StringBuilder::new(),
            effectivedate_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
            interest_rate_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
        }
    }
    fn append_builder(builder: &mut Self::Builder, row: Self::Row<'_>) {
        builder
            .contractyear_array
            .append_value({
                let mut val = row.contractyear;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .weekno_array
            .append_value({
                let mut val = row.weekno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .billrunno_array
            .append_value({
                let mut val = row.billrunno;
                val.rescale(0);
                val.mantissa()
            });
        builder.interest_acct_id_array.append_value(row.interest_acct_id());
        builder
            .effectivedate_array
            .append_value(row.effectivedate.and_utc().timestamp_millis());
        builder
            .interest_rate_array
            .append_option({
                row.interest_rate
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
    }
    fn finalize_builder(
        builder: &mut Self::Builder,
    ) -> mmsdm_core::Result<arrow::array::RecordBatch> {
        arrow::array::RecordBatch::try_new(
                alloc::sync::Arc::new(<Self as mmsdm_core::ArrowSchema>::schema()),
                alloc::vec::Vec::from([
                    alloc::sync::Arc::new(builder.contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.interest_acct_id_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.effectivedate_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.interest_rate_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                ]),
            )
            .map_err(Into::into)
    }
}
#[cfg(feature = "arrow")]
pub struct BillingSecdepInterestRate1Builder {
    contractyear_array: arrow::array::builder::Decimal128Builder,
    weekno_array: arrow::array::builder::Decimal128Builder,
    billrunno_array: arrow::array::builder::Decimal128Builder,
    interest_acct_id_array: arrow::array::builder::StringBuilder,
    effectivedate_array: arrow::array::builder::TimestampMillisecondBuilder,
    interest_rate_array: arrow::array::builder::Decimal128Builder,
}
pub struct BillingSubstDemand1 {
    extract_row_partition: alloc::boxed::Box<
        dyn Fn(
            &BillingSubstDemand1Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    >,
    row_partition_key: mmsdm_core::PartitionKey,
}
impl BillingSubstDemand1 {
    pub fn new(
        row_partition_key: mmsdm_core::PartitionKey,
        func: impl Fn(
            &<Self as mmsdm_core::GetTable>::Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    ) -> Self {
        Self {
            extract_row_partition: alloc::boxed::Box::new(func),
            row_partition_key,
        }
    }
}
pub struct BillingSubstDemand1Mapping([usize; 8]);
/// # Summary
///
/// ## BILLING_SUBST_DEMAND
///  _Demand Values Substituted in Billing Calculation_
///
/// * Data Set Name: Billing
/// * File Name: Subst Demand
/// * Data Version: 1
///
///
///
///
///
/// # Primary Key Columns
///
/// * BILLRUNNO
/// * CONTRACTYEAR
/// * PARTICIPANTID
/// * SETTLEMENTDATE
/// * TNI
/// * WEEKNO
#[derive(Debug, PartialEq, Eq)]
pub struct BillingSubstDemand1Row<'data> {
    /// Billing contract year
    pub contractyear: rust_decimal::Decimal,
    /// Billing week number
    pub weekno: rust_decimal::Decimal,
    /// Billing run number
    pub billrunno: rust_decimal::Decimal,
    /// Settlement Date
    pub settlementdate: chrono::NaiveDateTime,
    /// Unique identifier for the connection point
    pub tni: core::ops::Range<usize>,
    /// Unique identifier for the participant
    pub participantid: core::ops::Range<usize>,
    /// Unique identifier for the region to which the TNI belongs to on this settlement date
    pub regionid: core::ops::Range<usize>,
    /// Substitute metered quantity for non-energy recovery in MWh for the TNI and participant in the trading interval. A negative value indicates net consumption and a positive value indicates net generation
    pub substitutedemand: Option<rust_decimal::Decimal>,
    backing_data: mmsdm_core::CsvRow<'data>,
}
impl<'data> BillingSubstDemand1Row<'data> {
    pub fn tni(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.tni.clone())
    }
    pub fn participantid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.participantid.clone())
    }
    pub fn regionid(&self) -> Option<&str> {
        if self.regionid.is_empty() {
            None
        } else {
            Some(
                core::ops::Index::index(
                    self.backing_data.as_slice(),
                    self.regionid.clone(),
                ),
            )
        }
    }
}
impl mmsdm_core::GetTable for BillingSubstDemand1 {
    const VERSION: i32 = 1;
    const DATA_SET_NAME: &'static str = "BILLING";
    const TABLE_NAME: &'static str = "SUBST_DEMAND";
    const DEFAULT_FIELD_MAPPING: Self::FieldMapping = BillingSubstDemand1Mapping([
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
    ]);
    const COLUMNS: &'static [&'static str] = &[
        "CONTRACTYEAR",
        "WEEKNO",
        "BILLRUNNO",
        "SETTLEMENTDATE",
        "TNI",
        "PARTICIPANTID",
        "REGIONID",
        "SUBSTITUTEDEMAND",
    ];
    type Row<'row> = BillingSubstDemand1Row<'row>;
    type FieldMapping = BillingSubstDemand1Mapping;
    type PrimaryKey = BillingSubstDemand1PrimaryKey;
    fn from_row<'data>(
        row: mmsdm_core::CsvRow<'data>,
        field_mapping: &Self::FieldMapping,
    ) -> mmsdm_core::Result<Self::Row<'data>> {
        Ok(BillingSubstDemand1Row {
            contractyear: row
                .get_custom_parsed_at_idx(
                    "contractyear",
                    field_mapping.0[0],
                    mmsdm_core::mms_decimal::parse,
                )?,
            weekno: row
                .get_custom_parsed_at_idx(
                    "weekno",
                    field_mapping.0[1],
                    mmsdm_core::mms_decimal::parse,
                )?,
            billrunno: row
                .get_custom_parsed_at_idx(
                    "billrunno",
                    field_mapping.0[2],
                    mmsdm_core::mms_decimal::parse,
                )?,
            settlementdate: row
                .get_custom_parsed_at_idx(
                    "settlementdate",
                    field_mapping.0[3],
                    mmsdm_core::mms_datetime::parse,
                )?,
            tni: row.get_range("tni", field_mapping.0[4])?,
            participantid: row.get_range("participantid", field_mapping.0[5])?,
            regionid: row.get_opt_range("regionid", field_mapping.0[6])?,
            substitutedemand: row
                .get_opt_custom_parsed_at_idx(
                    "substitutedemand",
                    field_mapping.0[7],
                    mmsdm_core::mms_decimal::parse,
                )?,
            backing_data: row,
        })
    }
    fn field_mapping_from_row<'a>(
        mut row: mmsdm_core::CsvRow<'a>,
    ) -> mmsdm_core::Result<Self::FieldMapping> {
        if !row.is_heading() {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!("Expected an I row but got {row:?}"),
                ),
            );
        }
        let row_key = mmsdm_core::FileKey::from_row(row.borrow())?;
        if !Self::matches_file_key(&row_key, row_key.version) {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!(
                        "Expected a row matching {}.{}.v{} but got {row_key}",
                        Self::DATA_SET_NAME, Self::TABLE_NAME, Self::VERSION
                    ),
                ),
            );
        }
        let mut base_mapping = Self::DEFAULT_FIELD_MAPPING.0;
        for (field_index, field) in Self::COLUMNS.iter().enumerate() {
            base_mapping[field_index] = row
                .iter_fields()
                .position(|f| f == *field)
                .unwrap_or(usize::MAX);
        }
        Ok(BillingSubstDemand1Mapping(base_mapping))
    }
    fn matches_file_key(key: &mmsdm_core::FileKey<'_>, version: i32) -> bool {
        version == key.version && Self::DATA_SET_NAME == key.data_set_name()
            && Self::TABLE_NAME == key.table_name()
    }
    fn primary_key(row: &Self::Row<'_>) -> BillingSubstDemand1PrimaryKey {
        BillingSubstDemand1PrimaryKey {
            billrunno: row.billrunno,
            contractyear: row.contractyear,
            participantid: row.participantid().to_string(),
            settlementdate: row.settlementdate,
            tni: row.tni().to_string(),
            weekno: row.weekno,
        }
    }
    fn partition_value(&self, row: &Self::Row<'_>) -> mmsdm_core::PartitionValue {
        (self.extract_row_partition)(row)
    }
    fn partition_name(&self, row: &Self::Row<'_>) -> alloc::string::String {
        alloc::format!("billing_subst_demand_v1_{}", self.partition_value(row))
    }
    fn partition_key(&self) -> mmsdm_core::PartitionKey {
        self.row_partition_key
    }
    fn to_static<'a>(row: &Self::Row<'a>) -> Self::Row<'static> {
        BillingSubstDemand1Row {
            contractyear: row.contractyear.clone(),
            weekno: row.weekno.clone(),
            billrunno: row.billrunno.clone(),
            settlementdate: row.settlementdate.clone(),
            tni: row.tni.clone(),
            participantid: row.participantid.clone(),
            regionid: row.regionid.clone(),
            substitutedemand: row.substitutedemand.clone(),
            backing_data: row.backing_data.to_owned(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct BillingSubstDemand1PrimaryKey {
    pub billrunno: rust_decimal::Decimal,
    pub contractyear: rust_decimal::Decimal,
    pub participantid: alloc::string::String,
    pub settlementdate: chrono::NaiveDateTime,
    pub tni: alloc::string::String,
    pub weekno: rust_decimal::Decimal,
}
impl mmsdm_core::PrimaryKey for BillingSubstDemand1PrimaryKey {}
impl<'data> mmsdm_core::CompareWithRow for BillingSubstDemand1Row<'data> {
    type Row<'other> = BillingSubstDemand1Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.participantid() == row.participantid()
            && self.settlementdate == row.settlementdate && self.tni() == row.tni()
            && self.weekno == row.weekno
    }
}
impl<'data> mmsdm_core::CompareWithPrimaryKey for BillingSubstDemand1Row<'data> {
    type PrimaryKey = BillingSubstDemand1PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.participantid() == key.participantid
            && self.settlementdate == key.settlementdate && self.tni() == key.tni
            && self.weekno == key.weekno
    }
}
impl<'data> mmsdm_core::CompareWithRow for BillingSubstDemand1PrimaryKey {
    type Row<'other> = BillingSubstDemand1Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.participantid == row.participantid()
            && self.settlementdate == row.settlementdate && self.tni == row.tni()
            && self.weekno == row.weekno
    }
}
impl mmsdm_core::CompareWithPrimaryKey for BillingSubstDemand1PrimaryKey {
    type PrimaryKey = BillingSubstDemand1PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.participantid == key.participantid
            && self.settlementdate == key.settlementdate && self.tni == key.tni
            && self.weekno == key.weekno
    }
}
#[cfg(feature = "arrow")]
impl mmsdm_core::ArrowSchema for BillingSubstDemand1 {
    type Builder = BillingSubstDemand1Builder;
    fn schema() -> arrow::datatypes::Schema {
        arrow::datatypes::Schema::new(
            alloc::vec::Vec::from([
                arrow::datatypes::Field::new(
                    "contractyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "weekno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "billrunno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "settlementdate",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "tni",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "participantid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "regionid",
                    arrow::datatypes::DataType::Utf8,
                    true,
                ),
                arrow::datatypes::Field::new(
                    "substitutedemand",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
            ]),
        )
    }
    fn new_builder() -> Self::Builder {
        BillingSubstDemand1Builder {
            contractyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            weekno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            billrunno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            settlementdate_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
            tni_array: arrow::array::builder::StringBuilder::new(),
            participantid_array: arrow::array::builder::StringBuilder::new(),
            regionid_array: arrow::array::builder::StringBuilder::new(),
            substitutedemand_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
        }
    }
    fn append_builder(builder: &mut Self::Builder, row: Self::Row<'_>) {
        builder
            .contractyear_array
            .append_value({
                let mut val = row.contractyear;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .weekno_array
            .append_value({
                let mut val = row.weekno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .billrunno_array
            .append_value({
                let mut val = row.billrunno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .settlementdate_array
            .append_value(row.settlementdate.and_utc().timestamp_millis());
        builder.tni_array.append_value(row.tni());
        builder.participantid_array.append_value(row.participantid());
        builder.regionid_array.append_option(row.regionid());
        builder
            .substitutedemand_array
            .append_option({
                row.substitutedemand
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
    }
    fn finalize_builder(
        builder: &mut Self::Builder,
    ) -> mmsdm_core::Result<arrow::array::RecordBatch> {
        arrow::array::RecordBatch::try_new(
                alloc::sync::Arc::new(<Self as mmsdm_core::ArrowSchema>::schema()),
                alloc::vec::Vec::from([
                    alloc::sync::Arc::new(builder.contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.settlementdate_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.tni_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.participantid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.regionid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.substitutedemand_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                ]),
            )
            .map_err(Into::into)
    }
}
#[cfg(feature = "arrow")]
pub struct BillingSubstDemand1Builder {
    contractyear_array: arrow::array::builder::Decimal128Builder,
    weekno_array: arrow::array::builder::Decimal128Builder,
    billrunno_array: arrow::array::builder::Decimal128Builder,
    settlementdate_array: arrow::array::builder::TimestampMillisecondBuilder,
    tni_array: arrow::array::builder::StringBuilder,
    participantid_array: arrow::array::builder::StringBuilder,
    regionid_array: arrow::array::builder::StringBuilder,
    substitutedemand_array: arrow::array::builder::Decimal128Builder,
}
pub struct BillingSubstRunVersion1 {
    extract_row_partition: alloc::boxed::Box<
        dyn Fn(
            &BillingSubstRunVersion1Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    >,
    row_partition_key: mmsdm_core::PartitionKey,
}
impl BillingSubstRunVersion1 {
    pub fn new(
        row_partition_key: mmsdm_core::PartitionKey,
        func: impl Fn(
            &<Self as mmsdm_core::GetTable>::Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    ) -> Self {
        Self {
            extract_row_partition: alloc::boxed::Box::new(func),
            row_partition_key,
        }
    }
}
pub struct BillingSubstRunVersion1Mapping([usize; 5]);
/// # Summary
///
/// ## BILLING_SUBST_RUN_VERSION
///  _Details of settlement runs used as input in the substitute demand calculation_
///
/// * Data Set Name: Billing
/// * File Name: Subst Run Version
/// * Data Version: 1
///
///
///
///
///
/// # Primary Key Columns
///
/// * BILLRUNNO
/// * CONTRACTYEAR
/// * REFERENCESETTLEMENTDATE
/// * REFERENCESETTLEMENTRUNNO
/// * WEEKNO
#[derive(Debug, PartialEq, Eq)]
pub struct BillingSubstRunVersion1Row<'data> {
    /// Billing contract year
    pub contractyear: rust_decimal::Decimal,
    /// Billing week number
    pub weekno: rust_decimal::Decimal,
    /// Billing run number
    pub billrunno: rust_decimal::Decimal,
    /// Settlement Date
    pub referencesettlementdate: chrono::NaiveDateTime,
    /// The settlement run number matching the settlement date for a settlement run included in the reference period
    pub referencesettlementrunno: rust_decimal::Decimal,
    backing_data: core::marker::PhantomData<&'data ()>,
}
impl<'data> BillingSubstRunVersion1Row<'data> {}
impl mmsdm_core::GetTable for BillingSubstRunVersion1 {
    const VERSION: i32 = 1;
    const DATA_SET_NAME: &'static str = "BILLING";
    const TABLE_NAME: &'static str = "SUBST_RUN_VERSION";
    const DEFAULT_FIELD_MAPPING: Self::FieldMapping = BillingSubstRunVersion1Mapping([
        4,
        5,
        6,
        7,
        8,
    ]);
    const COLUMNS: &'static [&'static str] = &[
        "CONTRACTYEAR",
        "WEEKNO",
        "BILLRUNNO",
        "REFERENCESETTLEMENTDATE",
        "REFERENCESETTLEMENTRUNNO",
    ];
    type Row<'row> = BillingSubstRunVersion1Row<'row>;
    type FieldMapping = BillingSubstRunVersion1Mapping;
    type PrimaryKey = BillingSubstRunVersion1PrimaryKey;
    fn from_row<'data>(
        row: mmsdm_core::CsvRow<'data>,
        field_mapping: &Self::FieldMapping,
    ) -> mmsdm_core::Result<Self::Row<'data>> {
        Ok(BillingSubstRunVersion1Row {
            contractyear: row
                .get_custom_parsed_at_idx(
                    "contractyear",
                    field_mapping.0[0],
                    mmsdm_core::mms_decimal::parse,
                )?,
            weekno: row
                .get_custom_parsed_at_idx(
                    "weekno",
                    field_mapping.0[1],
                    mmsdm_core::mms_decimal::parse,
                )?,
            billrunno: row
                .get_custom_parsed_at_idx(
                    "billrunno",
                    field_mapping.0[2],
                    mmsdm_core::mms_decimal::parse,
                )?,
            referencesettlementdate: row
                .get_custom_parsed_at_idx(
                    "referencesettlementdate",
                    field_mapping.0[3],
                    mmsdm_core::mms_datetime::parse,
                )?,
            referencesettlementrunno: row
                .get_custom_parsed_at_idx(
                    "referencesettlementrunno",
                    field_mapping.0[4],
                    mmsdm_core::mms_decimal::parse,
                )?,
            backing_data: core::marker::PhantomData,
        })
    }
    fn field_mapping_from_row<'a>(
        mut row: mmsdm_core::CsvRow<'a>,
    ) -> mmsdm_core::Result<Self::FieldMapping> {
        if !row.is_heading() {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!("Expected an I row but got {row:?}"),
                ),
            );
        }
        let row_key = mmsdm_core::FileKey::from_row(row.borrow())?;
        if !Self::matches_file_key(&row_key, row_key.version) {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!(
                        "Expected a row matching {}.{}.v{} but got {row_key}",
                        Self::DATA_SET_NAME, Self::TABLE_NAME, Self::VERSION
                    ),
                ),
            );
        }
        let mut base_mapping = Self::DEFAULT_FIELD_MAPPING.0;
        for (field_index, field) in Self::COLUMNS.iter().enumerate() {
            base_mapping[field_index] = row
                .iter_fields()
                .position(|f| f == *field)
                .unwrap_or(usize::MAX);
        }
        Ok(BillingSubstRunVersion1Mapping(base_mapping))
    }
    fn matches_file_key(key: &mmsdm_core::FileKey<'_>, version: i32) -> bool {
        version == key.version && Self::DATA_SET_NAME == key.data_set_name()
            && Self::TABLE_NAME == key.table_name()
    }
    fn primary_key(row: &Self::Row<'_>) -> BillingSubstRunVersion1PrimaryKey {
        BillingSubstRunVersion1PrimaryKey {
            billrunno: row.billrunno,
            contractyear: row.contractyear,
            referencesettlementdate: row.referencesettlementdate,
            referencesettlementrunno: row.referencesettlementrunno,
            weekno: row.weekno,
        }
    }
    fn partition_value(&self, row: &Self::Row<'_>) -> mmsdm_core::PartitionValue {
        (self.extract_row_partition)(row)
    }
    fn partition_name(&self, row: &Self::Row<'_>) -> alloc::string::String {
        alloc::format!("billing_subst_run_version_v1_{}", self.partition_value(row))
    }
    fn partition_key(&self) -> mmsdm_core::PartitionKey {
        self.row_partition_key
    }
    fn to_static<'a>(row: &Self::Row<'a>) -> Self::Row<'static> {
        BillingSubstRunVersion1Row {
            contractyear: row.contractyear.clone(),
            weekno: row.weekno.clone(),
            billrunno: row.billrunno.clone(),
            referencesettlementdate: row.referencesettlementdate.clone(),
            referencesettlementrunno: row.referencesettlementrunno.clone(),
            backing_data: core::marker::PhantomData,
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct BillingSubstRunVersion1PrimaryKey {
    pub billrunno: rust_decimal::Decimal,
    pub contractyear: rust_decimal::Decimal,
    pub referencesettlementdate: chrono::NaiveDateTime,
    pub referencesettlementrunno: rust_decimal::Decimal,
    pub weekno: rust_decimal::Decimal,
}
impl mmsdm_core::PrimaryKey for BillingSubstRunVersion1PrimaryKey {}
impl<'data> mmsdm_core::CompareWithRow for BillingSubstRunVersion1Row<'data> {
    type Row<'other> = BillingSubstRunVersion1Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.referencesettlementdate == row.referencesettlementdate
            && self.referencesettlementrunno == row.referencesettlementrunno
            && self.weekno == row.weekno
    }
}
impl<'data> mmsdm_core::CompareWithPrimaryKey for BillingSubstRunVersion1Row<'data> {
    type PrimaryKey = BillingSubstRunVersion1PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.referencesettlementdate == key.referencesettlementdate
            && self.referencesettlementrunno == key.referencesettlementrunno
            && self.weekno == key.weekno
    }
}
impl<'data> mmsdm_core::CompareWithRow for BillingSubstRunVersion1PrimaryKey {
    type Row<'other> = BillingSubstRunVersion1Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.referencesettlementdate == row.referencesettlementdate
            && self.referencesettlementrunno == row.referencesettlementrunno
            && self.weekno == row.weekno
    }
}
impl mmsdm_core::CompareWithPrimaryKey for BillingSubstRunVersion1PrimaryKey {
    type PrimaryKey = BillingSubstRunVersion1PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.referencesettlementdate == key.referencesettlementdate
            && self.referencesettlementrunno == key.referencesettlementrunno
            && self.weekno == key.weekno
    }
}
#[cfg(feature = "arrow")]
impl mmsdm_core::ArrowSchema for BillingSubstRunVersion1 {
    type Builder = BillingSubstRunVersion1Builder;
    fn schema() -> arrow::datatypes::Schema {
        arrow::datatypes::Schema::new(
            alloc::vec::Vec::from([
                arrow::datatypes::Field::new(
                    "contractyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "weekno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "billrunno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "referencesettlementdate",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "referencesettlementrunno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
            ]),
        )
    }
    fn new_builder() -> Self::Builder {
        BillingSubstRunVersion1Builder {
            contractyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            weekno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            billrunno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            referencesettlementdate_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
            referencesettlementrunno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
        }
    }
    fn append_builder(builder: &mut Self::Builder, row: Self::Row<'_>) {
        builder
            .contractyear_array
            .append_value({
                let mut val = row.contractyear;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .weekno_array
            .append_value({
                let mut val = row.weekno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .billrunno_array
            .append_value({
                let mut val = row.billrunno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .referencesettlementdate_array
            .append_value(row.referencesettlementdate.and_utc().timestamp_millis());
        builder
            .referencesettlementrunno_array
            .append_value({
                let mut val = row.referencesettlementrunno;
                val.rescale(0);
                val.mantissa()
            });
    }
    fn finalize_builder(
        builder: &mut Self::Builder,
    ) -> mmsdm_core::Result<arrow::array::RecordBatch> {
        arrow::array::RecordBatch::try_new(
                alloc::sync::Arc::new(<Self as mmsdm_core::ArrowSchema>::schema()),
                alloc::vec::Vec::from([
                    alloc::sync::Arc::new(builder.contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.referencesettlementdate_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(
                        builder.referencesettlementrunno_array.finish(),
                    ) as alloc::sync::Arc<dyn arrow::array::Array>,
                ]),
            )
            .map_err(Into::into)
    }
}
#[cfg(feature = "arrow")]
pub struct BillingSubstRunVersion1Builder {
    contractyear_array: arrow::array::builder::Decimal128Builder,
    weekno_array: arrow::array::builder::Decimal128Builder,
    billrunno_array: arrow::array::builder::Decimal128Builder,
    referencesettlementdate_array: arrow::array::builder::TimestampMillisecondBuilder,
    referencesettlementrunno_array: arrow::array::builder::Decimal128Builder,
}
pub struct BillingWdr1 {
    extract_row_partition: alloc::boxed::Box<
        dyn Fn(&BillingWdr1Row<'_>) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    >,
    row_partition_key: mmsdm_core::PartitionKey,
}
impl BillingWdr1 {
    pub fn new(
        row_partition_key: mmsdm_core::PartitionKey,
        func: impl Fn(
            &<Self as mmsdm_core::GetTable>::Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    ) -> Self {
        Self {
            extract_row_partition: alloc::boxed::Box::new(func),
            row_partition_key,
        }
    }
}
pub struct BillingWdr1Mapping([usize; 6]);
/// # Summary
///
/// ## BILLING_WDR
///  _Billing WDR Transaction Weekly Summary_
///
/// * Data Set Name: Billing
/// * File Name: Wdr
/// * Data Version: 1
///
///
///
///
///
/// # Primary Key Columns
///
/// * BILLRUNNO
/// * CONTRACTYEAR
/// * PARTICIPANTID
/// * WEEKNO
#[derive(Debug, PartialEq, Eq)]
pub struct BillingWdr1Row<'data> {
    /// Contract year of the Billing run
    pub contractyear: rust_decimal::Decimal,
    /// Week number of the Billing run
    pub weekno: rust_decimal::Decimal,
    /// Billing run number identifier
    pub billrunno: rust_decimal::Decimal,
    /// DRSP or FRMP Participant Identifier
    pub participantid: core::ops::Range<usize>,
    /// WDR credit transaction amount
    pub wdr_credit_amount: Option<rust_decimal::Decimal>,
    /// WDR debit transaction amount
    pub wdr_debit_amount: Option<rust_decimal::Decimal>,
    backing_data: mmsdm_core::CsvRow<'data>,
}
impl<'data> BillingWdr1Row<'data> {
    pub fn participantid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.participantid.clone())
    }
}
impl mmsdm_core::GetTable for BillingWdr1 {
    const VERSION: i32 = 1;
    const DATA_SET_NAME: &'static str = "BILLING";
    const TABLE_NAME: &'static str = "WDR";
    const DEFAULT_FIELD_MAPPING: Self::FieldMapping = BillingWdr1Mapping([
        4,
        5,
        6,
        7,
        8,
        9,
    ]);
    const COLUMNS: &'static [&'static str] = &[
        "CONTRACTYEAR",
        "WEEKNO",
        "BILLRUNNO",
        "PARTICIPANTID",
        "WDR_CREDIT_AMOUNT",
        "WDR_DEBIT_AMOUNT",
    ];
    type Row<'row> = BillingWdr1Row<'row>;
    type FieldMapping = BillingWdr1Mapping;
    type PrimaryKey = BillingWdr1PrimaryKey;
    fn from_row<'data>(
        row: mmsdm_core::CsvRow<'data>,
        field_mapping: &Self::FieldMapping,
    ) -> mmsdm_core::Result<Self::Row<'data>> {
        Ok(BillingWdr1Row {
            contractyear: row
                .get_custom_parsed_at_idx(
                    "contractyear",
                    field_mapping.0[0],
                    mmsdm_core::mms_decimal::parse,
                )?,
            weekno: row
                .get_custom_parsed_at_idx(
                    "weekno",
                    field_mapping.0[1],
                    mmsdm_core::mms_decimal::parse,
                )?,
            billrunno: row
                .get_custom_parsed_at_idx(
                    "billrunno",
                    field_mapping.0[2],
                    mmsdm_core::mms_decimal::parse,
                )?,
            participantid: row.get_range("participantid", field_mapping.0[3])?,
            wdr_credit_amount: row
                .get_opt_custom_parsed_at_idx(
                    "wdr_credit_amount",
                    field_mapping.0[4],
                    mmsdm_core::mms_decimal::parse,
                )?,
            wdr_debit_amount: row
                .get_opt_custom_parsed_at_idx(
                    "wdr_debit_amount",
                    field_mapping.0[5],
                    mmsdm_core::mms_decimal::parse,
                )?,
            backing_data: row,
        })
    }
    fn field_mapping_from_row<'a>(
        mut row: mmsdm_core::CsvRow<'a>,
    ) -> mmsdm_core::Result<Self::FieldMapping> {
        if !row.is_heading() {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!("Expected an I row but got {row:?}"),
                ),
            );
        }
        let row_key = mmsdm_core::FileKey::from_row(row.borrow())?;
        if !Self::matches_file_key(&row_key, row_key.version) {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!(
                        "Expected a row matching {}.{}.v{} but got {row_key}",
                        Self::DATA_SET_NAME, Self::TABLE_NAME, Self::VERSION
                    ),
                ),
            );
        }
        let mut base_mapping = Self::DEFAULT_FIELD_MAPPING.0;
        for (field_index, field) in Self::COLUMNS.iter().enumerate() {
            base_mapping[field_index] = row
                .iter_fields()
                .position(|f| f == *field)
                .unwrap_or(usize::MAX);
        }
        Ok(BillingWdr1Mapping(base_mapping))
    }
    fn matches_file_key(key: &mmsdm_core::FileKey<'_>, version: i32) -> bool {
        version == key.version && Self::DATA_SET_NAME == key.data_set_name()
            && Self::TABLE_NAME == key.table_name()
    }
    fn primary_key(row: &Self::Row<'_>) -> BillingWdr1PrimaryKey {
        BillingWdr1PrimaryKey {
            billrunno: row.billrunno,
            contractyear: row.contractyear,
            participantid: row.participantid().to_string(),
            weekno: row.weekno,
        }
    }
    fn partition_value(&self, row: &Self::Row<'_>) -> mmsdm_core::PartitionValue {
        (self.extract_row_partition)(row)
    }
    fn partition_name(&self, row: &Self::Row<'_>) -> alloc::string::String {
        alloc::format!("billing_wdr_v1_{}", self.partition_value(row))
    }
    fn partition_key(&self) -> mmsdm_core::PartitionKey {
        self.row_partition_key
    }
    fn to_static<'a>(row: &Self::Row<'a>) -> Self::Row<'static> {
        BillingWdr1Row {
            contractyear: row.contractyear.clone(),
            weekno: row.weekno.clone(),
            billrunno: row.billrunno.clone(),
            participantid: row.participantid.clone(),
            wdr_credit_amount: row.wdr_credit_amount.clone(),
            wdr_debit_amount: row.wdr_debit_amount.clone(),
            backing_data: row.backing_data.to_owned(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct BillingWdr1PrimaryKey {
    pub billrunno: rust_decimal::Decimal,
    pub contractyear: rust_decimal::Decimal,
    pub participantid: alloc::string::String,
    pub weekno: rust_decimal::Decimal,
}
impl mmsdm_core::PrimaryKey for BillingWdr1PrimaryKey {}
impl<'data> mmsdm_core::CompareWithRow for BillingWdr1Row<'data> {
    type Row<'other> = BillingWdr1Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.participantid() == row.participantid() && self.weekno == row.weekno
    }
}
impl<'data> mmsdm_core::CompareWithPrimaryKey for BillingWdr1Row<'data> {
    type PrimaryKey = BillingWdr1PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.participantid() == key.participantid && self.weekno == key.weekno
    }
}
impl<'data> mmsdm_core::CompareWithRow for BillingWdr1PrimaryKey {
    type Row<'other> = BillingWdr1Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.participantid == row.participantid() && self.weekno == row.weekno
    }
}
impl mmsdm_core::CompareWithPrimaryKey for BillingWdr1PrimaryKey {
    type PrimaryKey = BillingWdr1PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.participantid == key.participantid && self.weekno == key.weekno
    }
}
#[cfg(feature = "arrow")]
impl mmsdm_core::ArrowSchema for BillingWdr1 {
    type Builder = BillingWdr1Builder;
    fn schema() -> arrow::datatypes::Schema {
        arrow::datatypes::Schema::new(
            alloc::vec::Vec::from([
                arrow::datatypes::Field::new(
                    "contractyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "weekno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "billrunno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "participantid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "wdr_credit_amount",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "wdr_debit_amount",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
            ]),
        )
    }
    fn new_builder() -> Self::Builder {
        BillingWdr1Builder {
            contractyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            weekno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            billrunno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            participantid_array: arrow::array::builder::StringBuilder::new(),
            wdr_credit_amount_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            wdr_debit_amount_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
        }
    }
    fn append_builder(builder: &mut Self::Builder, row: Self::Row<'_>) {
        builder
            .contractyear_array
            .append_value({
                let mut val = row.contractyear;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .weekno_array
            .append_value({
                let mut val = row.weekno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .billrunno_array
            .append_value({
                let mut val = row.billrunno;
                val.rescale(0);
                val.mantissa()
            });
        builder.participantid_array.append_value(row.participantid());
        builder
            .wdr_credit_amount_array
            .append_option({
                row.wdr_credit_amount
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .wdr_debit_amount_array
            .append_option({
                row.wdr_debit_amount
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
    }
    fn finalize_builder(
        builder: &mut Self::Builder,
    ) -> mmsdm_core::Result<arrow::array::RecordBatch> {
        arrow::array::RecordBatch::try_new(
                alloc::sync::Arc::new(<Self as mmsdm_core::ArrowSchema>::schema()),
                alloc::vec::Vec::from([
                    alloc::sync::Arc::new(builder.contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.participantid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.wdr_credit_amount_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.wdr_debit_amount_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                ]),
            )
            .map_err(Into::into)
    }
}
#[cfg(feature = "arrow")]
pub struct BillingWdr1Builder {
    contractyear_array: arrow::array::builder::Decimal128Builder,
    weekno_array: arrow::array::builder::Decimal128Builder,
    billrunno_array: arrow::array::builder::Decimal128Builder,
    participantid_array: arrow::array::builder::StringBuilder,
    wdr_credit_amount_array: arrow::array::builder::Decimal128Builder,
    wdr_debit_amount_array: arrow::array::builder::Decimal128Builder,
}
pub struct BillingWdrDetail1 {
    extract_row_partition: alloc::boxed::Box<
        dyn Fn(
            &BillingWdrDetail1Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    >,
    row_partition_key: mmsdm_core::PartitionKey,
}
impl BillingWdrDetail1 {
    pub fn new(
        row_partition_key: mmsdm_core::PartitionKey,
        func: impl Fn(
            &<Self as mmsdm_core::GetTable>::Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    ) -> Self {
        Self {
            extract_row_partition: alloc::boxed::Box::new(func),
            row_partition_key,
        }
    }
}
pub struct BillingWdrDetail1Mapping([usize; 10]);
/// # Summary
///
/// ## BILLING_WDR_DETAIL
///  _Billing WDR transaction detail summary_
///
/// * Data Set Name: Billing
/// * File Name: Wdr Detail
/// * Data Version: 1
///
///
///
///
///
/// # Primary Key Columns
///
/// * BILLRUNNO
/// * CONTRACTYEAR
/// * DRSP
/// * FRMP
/// * REGIONID
/// * WDRRRPERIOD
/// * WEEKNO
#[derive(Debug, PartialEq, Eq)]
pub struct BillingWdrDetail1Row<'data> {
    /// Contract year of the Billing run
    pub contractyear: rust_decimal::Decimal,
    /// Week number of the Billing run
    pub weekno: rust_decimal::Decimal,
    /// Billing run number identifier
    pub billrunno: rust_decimal::Decimal,
    /// Unique identifier for the period to which the WDRRR applies. For quarter-based periods, this will be equal to YYYY[Q]NN, for example, 2020Q3 for 2020 Quarter 3.
    pub wdrrrperiod: core::ops::Range<usize>,
    /// Region identifier
    pub regionid: core::ops::Range<usize>,
    /// Financial Responsible Market Participant Identifier
    pub frmp: core::ops::Range<usize>,
    /// Demand Response Service Provider Identifier
    pub drsp: core::ops::Range<usize>,
    /// WDR Settlement Quantity capped in MWh
    pub wdrsq: Option<rust_decimal::Decimal>,
    /// WDR reimbursement rate in $/MWh
    pub wdrrr: Option<rust_decimal::Decimal>,
    /// WDR transaction amount in $ for demand response
    pub wdrta: Option<rust_decimal::Decimal>,
    backing_data: mmsdm_core::CsvRow<'data>,
}
impl<'data> BillingWdrDetail1Row<'data> {
    pub fn wdrrrperiod(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.wdrrrperiod.clone())
    }
    pub fn regionid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.regionid.clone())
    }
    pub fn frmp(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.frmp.clone())
    }
    pub fn drsp(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.drsp.clone())
    }
}
impl mmsdm_core::GetTable for BillingWdrDetail1 {
    const VERSION: i32 = 1;
    const DATA_SET_NAME: &'static str = "BILLING";
    const TABLE_NAME: &'static str = "WDR_DETAIL";
    const DEFAULT_FIELD_MAPPING: Self::FieldMapping = BillingWdrDetail1Mapping([
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
    ]);
    const COLUMNS: &'static [&'static str] = &[
        "CONTRACTYEAR",
        "WEEKNO",
        "BILLRUNNO",
        "WDRRRPERIOD",
        "REGIONID",
        "FRMP",
        "DRSP",
        "WDRSQ",
        "WDRRR",
        "WDRTA",
    ];
    type Row<'row> = BillingWdrDetail1Row<'row>;
    type FieldMapping = BillingWdrDetail1Mapping;
    type PrimaryKey = BillingWdrDetail1PrimaryKey;
    fn from_row<'data>(
        row: mmsdm_core::CsvRow<'data>,
        field_mapping: &Self::FieldMapping,
    ) -> mmsdm_core::Result<Self::Row<'data>> {
        Ok(BillingWdrDetail1Row {
            contractyear: row
                .get_custom_parsed_at_idx(
                    "contractyear",
                    field_mapping.0[0],
                    mmsdm_core::mms_decimal::parse,
                )?,
            weekno: row
                .get_custom_parsed_at_idx(
                    "weekno",
                    field_mapping.0[1],
                    mmsdm_core::mms_decimal::parse,
                )?,
            billrunno: row
                .get_custom_parsed_at_idx(
                    "billrunno",
                    field_mapping.0[2],
                    mmsdm_core::mms_decimal::parse,
                )?,
            wdrrrperiod: row.get_range("wdrrrperiod", field_mapping.0[3])?,
            regionid: row.get_range("regionid", field_mapping.0[4])?,
            frmp: row.get_range("frmp", field_mapping.0[5])?,
            drsp: row.get_range("drsp", field_mapping.0[6])?,
            wdrsq: row
                .get_opt_custom_parsed_at_idx(
                    "wdrsq",
                    field_mapping.0[7],
                    mmsdm_core::mms_decimal::parse,
                )?,
            wdrrr: row
                .get_opt_custom_parsed_at_idx(
                    "wdrrr",
                    field_mapping.0[8],
                    mmsdm_core::mms_decimal::parse,
                )?,
            wdrta: row
                .get_opt_custom_parsed_at_idx(
                    "wdrta",
                    field_mapping.0[9],
                    mmsdm_core::mms_decimal::parse,
                )?,
            backing_data: row,
        })
    }
    fn field_mapping_from_row<'a>(
        mut row: mmsdm_core::CsvRow<'a>,
    ) -> mmsdm_core::Result<Self::FieldMapping> {
        if !row.is_heading() {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!("Expected an I row but got {row:?}"),
                ),
            );
        }
        let row_key = mmsdm_core::FileKey::from_row(row.borrow())?;
        if !Self::matches_file_key(&row_key, row_key.version) {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!(
                        "Expected a row matching {}.{}.v{} but got {row_key}",
                        Self::DATA_SET_NAME, Self::TABLE_NAME, Self::VERSION
                    ),
                ),
            );
        }
        let mut base_mapping = Self::DEFAULT_FIELD_MAPPING.0;
        for (field_index, field) in Self::COLUMNS.iter().enumerate() {
            base_mapping[field_index] = row
                .iter_fields()
                .position(|f| f == *field)
                .unwrap_or(usize::MAX);
        }
        Ok(BillingWdrDetail1Mapping(base_mapping))
    }
    fn matches_file_key(key: &mmsdm_core::FileKey<'_>, version: i32) -> bool {
        version == key.version && Self::DATA_SET_NAME == key.data_set_name()
            && Self::TABLE_NAME == key.table_name()
    }
    fn primary_key(row: &Self::Row<'_>) -> BillingWdrDetail1PrimaryKey {
        BillingWdrDetail1PrimaryKey {
            billrunno: row.billrunno,
            contractyear: row.contractyear,
            drsp: row.drsp().to_string(),
            frmp: row.frmp().to_string(),
            regionid: row.regionid().to_string(),
            wdrrrperiod: row.wdrrrperiod().to_string(),
            weekno: row.weekno,
        }
    }
    fn partition_value(&self, row: &Self::Row<'_>) -> mmsdm_core::PartitionValue {
        (self.extract_row_partition)(row)
    }
    fn partition_name(&self, row: &Self::Row<'_>) -> alloc::string::String {
        alloc::format!("billing_wdr_detail_v1_{}", self.partition_value(row))
    }
    fn partition_key(&self) -> mmsdm_core::PartitionKey {
        self.row_partition_key
    }
    fn to_static<'a>(row: &Self::Row<'a>) -> Self::Row<'static> {
        BillingWdrDetail1Row {
            contractyear: row.contractyear.clone(),
            weekno: row.weekno.clone(),
            billrunno: row.billrunno.clone(),
            wdrrrperiod: row.wdrrrperiod.clone(),
            regionid: row.regionid.clone(),
            frmp: row.frmp.clone(),
            drsp: row.drsp.clone(),
            wdrsq: row.wdrsq.clone(),
            wdrrr: row.wdrrr.clone(),
            wdrta: row.wdrta.clone(),
            backing_data: row.backing_data.to_owned(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct BillingWdrDetail1PrimaryKey {
    pub billrunno: rust_decimal::Decimal,
    pub contractyear: rust_decimal::Decimal,
    pub drsp: alloc::string::String,
    pub frmp: alloc::string::String,
    pub regionid: alloc::string::String,
    pub wdrrrperiod: alloc::string::String,
    pub weekno: rust_decimal::Decimal,
}
impl mmsdm_core::PrimaryKey for BillingWdrDetail1PrimaryKey {}
impl<'data> mmsdm_core::CompareWithRow for BillingWdrDetail1Row<'data> {
    type Row<'other> = BillingWdrDetail1Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.drsp() == row.drsp() && self.frmp() == row.frmp()
            && self.regionid() == row.regionid()
            && self.wdrrrperiod() == row.wdrrrperiod() && self.weekno == row.weekno
    }
}
impl<'data> mmsdm_core::CompareWithPrimaryKey for BillingWdrDetail1Row<'data> {
    type PrimaryKey = BillingWdrDetail1PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.drsp() == key.drsp && self.frmp() == key.frmp
            && self.regionid() == key.regionid && self.wdrrrperiod() == key.wdrrrperiod
            && self.weekno == key.weekno
    }
}
impl<'data> mmsdm_core::CompareWithRow for BillingWdrDetail1PrimaryKey {
    type Row<'other> = BillingWdrDetail1Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.drsp == row.drsp() && self.frmp == row.frmp()
            && self.regionid == row.regionid() && self.wdrrrperiod == row.wdrrrperiod()
            && self.weekno == row.weekno
    }
}
impl mmsdm_core::CompareWithPrimaryKey for BillingWdrDetail1PrimaryKey {
    type PrimaryKey = BillingWdrDetail1PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.drsp == key.drsp && self.frmp == key.frmp
            && self.regionid == key.regionid && self.wdrrrperiod == key.wdrrrperiod
            && self.weekno == key.weekno
    }
}
#[cfg(feature = "arrow")]
impl mmsdm_core::ArrowSchema for BillingWdrDetail1 {
    type Builder = BillingWdrDetail1Builder;
    fn schema() -> arrow::datatypes::Schema {
        arrow::datatypes::Schema::new(
            alloc::vec::Vec::from([
                arrow::datatypes::Field::new(
                    "contractyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "weekno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "billrunno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "wdrrrperiod",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "regionid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "frmp",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "drsp",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "wdrsq",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "wdrrr",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "wdrta",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
            ]),
        )
    }
    fn new_builder() -> Self::Builder {
        BillingWdrDetail1Builder {
            contractyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            weekno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            billrunno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            wdrrrperiod_array: arrow::array::builder::StringBuilder::new(),
            regionid_array: arrow::array::builder::StringBuilder::new(),
            frmp_array: arrow::array::builder::StringBuilder::new(),
            drsp_array: arrow::array::builder::StringBuilder::new(),
            wdrsq_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            wdrrr_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            wdrta_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
        }
    }
    fn append_builder(builder: &mut Self::Builder, row: Self::Row<'_>) {
        builder
            .contractyear_array
            .append_value({
                let mut val = row.contractyear;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .weekno_array
            .append_value({
                let mut val = row.weekno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .billrunno_array
            .append_value({
                let mut val = row.billrunno;
                val.rescale(0);
                val.mantissa()
            });
        builder.wdrrrperiod_array.append_value(row.wdrrrperiod());
        builder.regionid_array.append_value(row.regionid());
        builder.frmp_array.append_value(row.frmp());
        builder.drsp_array.append_value(row.drsp());
        builder
            .wdrsq_array
            .append_option({
                row.wdrsq
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .wdrrr_array
            .append_option({
                row.wdrrr
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .wdrta_array
            .append_option({
                row.wdrta
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
    }
    fn finalize_builder(
        builder: &mut Self::Builder,
    ) -> mmsdm_core::Result<arrow::array::RecordBatch> {
        arrow::array::RecordBatch::try_new(
                alloc::sync::Arc::new(<Self as mmsdm_core::ArrowSchema>::schema()),
                alloc::vec::Vec::from([
                    alloc::sync::Arc::new(builder.contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.wdrrrperiod_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.regionid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.frmp_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.drsp_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.wdrsq_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.wdrrr_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.wdrta_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                ]),
            )
            .map_err(Into::into)
    }
}
#[cfg(feature = "arrow")]
pub struct BillingWdrDetail1Builder {
    contractyear_array: arrow::array::builder::Decimal128Builder,
    weekno_array: arrow::array::builder::Decimal128Builder,
    billrunno_array: arrow::array::builder::Decimal128Builder,
    wdrrrperiod_array: arrow::array::builder::StringBuilder,
    regionid_array: arrow::array::builder::StringBuilder,
    frmp_array: arrow::array::builder::StringBuilder,
    drsp_array: arrow::array::builder::StringBuilder,
    wdrsq_array: arrow::array::builder::Decimal128Builder,
    wdrrr_array: arrow::array::builder::Decimal128Builder,
    wdrta_array: arrow::array::builder::Decimal128Builder,
}
pub struct BillingReservetraderpayment1 {
    extract_row_partition: alloc::boxed::Box<
        dyn Fn(
            &BillingReservetraderpayment1Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    >,
    row_partition_key: mmsdm_core::PartitionKey,
}
impl BillingReservetraderpayment1 {
    pub fn new(
        row_partition_key: mmsdm_core::PartitionKey,
        func: impl Fn(
            &<Self as mmsdm_core::GetTable>::Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    ) -> Self {
        Self {
            extract_row_partition: alloc::boxed::Box::new(func),
            row_partition_key,
        }
    }
}
pub struct BillingReservetraderpayment1Mapping([usize; 8]);
/// # Summary
///
/// ## BILLRESERVETRADERPAYMENT
///  _Details of the RERT Usage and Availability Payments made to the participant._
///
/// * Data Set Name: Billing
/// * File Name: Reservetraderpayment
/// * Data Version: 1
///
///
///
///
///
/// # Primary Key Columns
///
/// * BILLRUNNO
/// * CONTRACTID
/// * CONTRACTYEAR
/// * PAYMENT_ID
/// * WEEKNO
#[derive(Debug, PartialEq, Eq)]
pub struct BillingReservetraderpayment1Row<'data> {
    /// Billing contract year
    pub contractyear: rust_decimal::Decimal,
    /// Billing week number
    pub weekno: rust_decimal::Decimal,
    /// Billing posted run number
    pub billrunno: rust_decimal::Decimal,
    /// Participant identifier.
    pub participantid: core::ops::Range<usize>,
    /// RERT payment contract ID
    pub contractid: core::ops::Range<usize>,
    /// RERT payment number
    pub payment_id: rust_decimal::Decimal,
    /// Description for the reserve trader contract payment amount.
    pub payment_type: core::ops::Range<usize>,
    /// RERT payment amount for the payment type
    pub payment_amount: Option<rust_decimal::Decimal>,
    backing_data: mmsdm_core::CsvRow<'data>,
}
impl<'data> BillingReservetraderpayment1Row<'data> {
    pub fn participantid(&self) -> Option<&str> {
        if self.participantid.is_empty() {
            None
        } else {
            Some(
                core::ops::Index::index(
                    self.backing_data.as_slice(),
                    self.participantid.clone(),
                ),
            )
        }
    }
    pub fn contractid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.contractid.clone())
    }
    pub fn payment_type(&self) -> Option<&str> {
        if self.payment_type.is_empty() {
            None
        } else {
            Some(
                core::ops::Index::index(
                    self.backing_data.as_slice(),
                    self.payment_type.clone(),
                ),
            )
        }
    }
}
impl mmsdm_core::GetTable for BillingReservetraderpayment1 {
    const VERSION: i32 = 1;
    const DATA_SET_NAME: &'static str = "BILLING";
    const TABLE_NAME: &'static str = "RESERVETRADERPAYMENT";
    const DEFAULT_FIELD_MAPPING: Self::FieldMapping = BillingReservetraderpayment1Mapping([
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
    ]);
    const COLUMNS: &'static [&'static str] = &[
        "CONTRACTYEAR",
        "WEEKNO",
        "BILLRUNNO",
        "PARTICIPANTID",
        "CONTRACTID",
        "PAYMENT_ID",
        "PAYMENT_TYPE",
        "PAYMENT_AMOUNT",
    ];
    type Row<'row> = BillingReservetraderpayment1Row<'row>;
    type FieldMapping = BillingReservetraderpayment1Mapping;
    type PrimaryKey = BillingReservetraderpayment1PrimaryKey;
    fn from_row<'data>(
        row: mmsdm_core::CsvRow<'data>,
        field_mapping: &Self::FieldMapping,
    ) -> mmsdm_core::Result<Self::Row<'data>> {
        Ok(BillingReservetraderpayment1Row {
            contractyear: row
                .get_custom_parsed_at_idx(
                    "contractyear",
                    field_mapping.0[0],
                    mmsdm_core::mms_decimal::parse,
                )?,
            weekno: row
                .get_custom_parsed_at_idx(
                    "weekno",
                    field_mapping.0[1],
                    mmsdm_core::mms_decimal::parse,
                )?,
            billrunno: row
                .get_custom_parsed_at_idx(
                    "billrunno",
                    field_mapping.0[2],
                    mmsdm_core::mms_decimal::parse,
                )?,
            participantid: row.get_opt_range("participantid", field_mapping.0[3])?,
            contractid: row.get_range("contractid", field_mapping.0[4])?,
            payment_id: row
                .get_custom_parsed_at_idx(
                    "payment_id",
                    field_mapping.0[5],
                    mmsdm_core::mms_decimal::parse,
                )?,
            payment_type: row.get_opt_range("payment_type", field_mapping.0[6])?,
            payment_amount: row
                .get_opt_custom_parsed_at_idx(
                    "payment_amount",
                    field_mapping.0[7],
                    mmsdm_core::mms_decimal::parse,
                )?,
            backing_data: row,
        })
    }
    fn field_mapping_from_row<'a>(
        mut row: mmsdm_core::CsvRow<'a>,
    ) -> mmsdm_core::Result<Self::FieldMapping> {
        if !row.is_heading() {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!("Expected an I row but got {row:?}"),
                ),
            );
        }
        let row_key = mmsdm_core::FileKey::from_row(row.borrow())?;
        if !Self::matches_file_key(&row_key, row_key.version) {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!(
                        "Expected a row matching {}.{}.v{} but got {row_key}",
                        Self::DATA_SET_NAME, Self::TABLE_NAME, Self::VERSION
                    ),
                ),
            );
        }
        let mut base_mapping = Self::DEFAULT_FIELD_MAPPING.0;
        for (field_index, field) in Self::COLUMNS.iter().enumerate() {
            base_mapping[field_index] = row
                .iter_fields()
                .position(|f| f == *field)
                .unwrap_or(usize::MAX);
        }
        Ok(BillingReservetraderpayment1Mapping(base_mapping))
    }
    fn matches_file_key(key: &mmsdm_core::FileKey<'_>, version: i32) -> bool {
        version == key.version && Self::DATA_SET_NAME == key.data_set_name()
            && Self::TABLE_NAME == key.table_name()
    }
    fn primary_key(row: &Self::Row<'_>) -> BillingReservetraderpayment1PrimaryKey {
        BillingReservetraderpayment1PrimaryKey {
            billrunno: row.billrunno,
            contractid: row.contractid().to_string(),
            contractyear: row.contractyear,
            payment_id: row.payment_id,
            weekno: row.weekno,
        }
    }
    fn partition_value(&self, row: &Self::Row<'_>) -> mmsdm_core::PartitionValue {
        (self.extract_row_partition)(row)
    }
    fn partition_name(&self, row: &Self::Row<'_>) -> alloc::string::String {
        alloc::format!("billing_reservetraderpayment_v1_{}", self.partition_value(row))
    }
    fn partition_key(&self) -> mmsdm_core::PartitionKey {
        self.row_partition_key
    }
    fn to_static<'a>(row: &Self::Row<'a>) -> Self::Row<'static> {
        BillingReservetraderpayment1Row {
            contractyear: row.contractyear.clone(),
            weekno: row.weekno.clone(),
            billrunno: row.billrunno.clone(),
            participantid: row.participantid.clone(),
            contractid: row.contractid.clone(),
            payment_id: row.payment_id.clone(),
            payment_type: row.payment_type.clone(),
            payment_amount: row.payment_amount.clone(),
            backing_data: row.backing_data.to_owned(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct BillingReservetraderpayment1PrimaryKey {
    pub billrunno: rust_decimal::Decimal,
    pub contractid: alloc::string::String,
    pub contractyear: rust_decimal::Decimal,
    pub payment_id: rust_decimal::Decimal,
    pub weekno: rust_decimal::Decimal,
}
impl mmsdm_core::PrimaryKey for BillingReservetraderpayment1PrimaryKey {}
impl<'data> mmsdm_core::CompareWithRow for BillingReservetraderpayment1Row<'data> {
    type Row<'other> = BillingReservetraderpayment1Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractid() == row.contractid()
            && self.contractyear == row.contractyear && self.payment_id == row.payment_id
            && self.weekno == row.weekno
    }
}
impl<'data> mmsdm_core::CompareWithPrimaryKey
for BillingReservetraderpayment1Row<'data> {
    type PrimaryKey = BillingReservetraderpayment1PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractid() == key.contractid
            && self.contractyear == key.contractyear && self.payment_id == key.payment_id
            && self.weekno == key.weekno
    }
}
impl<'data> mmsdm_core::CompareWithRow for BillingReservetraderpayment1PrimaryKey {
    type Row<'other> = BillingReservetraderpayment1Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractid == row.contractid()
            && self.contractyear == row.contractyear && self.payment_id == row.payment_id
            && self.weekno == row.weekno
    }
}
impl mmsdm_core::CompareWithPrimaryKey for BillingReservetraderpayment1PrimaryKey {
    type PrimaryKey = BillingReservetraderpayment1PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractid == key.contractid
            && self.contractyear == key.contractyear && self.payment_id == key.payment_id
            && self.weekno == key.weekno
    }
}
#[cfg(feature = "arrow")]
impl mmsdm_core::ArrowSchema for BillingReservetraderpayment1 {
    type Builder = BillingReservetraderpayment1Builder;
    fn schema() -> arrow::datatypes::Schema {
        arrow::datatypes::Schema::new(
            alloc::vec::Vec::from([
                arrow::datatypes::Field::new(
                    "contractyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "weekno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "billrunno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "participantid",
                    arrow::datatypes::DataType::Utf8,
                    true,
                ),
                arrow::datatypes::Field::new(
                    "contractid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "payment_id",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "payment_type",
                    arrow::datatypes::DataType::Utf8,
                    true,
                ),
                arrow::datatypes::Field::new(
                    "payment_amount",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
            ]),
        )
    }
    fn new_builder() -> Self::Builder {
        BillingReservetraderpayment1Builder {
            contractyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            weekno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            billrunno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            participantid_array: arrow::array::builder::StringBuilder::new(),
            contractid_array: arrow::array::builder::StringBuilder::new(),
            payment_id_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            payment_type_array: arrow::array::builder::StringBuilder::new(),
            payment_amount_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
        }
    }
    fn append_builder(builder: &mut Self::Builder, row: Self::Row<'_>) {
        builder
            .contractyear_array
            .append_value({
                let mut val = row.contractyear;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .weekno_array
            .append_value({
                let mut val = row.weekno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .billrunno_array
            .append_value({
                let mut val = row.billrunno;
                val.rescale(0);
                val.mantissa()
            });
        builder.participantid_array.append_option(row.participantid());
        builder.contractid_array.append_value(row.contractid());
        builder
            .payment_id_array
            .append_value({
                let mut val = row.payment_id;
                val.rescale(0);
                val.mantissa()
            });
        builder.payment_type_array.append_option(row.payment_type());
        builder
            .payment_amount_array
            .append_option({
                row.payment_amount
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
    }
    fn finalize_builder(
        builder: &mut Self::Builder,
    ) -> mmsdm_core::Result<arrow::array::RecordBatch> {
        arrow::array::RecordBatch::try_new(
                alloc::sync::Arc::new(<Self as mmsdm_core::ArrowSchema>::schema()),
                alloc::vec::Vec::from([
                    alloc::sync::Arc::new(builder.contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.participantid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.contractid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.payment_id_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.payment_type_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.payment_amount_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                ]),
            )
            .map_err(Into::into)
    }
}
#[cfg(feature = "arrow")]
pub struct BillingReservetraderpayment1Builder {
    contractyear_array: arrow::array::builder::Decimal128Builder,
    weekno_array: arrow::array::builder::Decimal128Builder,
    billrunno_array: arrow::array::builder::Decimal128Builder,
    participantid_array: arrow::array::builder::StringBuilder,
    contractid_array: arrow::array::builder::StringBuilder,
    payment_id_array: arrow::array::builder::Decimal128Builder,
    payment_type_array: arrow::array::builder::StringBuilder,
    payment_amount_array: arrow::array::builder::Decimal128Builder,
}
pub struct BillingReservetraderrecovery3 {
    extract_row_partition: alloc::boxed::Box<
        dyn Fn(
            &BillingReservetraderrecovery3Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    >,
    row_partition_key: mmsdm_core::PartitionKey,
}
impl BillingReservetraderrecovery3 {
    pub fn new(
        row_partition_key: mmsdm_core::PartitionKey,
        func: impl Fn(
            &<Self as mmsdm_core::GetTable>::Row<'_>,
        ) -> mmsdm_core::PartitionValue + Send + Sync + 'static,
    ) -> Self {
        Self {
            extract_row_partition: alloc::boxed::Box::new(func),
            row_partition_key,
        }
    }
}
pub struct BillingReservetraderrecovery3Mapping([usize; 16]);
/// # Summary
///
/// ## BILLRESERVETRADERRECOVERY
///  _Provides details of the RERT Recovery Amount for the Market Customers._
///
/// * Data Set Name: Billing
/// * File Name: Reservetraderrecovery
/// * Data Version: 3
///
///
///
///
///
/// # Primary Key Columns
///
/// * BILLRUNNO
/// * CONTRACTYEAR
/// * PARTICIPANTID
/// * PAYMENT_ID
/// * PUBLICATION_ID
/// * REGIONID
/// * WEEKNO
#[derive(Debug, PartialEq, Eq)]
pub struct BillingReservetraderrecovery3Row<'data> {
    /// Billing contract year
    pub contractyear: rust_decimal::Decimal,
    /// Billing week number
    pub weekno: rust_decimal::Decimal,
    /// Billing posted run number
    pub billrunno: rust_decimal::Decimal,
    /// Unique Publication Identifier for RERT Payment
    pub publication_id: core::ops::Range<usize>,
    /// RERT payment number
    pub payment_id: rust_decimal::Decimal,
    /// RERT payment amount
    pub payment_amount: Option<rust_decimal::Decimal>,
    /// Participant identifier.
    pub participantid: core::ops::Range<usize>,
    /// Region from which the amount is recovered
    pub regionid: core::ops::Range<usize>,
    /// Participant Demand Value used for RERT Recovery. NULL for Billing Week post the IESS rule effective date.
    pub participant_demand: Option<rust_decimal::Decimal>,
    /// Region Demand Value used for RERT Recovery. NULL for Billing Week post the IESS rule effective date.
    pub region_demand: Option<rust_decimal::Decimal>,
    /// Starting Period of RERT Recovery for Usage Payments
    pub eligibility_start_interval: Option<chrono::NaiveDateTime>,
    /// Ending Period of RERT Recovery for Usage Payments
    pub eligibility_end_interval: Option<chrono::NaiveDateTime>,
    /// Recovery Amount applicable for each Market Customer
    pub recovery_amount: Option<rust_decimal::Decimal>,
    /// The Energy Value (Scheduled Loads) that is excluded
    pub excluded_energy: Option<rust_decimal::Decimal>,
    /// The Participant ACE MWh Value used in the Recovery of the RERT Amount. NULL for Billing Week prior to the IESS rule effective date
    pub participant_ace_mwh: Option<rust_decimal::Decimal>,
    /// The Region ACE MWh Value used in the Recovery of the RERT Amount. NULL for Billing Week prior to the IESS rule effective date
    pub region_ace_mwh: Option<rust_decimal::Decimal>,
    backing_data: mmsdm_core::CsvRow<'data>,
}
impl<'data> BillingReservetraderrecovery3Row<'data> {
    pub fn publication_id(&self) -> &str {
        core::ops::Index::index(
            self.backing_data.as_slice(),
            self.publication_id.clone(),
        )
    }
    pub fn participantid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.participantid.clone())
    }
    pub fn regionid(&self) -> &str {
        core::ops::Index::index(self.backing_data.as_slice(), self.regionid.clone())
    }
}
impl mmsdm_core::GetTable for BillingReservetraderrecovery3 {
    const VERSION: i32 = 3;
    const DATA_SET_NAME: &'static str = "BILLING";
    const TABLE_NAME: &'static str = "RESERVETRADERRECOVERY";
    const DEFAULT_FIELD_MAPPING: Self::FieldMapping = BillingReservetraderrecovery3Mapping([
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
    ]);
    const COLUMNS: &'static [&'static str] = &[
        "CONTRACTYEAR",
        "WEEKNO",
        "BILLRUNNO",
        "PUBLICATION_ID",
        "PAYMENT_ID",
        "PAYMENT_AMOUNT",
        "PARTICIPANTID",
        "REGIONID",
        "PARTICIPANT_DEMAND",
        "REGION_DEMAND",
        "ELIGIBILITY_START_INTERVAL",
        "ELIGIBILITY_END_INTERVAL",
        "RECOVERY_AMOUNT",
        "EXCLUDED_ENERGY",
        "PARTICIPANT_ACE_MWH",
        "REGION_ACE_MWH",
    ];
    type Row<'row> = BillingReservetraderrecovery3Row<'row>;
    type FieldMapping = BillingReservetraderrecovery3Mapping;
    type PrimaryKey = BillingReservetraderrecovery3PrimaryKey;
    fn from_row<'data>(
        row: mmsdm_core::CsvRow<'data>,
        field_mapping: &Self::FieldMapping,
    ) -> mmsdm_core::Result<Self::Row<'data>> {
        Ok(BillingReservetraderrecovery3Row {
            contractyear: row
                .get_custom_parsed_at_idx(
                    "contractyear",
                    field_mapping.0[0],
                    mmsdm_core::mms_decimal::parse,
                )?,
            weekno: row
                .get_custom_parsed_at_idx(
                    "weekno",
                    field_mapping.0[1],
                    mmsdm_core::mms_decimal::parse,
                )?,
            billrunno: row
                .get_custom_parsed_at_idx(
                    "billrunno",
                    field_mapping.0[2],
                    mmsdm_core::mms_decimal::parse,
                )?,
            publication_id: row.get_range("publication_id", field_mapping.0[3])?,
            payment_id: row
                .get_custom_parsed_at_idx(
                    "payment_id",
                    field_mapping.0[4],
                    mmsdm_core::mms_decimal::parse,
                )?,
            payment_amount: row
                .get_opt_custom_parsed_at_idx(
                    "payment_amount",
                    field_mapping.0[5],
                    mmsdm_core::mms_decimal::parse,
                )?,
            participantid: row.get_range("participantid", field_mapping.0[6])?,
            regionid: row.get_range("regionid", field_mapping.0[7])?,
            participant_demand: row
                .get_opt_custom_parsed_at_idx(
                    "participant_demand",
                    field_mapping.0[8],
                    mmsdm_core::mms_decimal::parse,
                )?,
            region_demand: row
                .get_opt_custom_parsed_at_idx(
                    "region_demand",
                    field_mapping.0[9],
                    mmsdm_core::mms_decimal::parse,
                )?,
            eligibility_start_interval: row
                .get_opt_custom_parsed_at_idx(
                    "eligibility_start_interval",
                    field_mapping.0[10],
                    mmsdm_core::mms_datetime::parse,
                )?,
            eligibility_end_interval: row
                .get_opt_custom_parsed_at_idx(
                    "eligibility_end_interval",
                    field_mapping.0[11],
                    mmsdm_core::mms_datetime::parse,
                )?,
            recovery_amount: row
                .get_opt_custom_parsed_at_idx(
                    "recovery_amount",
                    field_mapping.0[12],
                    mmsdm_core::mms_decimal::parse,
                )?,
            excluded_energy: row
                .get_opt_custom_parsed_at_idx(
                    "excluded_energy",
                    field_mapping.0[13],
                    mmsdm_core::mms_decimal::parse,
                )?,
            participant_ace_mwh: row
                .get_opt_custom_parsed_at_idx(
                    "participant_ace_mwh",
                    field_mapping.0[14],
                    mmsdm_core::mms_decimal::parse,
                )?,
            region_ace_mwh: row
                .get_opt_custom_parsed_at_idx(
                    "region_ace_mwh",
                    field_mapping.0[15],
                    mmsdm_core::mms_decimal::parse,
                )?,
            backing_data: row,
        })
    }
    fn field_mapping_from_row<'a>(
        mut row: mmsdm_core::CsvRow<'a>,
    ) -> mmsdm_core::Result<Self::FieldMapping> {
        if !row.is_heading() {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!("Expected an I row but got {row:?}"),
                ),
            );
        }
        let row_key = mmsdm_core::FileKey::from_row(row.borrow())?;
        if !Self::matches_file_key(&row_key, row_key.version) {
            return Err(
                mmsdm_core::Error::UnexpectedRowType(
                    alloc::format!(
                        "Expected a row matching {}.{}.v{} but got {row_key}",
                        Self::DATA_SET_NAME, Self::TABLE_NAME, Self::VERSION
                    ),
                ),
            );
        }
        let mut base_mapping = Self::DEFAULT_FIELD_MAPPING.0;
        for (field_index, field) in Self::COLUMNS.iter().enumerate() {
            base_mapping[field_index] = row
                .iter_fields()
                .position(|f| f == *field)
                .unwrap_or(usize::MAX);
        }
        Ok(BillingReservetraderrecovery3Mapping(base_mapping))
    }
    fn matches_file_key(key: &mmsdm_core::FileKey<'_>, version: i32) -> bool {
        version == key.version && Self::DATA_SET_NAME == key.data_set_name()
            && Self::TABLE_NAME == key.table_name()
    }
    fn primary_key(row: &Self::Row<'_>) -> BillingReservetraderrecovery3PrimaryKey {
        BillingReservetraderrecovery3PrimaryKey {
            billrunno: row.billrunno,
            contractyear: row.contractyear,
            participantid: row.participantid().to_string(),
            payment_id: row.payment_id,
            publication_id: row.publication_id().to_string(),
            regionid: row.regionid().to_string(),
            weekno: row.weekno,
        }
    }
    fn partition_value(&self, row: &Self::Row<'_>) -> mmsdm_core::PartitionValue {
        (self.extract_row_partition)(row)
    }
    fn partition_name(&self, row: &Self::Row<'_>) -> alloc::string::String {
        alloc::format!("billing_reservetraderrecovery_v3_{}", self.partition_value(row))
    }
    fn partition_key(&self) -> mmsdm_core::PartitionKey {
        self.row_partition_key
    }
    fn to_static<'a>(row: &Self::Row<'a>) -> Self::Row<'static> {
        BillingReservetraderrecovery3Row {
            contractyear: row.contractyear.clone(),
            weekno: row.weekno.clone(),
            billrunno: row.billrunno.clone(),
            publication_id: row.publication_id.clone(),
            payment_id: row.payment_id.clone(),
            payment_amount: row.payment_amount.clone(),
            participantid: row.participantid.clone(),
            regionid: row.regionid.clone(),
            participant_demand: row.participant_demand.clone(),
            region_demand: row.region_demand.clone(),
            eligibility_start_interval: row.eligibility_start_interval.clone(),
            eligibility_end_interval: row.eligibility_end_interval.clone(),
            recovery_amount: row.recovery_amount.clone(),
            excluded_energy: row.excluded_energy.clone(),
            participant_ace_mwh: row.participant_ace_mwh.clone(),
            region_ace_mwh: row.region_ace_mwh.clone(),
            backing_data: row.backing_data.to_owned(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct BillingReservetraderrecovery3PrimaryKey {
    pub billrunno: rust_decimal::Decimal,
    pub contractyear: rust_decimal::Decimal,
    pub participantid: alloc::string::String,
    pub payment_id: rust_decimal::Decimal,
    pub publication_id: alloc::string::String,
    pub regionid: alloc::string::String,
    pub weekno: rust_decimal::Decimal,
}
impl mmsdm_core::PrimaryKey for BillingReservetraderrecovery3PrimaryKey {}
impl<'data> mmsdm_core::CompareWithRow for BillingReservetraderrecovery3Row<'data> {
    type Row<'other> = BillingReservetraderrecovery3Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.participantid() == row.participantid()
            && self.payment_id == row.payment_id
            && self.publication_id() == row.publication_id()
            && self.regionid() == row.regionid() && self.weekno == row.weekno
    }
}
impl<'data> mmsdm_core::CompareWithPrimaryKey
for BillingReservetraderrecovery3Row<'data> {
    type PrimaryKey = BillingReservetraderrecovery3PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.participantid() == key.participantid
            && self.payment_id == key.payment_id
            && self.publication_id() == key.publication_id
            && self.regionid() == key.regionid && self.weekno == key.weekno
    }
}
impl<'data> mmsdm_core::CompareWithRow for BillingReservetraderrecovery3PrimaryKey {
    type Row<'other> = BillingReservetraderrecovery3Row<'other>;
    fn compare_with_row<'other>(&self, row: &Self::Row<'other>) -> bool {
        self.billrunno == row.billrunno && self.contractyear == row.contractyear
            && self.participantid == row.participantid()
            && self.payment_id == row.payment_id
            && self.publication_id == row.publication_id()
            && self.regionid == row.regionid() && self.weekno == row.weekno
    }
}
impl mmsdm_core::CompareWithPrimaryKey for BillingReservetraderrecovery3PrimaryKey {
    type PrimaryKey = BillingReservetraderrecovery3PrimaryKey;
    fn compare_with_key(&self, key: &Self::PrimaryKey) -> bool {
        self.billrunno == key.billrunno && self.contractyear == key.contractyear
            && self.participantid == key.participantid
            && self.payment_id == key.payment_id
            && self.publication_id == key.publication_id && self.regionid == key.regionid
            && self.weekno == key.weekno
    }
}
#[cfg(feature = "arrow")]
impl mmsdm_core::ArrowSchema for BillingReservetraderrecovery3 {
    type Builder = BillingReservetraderrecovery3Builder;
    fn schema() -> arrow::datatypes::Schema {
        arrow::datatypes::Schema::new(
            alloc::vec::Vec::from([
                arrow::datatypes::Field::new(
                    "contractyear",
                    arrow::datatypes::DataType::Decimal128(4, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "weekno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "billrunno",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "publication_id",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "payment_id",
                    arrow::datatypes::DataType::Decimal128(3, 0),
                    false,
                ),
                arrow::datatypes::Field::new(
                    "payment_amount",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "participantid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "regionid",
                    arrow::datatypes::DataType::Utf8,
                    false,
                ),
                arrow::datatypes::Field::new(
                    "participant_demand",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "region_demand",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "eligibility_start_interval",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "eligibility_end_interval",
                    arrow::datatypes::DataType::Timestamp(
                        arrow::datatypes::TimeUnit::Millisecond,
                        None,
                    ),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "recovery_amount",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "excluded_energy",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "participant_ace_mwh",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
                arrow::datatypes::Field::new(
                    "region_ace_mwh",
                    arrow::datatypes::DataType::Decimal128(18, 8),
                    true,
                ),
            ]),
        )
    }
    fn new_builder() -> Self::Builder {
        BillingReservetraderrecovery3Builder {
            contractyear_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(4, 0)),
            weekno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            billrunno_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            publication_id_array: arrow::array::builder::StringBuilder::new(),
            payment_id_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(3, 0)),
            payment_amount_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            participantid_array: arrow::array::builder::StringBuilder::new(),
            regionid_array: arrow::array::builder::StringBuilder::new(),
            participant_demand_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            region_demand_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            eligibility_start_interval_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
            eligibility_end_interval_array: arrow::array::builder::TimestampMillisecondBuilder::new(),
            recovery_amount_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            excluded_energy_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            participant_ace_mwh_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
            region_ace_mwh_array: arrow::array::builder::Decimal128Builder::new()
                .with_data_type(arrow::datatypes::DataType::Decimal128(18, 8)),
        }
    }
    fn append_builder(builder: &mut Self::Builder, row: Self::Row<'_>) {
        builder
            .contractyear_array
            .append_value({
                let mut val = row.contractyear;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .weekno_array
            .append_value({
                let mut val = row.weekno;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .billrunno_array
            .append_value({
                let mut val = row.billrunno;
                val.rescale(0);
                val.mantissa()
            });
        builder.publication_id_array.append_value(row.publication_id());
        builder
            .payment_id_array
            .append_value({
                let mut val = row.payment_id;
                val.rescale(0);
                val.mantissa()
            });
        builder
            .payment_amount_array
            .append_option({
                row.payment_amount
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder.participantid_array.append_value(row.participantid());
        builder.regionid_array.append_value(row.regionid());
        builder
            .participant_demand_array
            .append_option({
                row.participant_demand
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .region_demand_array
            .append_option({
                row.region_demand
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .eligibility_start_interval_array
            .append_option(
                row
                    .eligibility_start_interval
                    .map(|val| val.and_utc().timestamp_millis()),
            );
        builder
            .eligibility_end_interval_array
            .append_option(
                row.eligibility_end_interval.map(|val| val.and_utc().timestamp_millis()),
            );
        builder
            .recovery_amount_array
            .append_option({
                row.recovery_amount
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .excluded_energy_array
            .append_option({
                row.excluded_energy
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .participant_ace_mwh_array
            .append_option({
                row.participant_ace_mwh
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
        builder
            .region_ace_mwh_array
            .append_option({
                row.region_ace_mwh
                    .map(|mut val| {
                        val.rescale(8);
                        val.mantissa()
                    })
            });
    }
    fn finalize_builder(
        builder: &mut Self::Builder,
    ) -> mmsdm_core::Result<arrow::array::RecordBatch> {
        arrow::array::RecordBatch::try_new(
                alloc::sync::Arc::new(<Self as mmsdm_core::ArrowSchema>::schema()),
                alloc::vec::Vec::from([
                    alloc::sync::Arc::new(builder.contractyear_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.weekno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.billrunno_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.publication_id_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.payment_id_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.payment_amount_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.participantid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.regionid_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.participant_demand_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.region_demand_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(
                        builder.eligibility_start_interval_array.finish(),
                    ) as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(
                        builder.eligibility_end_interval_array.finish(),
                    ) as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.recovery_amount_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.excluded_energy_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.participant_ace_mwh_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                    alloc::sync::Arc::new(builder.region_ace_mwh_array.finish())
                        as alloc::sync::Arc<dyn arrow::array::Array>,
                ]),
            )
            .map_err(Into::into)
    }
}
#[cfg(feature = "arrow")]
pub struct BillingReservetraderrecovery3Builder {
    contractyear_array: arrow::array::builder::Decimal128Builder,
    weekno_array: arrow::array::builder::Decimal128Builder,
    billrunno_array: arrow::array::builder::Decimal128Builder,
    publication_id_array: arrow::array::builder::StringBuilder,
    payment_id_array: arrow::array::builder::Decimal128Builder,
    payment_amount_array: arrow::array::builder::Decimal128Builder,
    participantid_array: arrow::array::builder::StringBuilder,
    regionid_array: arrow::array::builder::StringBuilder,
    participant_demand_array: arrow::array::builder::Decimal128Builder,
    region_demand_array: arrow::array::builder::Decimal128Builder,
    eligibility_start_interval_array: arrow::array::builder::TimestampMillisecondBuilder,
    eligibility_end_interval_array: arrow::array::builder::TimestampMillisecondBuilder,
    recovery_amount_array: arrow::array::builder::Decimal128Builder,
    excluded_energy_array: arrow::array::builder::Decimal128Builder,
    participant_ace_mwh_array: arrow::array::builder::Decimal128Builder,
    region_ace_mwh_array: arrow::array::builder::Decimal128Builder,
}
